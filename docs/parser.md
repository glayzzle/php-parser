<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

# parser

The PHP Parser class

**Parameters**

-   `lexer`  
-   `ast`  

**Properties**

-   `EOF` **Integer** 
-   `lexer` **Lexer** 
-   `token` **(Integer | [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String))** 
-   `extractDoc` **[Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** 
-   `debug` **[Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** 

## getTokenName

helper : gets a token name

**Parameters**

-   `token`  

## parse

main entry point : converts a source code to AST

**Parameters**

-   `code`  

## raiseError

Raise an error

**Parameters**

-   `message`  
-   `msgExpect`  
-   `expect`  
-   `token`  

## error

handling errors

**Parameters**

-   `expect`  

## node

Creates a new AST node

**Parameters**

-   `name`  

## expectEndOfStatement

expects an end of statement or end of file

## expect

Force the parser to check the current token.

If the current token does not match to expected token,
the an error will be raised.

If the suppressError mode is activated, then the error will
be added to the program error stack and this function will return `false`.

**Parameters**

-   `token` **([String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) \| [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number))** 


-   Throws **any** Error

Returns **(Parser | False)** 

## text

Returns the current token contents

Returns **[String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** 

## next

consume the next token \*

## ignoreComments

consume comments (if found) \*

## nextWithComments

consume the next token (including doc) \*

## is

Check if token is of specified type

**Parameters**

-   `type`  

## read_token

convert an token to ast \*

## read_list

Helper : reads a list of tokens / sample : T_STRING ',' T_STRING ...

```ebnf
list ::= separator? ( item separator )* item
```

**Parameters**

-   `item`  
-   `separator`  
-   `preserveFirstSeparator`  

## read_name_list

Reads a list of names separated by a comma

```ebnf
name_list ::= namespace (',' namespace)*
```

Sample code :

```php
<?php class foo extends bar, baz { }
```

Returns **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;Identifier>** 

# ignoreStack

outputs some debug information on current token \*

# read_array

Parse an array

```ebnf
array ::= T_ARRAY '(' array_pair_list ')' |
  '[' array_pair_list ']'
```

# read_array_pair_list

Reads an array entry item

```ebnf
array_pair_list ::= '&' w_variable |
 (
   expr (
     T_DOUBLE_ARROW (
       expr | '&' w_variable
     )
   )?
 )
```

# read_dim_offset

```ebnf
 dim_offset ::= expr?
```

# read_class

reading a class

```ebnf
class ::= class_scope? T_CLASS T_STRING (T_EXTENDS NAMESPACE_NAME)? (T_IMPLEMENTS (NAMESPACE_NAME ',')* NAMESPACE_NAME)? '{' CLASS_BODY '}'
```

# read_class_scope

Read the class visibility

```ebnf
  class_scope ::= (T_FINAL | T_ABSTRACT)?
```

# read_class_body

Reads a class body

```ebnf
  class_body ::= (member_flags? (T_VAR | T_STRING | T_FUNCTION))*
```

# read_variable_list

Reads variable list

```ebnf
 variable_list ::= (variable_declaration ',')* variable_declaration
```

# read_constant_list

Reads constant list

```ebnf
 constant_list ::= T_CONST (constant_declaration ',')* constant_declaration
```

# read_member_flags

Read member flags

Returns **any** array
 1st index : 0 => public, 1 => protected, 2 => private
 2nd index : 0 => instance member, 1 => static member
 3rd index : 0 => normal, 1 => abstract member, 2 => final member

# read_interface

reading an interface

```ebnf
interface ::= T_INTERFACE T_STRING (T_EXTENDS (NAMESPACE_NAME ',')* NAMESPACE_NAME)? '{' INTERFACE_BODY '}'
```

# read_interface_body

Reads an interface body

```ebnf
  interface_body ::= (member_flags? (T_CONST | T_FUNCTION))*
```

# read_trait

reading a trait

```ebnf
trait ::= T_TRAIT T_STRING (T_EXTENDS (NAMESPACE_NAME ',')* NAMESPACE_NAME)? '{' FUNCTION* '}'
```

# read_trait_use_statement

reading a use statement

```ebnf
trait_use_statement ::= namespace_name (',' namespace_name)* ('{' trait_use_alias '}')?
```

# read_trait_use_alias

Reading trait alias

```ebnf
trait_use_alias ::= namespace_name ( T_DOUBLE_COLON T_STRING )? (T_INSTEADOF namespace_name) | (T_AS member_flags? T_STRING)
```

# read_variable_declaration

Reads a variable declaration

```ebnf
 variable_declaration ::= T_VARIABLE '=' scalar
```

# read_constant_declaration

Reads a constant declaration

```ebnf
 constant_declaration ::= T_STRING '=' expr
```

Returns **Constant** [:link:](AST.md#constant)

# read_comment

Comments with // or # or / _ ... _ /

# read_doc_comment

Comments with / \*_ ... _ /

# read_expr_item

```ebnf
Reads an expression
 expr ::= @todo
```

# read_new_expr

```ebnf
   new_expr ::= T_NEW (namespace_name function_argument_list) | (T_CLASS ... class declaration)
```

<https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L850>

# read_class_name_reference

Reads a class name

```ebnf
class_name_reference ::= namespace_name | variable
```

# read_assignment_list

```ebnf
  assignment_list ::= assignment_list_element (',' assignment_list_element?)*
```

# read_assignment_list_element

```ebnf
 assignment_list_element ::= expr | expr T_DOUBLE_ARROW expr
```

# is_reference

checks if current token is a reference keyword

# is_variadic

checks if current token is a variadic keyword

# read_function

reading a function

```ebnf
function ::= function_declaration code_block
```

# read_function_declaration

reads a function declaration (without his body)

```ebnf
function_declaration ::= T_FUNCTION '&'?  T_STRING '(' parameter_list ')'
```

# read_lexical_var

```ebnf
lexical_var ::= '&'? T_VARIABLE
```

# read_parameter_list

reads a list of parameters

```ebnf
 parameter_list ::= (parameter ',')* parameter?
```

# read_parameter

```ebnf
 parameter ::= type? '&'? T_ELLIPSIS? T_VARIABLE ('=' expr)?
```

# read_function_argument_list

```ebnf
 function_argument_list ::= '(' (argument_list (',' argument_list)*)? ')'
```

# read_argument_list

```ebnf
   argument_list ::= T_ELLIPSIS? expr
```

# read_type

read type hinting

```ebnf
 type ::= T_ARRAY | T_CALLABLE | namespace_name
```

# read_if

```ebnf
 if ::= '(' expr ')' ':' ...
```

# read_if_expr

reads an if expression : '(' expr ')'

# read_elseif_short

reads an elseif (expr): statements

# read_else_short

# read_short_form

Reads a short form of tokens

# read_while

Reads a while statement

# read_foreach

```ebnf
foreach ::= '(' expr T_AS foreach_variable (T_DOUBLE_ARROW foreach_variable)? ')' statement
```

# read_foreach_variable

```ebnf
foreach_variable = ('&'? variable) | (T_LIST '(' assignment_list ')')
```

# read_start

```ebnf
start ::= (namespace | top_statement)*
```

# read_namespace

```ebnf
namespace ::= T_NAMESPACE namespace_name? '{'
   top_statements
'}'
| T_NAMESPACE namespace_name ';' top_statements
```

# read_namespace_name

reading a namespace name

```ebnf
 namespace_name ::= T_NS_SEPARATOR? (T_STRING T_NS_SEPARATOR)* T_STRING
```

# read_use_statements

```ebnf
use_statements ::=
     use_statements ',' use_statement
     | use_statement
```

# read_inline_use_declaration

```ebnf
 inline_use_declaration ::= ...
```

# read_use_statement_mixed

```ebnf
  use_statement_mixed ::=
      use_statement  (T_AS T_STRING | '{' read_inline_use_declaration '}' )
      (',' read_use_statement)*
```

# read_use_statement

```ebnf
use_statement ::= (
 (T_FUNCTION | T_CONST)? namespace_name
 )
```

# resolve_special_chars

Unescape special chars

# read_scalar

```ebnf
 scalar ::= T_MAGIC_CONST
      | T_LNUMBER | T_DNUMBER
      | T_START_HEREDOC T_ENCAPSED_AND_WHITESPACE? T_END_HEREDOC
      | '"' encaps_list '"'
      | T_START_HEREDOC encaps_list T_END_HEREDOC
      | namespace_name (T_DOUBLE_COLON T_STRING)?
```

# read_dereferencable

Handles the dereferencing

# read_encapsed_string_item

```ebnf
encapsed_string_item ::= T_ENCAPSED_AND_WHITESPACE
 | T_DOLLAR_OPEN_CURLY_BRACES expr '}'
 | T_DOLLAR_OPEN_CURLY_BRACES T_STRING_VARNAME '}'
 | T_DOLLAR_OPEN_CURLY_BRACES T_STRING_VARNAME '[' expr ']' '}'
 | variable
 | T_CURLY_OPEN variable '}'
```

# read_encapsed_string

Reads an encapsed string

# get_magic_constant

Constant token

# read_top_statements

reading a list of top statements (helper for top_statement\*)

```ebnf
 top_statements ::= top_statement*
```

# read_top_statement

reading a top statement

```ebnf
 top_statement ::=
      namespace | function | class
      | interface | trait
      | use_statements | const_list
      | statement
```

# read_inner_statements

reads a list of simple inner statements (helper for inner_statement\*)

```ebnf
 inner_statements ::= inner_statement*
```

# read_const_list

Reads a list of constants declaration

```ebnf
  const_list ::= T_CONST T_STRING '=' expr (',' T_STRING '=' expr)* ';'
```

# read_declare_list

Reads a list of constants declaration

```ebnf
  const_list ::= T_CONST T_STRING '=' expr (',' T_STRING '=' expr)*
```

# read_inner_statement

reads a simple inner statement

```ebnf
 inner_statement ::= '{' inner_statements '}' | token
```

# read_statement

Reads statements

# read_code_block

```ebnf
 code_block ::= '{' (inner_statements | top_statements) '}'
```

# read_switch

Reads a switch statement

```ebnf
 switch ::= T_SWITCH '(' expr ')' switch_case_list
```

# read_switch_case_list

```ebnf
 switch_case_list ::= '{' ';'? case_list* '}' | ':' ';'? case_list* T_ENDSWITCH ';'
```

# read_case_list

```ebnf
  case_list ::= ((T_CASE expr) | T_DEFAULT) (':' | ';') inner_statement*
```

# read_try

```ebnf
 try ::= T_TRY '{' inner_statement* '}'
         (
             T_CATCH '(' namespace_name variable ')' '{'  inner_statement* '}'
         )*
         (T_FINALLY '{' inner_statement* '}')?
```

# read_variable

Reads a variable

```ebnf
  variable ::= ...complex @todo
```

Some samples of parsed code :

```php
 $var                      // simple var
 classname::CONST_NAME     // dynamic class name with const retrieval
 foo()                     // function call
 $var->func()->property    // chained calls
```

# read_encaps_var_offset

<https://github.com/php/php-src/blob/493524454d66adde84e00d249d607ecd540de99f/Zend/zend_language_parser.y#L1231>

# read_reference_variable

```ebnf
 reference_variable ::=  simple_variable ('[' OFFSET ']')* | '{' EXPR '}'
```

<code>
 $foo[123];      // foo is an array ==> gets its entry
 $foo{1};        // foo is a string ==> get the 2nd char offset
 ${'foo'}[123];  // get the dynamic var $foo
 $foo[123]{1};   // gets the 2nd char from the 123 array entry
</code>

# read_simple_variable

```ebnf
 simple_variable ::= T_VARIABLE | '$' '{' expr '}' | '$' simple_variable
```
