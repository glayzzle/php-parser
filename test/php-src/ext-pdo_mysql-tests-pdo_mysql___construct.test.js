// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_mysql/tests/pdo_mysql___construct.phpt
  it("MySQL PDO->__construct() - Generic + DSN", function () {
    expect(parser.parseCode("<?php\n    require_once(__DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');\n    function tryandcatch($offset, $code) {\n        try {\n            eval($code);\n            assert(sprintf(\"[%03d] Should have failed\\n\", $offset) != '');\n        } catch (PDOException $e) {\n            return sprintf(\"[%03d] %s, [%s] %s\\n\",\n                $offset,\n                $e->getMessage(),\n                (isset($db) && is_object($db)) ? $db->errorCode() : 'n/a',\n                (isset($db) && is_object($db)) ? implode(' ', $db->errorInfo()) : 'n/a');\n        }\n        return '';\n    }\n    try {\n        try {\n            if (NULL !== ($db = @new PDO()))\n                printf(\"[001] Too few parameters\\n\");\n        } catch (TypeError $ex) {\n        }\n        print tryandcatch(2, '$db = new PDO(chr(0));');\n        print tryandcatch(3, '$db = new PDO(\"a\" . chr(0) . \"b\");');\n        print tryandcatch(4, '$db = new PDO(\"MYSQL\");');\n        print tryandcatch(5, '$db = new PDO(\"mysql\");');\n        print tryandcatch(6, '$db = new PDO(\"mysql \");');\n        print tryandcatch(7, '$db = new PDO(\"fantasyandfriends :\");');\n        $dsn = PDO_MYSQL_TEST_DSN;\n        // MySQL Server might accept anonymous connections, don't\n        // print anything\n        tryandcatch(8, '$db = new PDO(\"' . $dsn . '\");');\n        $user = 'dontcreatesuchauser';\n        $pass = 'withthispassword';\n        print tryandcatch(9, '$db = new PDO(\"' . $dsn . '\", \"' . $user . '\", \"' . $pass . '\");');\n        // should fail\n        $dsn = 'mysql:';\n        // don't print the message since it can be different\n        tryandcatch(10, '$db = new PDO(\"' . $dsn . '\", \"' . $user . '\", \"' . $pass . '\");');\n        $dsn = PDO_MYSQL_TEST_DSN;\n        $user = PDO_MYSQL_TEST_USER;\n        $pass\t= PDO_MYSQL_TEST_PASS;\n        // should work...\n        $db = new PDO($dsn, $user, $pass);\n        // Reaction on host not specified differs for different configs, so no printing\n        $dsn = 'mysql:invalid=foo';\n        tryandcatch(11, '$db = new PDO(\"' . $dsn . '\", \"' . $user . '\", \"' . $pass . '\");');\n        $dsn = 'mysql:' . str_repeat('howmuch=canpdoeat;', 1000);\n        tryandcatch(12, '$db = new PDO(\"' . $dsn . '\", \"' . $user . '\", \"' . $pass . '\");');\n        $dsn = 'mysql:' . str_repeat('abcdefghij', 1024 * 10) . '=somevalue';\n        tryandcatch(13, '$db = new PDO(\"' . $dsn . '\", \"' . $user . '\", \"' . $pass . '\");');\n        if (PDO_MYSQL_TEST_HOST) {\n            $host = PDO_MYSQL_TEST_HOST;\n            $invalid_host = $host . 'invalid';\n            // last host specification should be the one used\n            $dsn = MySQLPDOTest::getDSN(array('host' => $host), 'host=' . $invalid_host);\n            try { $db = @new PDO($dsn, $user, $pass); assert(false); printf(\"%s\\n\", $dsn); } catch (PDOException $e) {\n                $tmp = $e->getMessage();\n                if (!stristr($tmp, 'HY000') && !stristr($tmp, '2005') && !stristr($tmp, '2002'))\n                    printf(\"[014] Cannot find proper error codes: %s\\n\", $tmp);\n            }\n            $dsn = MySQLPDOTest::getDSN(array('host' => $invalid_host), 'host=' . $host);\n            try { $db = @new PDO($dsn, $user, $pass); } catch (PDOException $e) {\n                printf(\"[015] DSN=%s, %s\\n\", $dsn, $e->getMessage());\n            }\n            $invalid_host = '-' . chr(0);\n            $dsn = MySQLPDOTest::getDSN(array('host' => $invalid_host));\n            try { $db = @new PDO($dsn, $user, $pass); assert(false); printf(\"%s\\n\", $dsn); } catch (PDOException $e) {\n                $tmp = $e->getMessage();\n                if (!stristr($tmp, 'HY000') && !stristr($tmp, '2005') && !stristr($tmp, '2002'))\n                    printf(\"[016] Cannot find proper error codes: %s\\n\", $tmp);\n            }\n            // parsing should not get confused by chr(0)\n            $dsn = MySQLPDOTest::getDSN(array('host' => $invalid_host), 'host=' . $host);\n            try { $db = @new PDO($dsn, $user, $pass); } catch (PDOException $e) {\n                printf(\"[017] DSN=%s, %s\\n\", $dsn, $e->getMessage());\n            }\n        }\n        // what about long values for a valid option ...\n        // hostnames > 1024 chars break on some NIS-enabled FreeBSD...\n        $dsn = MySQLPDOTest::getDSN(array('host' => str_repeat('0123456789', 100)));\n        try { $db = @new PDO($dsn, $user, $pass); assert(false); printf(\"%s\\n\", $dsn); } catch (PDOException $e) {\n            $tmp = $e->getMessage();\n            if (!stristr($tmp, 'HY000') && !stristr($tmp, '2005') && !stristr($tmp, '2002'))\n                printf(\"[018] Cannot find proper error codes: %s\\n\", $tmp);\n        }\n        if (PDO_MYSQL_TEST_PORT && (PDO_MYSQL_TEST_SOCKET == '')) {\n            // Playing with the port makes only sense if no socket gets used\n            $port = PDO_MYSQL_TEST_PORT;\n            // let's hope we don't hit a MySQL running on that port...\n            $invalid_port = $port * 2;\n            $dsn = MySQLPDOTest::getDSN(array('port' => $port), 'port=' . $invalid_port);\n            try { $db = @new PDO($dsn, $user, $pass); assert(false); printf(\"%s\\n\", $dsn); } catch (PDOException $e) {\n                $tmp = $e->getMessage();\n                if (!stristr($tmp, 'HY000') && !stristr($tmp, '2005'))\n                    printf(\"[019] Cannot find proper error codes: %s\\n\", $tmp);\n            }\n            $dsn = MySQLPDOTest::getDSN(array('port' => $invalid_port), 'port=' . $port);\n            try { $db = @new PDO($dsn, $user, $pass); } catch (PDOException $e) {\n                printf(\"[020] DSN=%s, %s\\n\", $dsn, $e->getMessage());\n            }\n            $invalid_port = 'abc';\n            $dsn = MySQLPDOTest::getDSN(array('port' => $port), 'port=' . $invalid_port);\n            try {\n                $db = @new PDO($dsn, $user, $pass);\n                // atoi('abc') = 0, 0 -> fallback to default 3306 -> may or may not fail!\n            } catch (PDOException $e) {\n            }\n        }\n        if (PDO_MYSQL_TEST_DB) {\n            $db = PDO_MYSQL_TEST_DB;\n            $invalid_db = 'letshopeitdoesnotexist';\n            $dsn = MySQLPDOTest::getDSN(array('dbname' => $db), 'dbname=' . $invalid_db);\n            try { $db = @new PDO($dsn, $user, $pass); assert(false); printf(\"%s\\n\", $dsn); } catch (PDOException $e) {\n                $tmp = $e->getMessage();\n                // 1044 may occur here if running tests using a custom user that does not have access to all databases\n                if (!stristr($tmp, '42000') && !stristr($tmp, '1049') && !stristr($tmp, '1044'))\n                    printf(\"[022] Cannot find proper error codes: %s\\n\", $tmp);\n            }\n            $dsn = MySQLPDOTest::getDSN(array('dbname' => $invalid_db), 'dbname=' . $db);\n            try { $db = @new PDO($dsn, $user, $pass); } catch (PDOException $e) {\n                printf(\"[023] DSN=%s, %s\\n\", $dsn, $e->getMessage());\n            }\n        }\n        if (PDO_MYSQL_TEST_SOCKET && (stristr(PDO_MYSQL_TEST_DSN, PDO_MYSQL_TEST_SOCKET) !== false)) {\n            $socket = PDO_MYSQL_TEST_SOCKET;\n            $invalid_socket = '/lets/hope/it/does/not/exist';\n            $dsn = MySQLPDOTest::getDSN(array('unix_socket' => $socket), 'unix_socket=' . $invalid_socket);\n            try { $db = @new PDO($dsn, $user, $pass); assert(false); printf(\"%s\\n\", $dsn); } catch (PDOException $e) {\n                $tmp = $e->getMessage();\n                if (!stristr($tmp, 'HY000') && !stristr($tmp, '2002'))\n                    printf(\"[024] Cannot find proper error codes: %s\\n\", $tmp);\n            }\n            $dsn = MySQLPDOTest::getDSN(array('unix_socket' => $invalid_socket), 'unix_socket=' . $socket);\n            try { $db = @new PDO($dsn, $user, $pass); } catch (PDOException $e) {\n                printf(\"[025] DSN=%s, %s\\n\", $dsn, $e->getMessage());\n            }\n        }\n        $have_charset_support = false;\n        $dsn = MySQLPDOTest::getDSN();\n        try {\n            $db = new PDO($dsn, $user, $pass);\n            $stmt = $db->query('SELECT VERSION() as _version');\n            $version = $stmt->fetch(PDO::FETCH_ASSOC);\n            $tmp = explode('.', $version['_version']);\n            if ((count($tmp) == 3) &&\n                    (($tmp[0] >= 4 && $tmp[1] >= 1) || ($tmp[0] >= 5))) {\n                // MySQL Server 4.1 - charset support available\n                $have_charset_support = true;\n            }\n        } catch (PDOException $e) {\n            printf(\"[026] DSN=%s, %s\\n\", $dsn, $e->getMessage());\n        }\n        if (PDO_MYSQL_TEST_CHARSET) {\n            $charset = PDO_MYSQL_TEST_CHARSET;\n            $invalid_charset = 'invalid';\n            if ($have_charset_support) {\n                $dsn = MySQLPDOTest::getDSN();\n                $db = new PDO($dsn, $user, $pass);\n                $stmt = $db->query(sprintf('SHOW CHARACTER SET LIKE \"%s\"', $charset));\n                $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n                $have_charset = (empty($tmp)) ? false : true;\n                if ($have_charset) {\n                    $dsn = MySQLPDOTest::getDSN(array('charset' => $charset), 'charset=' . $invalid_charset);\n                    try {\n                        $db = @new PDO($dsn, $user, $pass);\n                        /* NOTE: MySQL does a fallback to the charset suggested during the handshake - no error - no bug! */\n                    } catch (PDOException $e) {\n                        $tmp = $e->getMessage();\n                        /* TODO: add proper codes */\n                        if (!stristr($tmp, 'sqlstatecode') || !stristr($tmp, 'mysqlinternalerrcode'))\n                            printf(\"[027] TODO - Cannot find proper error codes: %s\\n\", $tmp);\n                    }\n                    $dsn = MySQLPDOTest::getDSN(array('charset' => $invalid_charset), 'charset=' . $charset);\n                    try {\n                        $db = @new PDO($dsn, $user, $pass);\n                        /* Strictly speaking we should test more: character_set_client, character_set_results, and character_set_connection */\n                        $stmt = $db->query('SELECT @@character_set_connection AS _charset');\n                        $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n                        if ($tmp['_charset'] != $charset)\n                            printf(\"[028] Character sets has not been set, @@character_set_connection reports '%s', expecting '%s'\",\n                                $tmp['_charset'], $charset);\n                    } catch (PDOException $e) {\n                        printf(\"[029] DSN=%s, %s\\n\", $dsn, $e->getMessage());\n                    }\n                } else {\n                    printf(\"[030] You're trying to run the tests with charset '%s' which seems not supported by the server!\", $charset);\n                }\n            }\n        }\n        if ($have_charset_support) {\n            // In case the PDO_MYSQL_TEST_CHARSET interferes with any defaults\n            // we do another test to verify that the charset has been set.\n            $dsn = MySQLPDOTest::getDSN();\n            $db = new PDO($dsn, $user, $pass);\n            $stmt = $db->query('SHOW CHARACTER SET LIKE \"latin1\"');\n            $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n            $have_latin1 =(empty($tmp)) ? false : true;\n            $stmt = $db->query('SHOW CHARACTER SET LIKE \"latin2\"');\n            $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n            $have_latin2 =(empty($tmp)) ? false : true;\n            if ($have_latin1 && $have_latin2) {\n                // very likely we do have both of them...\n                try {\n                    $dsn = MySQLPDOTest::getDSN(array('charset' => 'latin1'));\n                    $db = new PDO($dsn, $user, $pass);\n                    $stmt = $db->query('SELECT @@character_set_connection AS _charset');\n                    $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n                    if ($tmp['_charset'] != 'latin1')\n                        printf(\"[031] DSN = %s, Character sets has not been set, @@character_set_connection reports '%s', expecting '%s'\",\n                            $dsn, $tmp['_charset'], 'latin1');\n                } catch (PDOException $e) {\n                    printf(\"[032] %s\\n\", $e->getMessage());\n                }\n                try {\n                    $dsn = MySQLPDOTest::getDSN(array('charset' => 'latin2'));\n                    $db = new PDO($dsn, $user, $pass);\n                    $stmt = $db->query('SELECT @@character_set_connection AS _charset');\n                    $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n                    if ($tmp['_charset'] != 'latin2')\n                        printf(\"[033] DSN = %s, character sets has not been set, @@character_set_connection reports '%s', expecting '%s'\",\n                            $dsn, $tmp['_charset'], 'latin2');\n                } catch (PDOException $e) {\n                    printf(\"[034] %s\\n\", $e->getMessage());\n                }\n            }\n        }\n    } catch (PDOException $e) {\n        printf(\"[001] %s, [%s] %s\\n\",\n            $e->getMessage(),\n            (is_object($db)) ? $db->errorCode() : 'n/a',\n            (is_object($db)) ? implode(' ', $db->errorInfo()) : 'n/a');\n    }\n    print \"done!\";\n?>")).toMatchSnapshot();
  });
});
