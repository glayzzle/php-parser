// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_mysql/tests/pdo_mysql_stmt_unbuffered_2050.phpt
  it("MySQL PDO:query() vs. PDO::prepare() and MySQL error 2050", function () {
    expect(parser.parseCode("<?php\n    require_once(__DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');\n    $db = MySQLPDOTest::factory();\n    try {\n        printf(\"Native PS...\\n\");\n        $db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);\n        if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))\n            printf(\"[004] Unable to turn off emulated prepared statements\\n\");\n        printf(\"Buffered...\\n\");\n        MySQLPDOTest::createTestTable($db);\n        $db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);\n        $stmt = $db->query('SELECT id, label FROM test WHERE id = 1');\n        var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));\n        $stmt = $db->query('SELECT id, label FROM test WHERE id = 1');\n        var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));\n        printf(\"Unbuffered...\\n\");\n        MySQLPDOTest::createTestTable($db);\n        $db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);\n        $stmt = $db->query('SELECT id, label FROM test WHERE id = 1');\n        var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));\n        /*\n        NOTE - this will cause an error and it OK\n        When using unbuffered prepared statements MySQL expects you to\n        fetch all data from the row before sending new data to the server.\n        PDO::query() will prepare and execute a statement in one step.\n        After the execution of PDO::query(), MySQL expects you to fetch\n        the results from the line before sending new commands. However,\n        PHP/PDO will send a CLOSE message as part of the PDO::query() call.\n        The following happens:\n            $stmt = PDO::query(<some query>)\n                mysql_stmt_prepare()\n                mysql_stmt_execute()\n            $stmt->fetchAll()\n                mysql_stmt_fetch()\n            And now the right side of the expression will be executed first:\n                $stmt = PDO::query(<some query>)\n                    PDO::query(<some query>)\n                        mysql_stmt_prepare\n                        mysql_stmt_execute\n            PHP continues at the left side of the expression:\n                $stmt = PDO::query(<some query>)\n                    What happens is that $stmt gets overwritten. The reference counter of the\n                    zval representing the current value of $stmt. PDO gets a callback that\n                    it has to free the resources associated with the zval representing the\n                    current value of stmt:\n                        mysql_stmt_close\n                            ---> ERROR\n                            ---> execute() has been send on the line, you are supposed to fetch\n                            ---> you must not try to send a CLOSE after execute()\n                            ---> Error: 2050 (CR_FETCH_CANCELED)\n                            ---> Message: Row retrieval was canceled by mysql_stmt_close() call\n                            ---> MySQL does its best to recover the line and cancels the retrieval\n                    PHP proceeds and assigns the new statement object/zval obtained from\n                    PDO to $stmt.\n        Solutions:\n                - use mysqlnd\n                - use prepare() + execute() instead of query()\n                - as there is no explicit close() in PDO, try unset($stmt) before the new assignment\n                - fix PDO::query() [not the driver, fix PDO itself]\n        */\n        $stmt = $db->query('SELECT id, label FROM test WHERE id = 1');\n        var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));\n        $stmt = $db->prepare('SELECT id, label FROM test WHERE id = 1');\n        $stmt->execute();\n        var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));\n        $stmt = $db->prepare('SELECT id, label FROM test WHERE id = 1');\n        $stmt->execute();\n        var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));\n        unset($stmt);\n        $stmt = $db->query('SELECT id, label FROM test WHERE id = 1');\n        var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));\n        unset($stmt);\n        $stmt = $db->query('SELECT id, label FROM test WHERE id = 1');\n        var_dump($stmt->fetchAll(PDO::FETCH_ASSOC));\n    } catch (PDOException $e) {\n        printf(\"[001] %s [%s] %s\\n\",\n            $e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));\n    }\n    print \"done!\";\n?>")).toMatchSnapshot();
  });
});
