// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/cp51932_encoding.phpt
  it("Exhaustive test of CP51932 encoding verification and conversion", function () {
    expect(parser.parseCode("<?php\nsrand(2020); /* Make results consistent */\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\n/* Read in the table of all characters in CP51932 */\n$validChars = array(); /* CP51932 string -> UTF-16BE string */\n$fromUnicode = array();\n$fp = fopen(realpath(__DIR__ . '/data/CP51932.txt'), 'r+');\nwhile ($line = fgets($fp, 256)) {\n  if ($line[0] == '#')\n    continue;\n  $byte2 = null;\n  if (sscanf($line, '<U%x> \\x%x\\x%x', $codepoint, $byte1, $byte2) >= 2) {\n    /* The table we are using tries to map as many Unicode codepoints into\n     * CP51932 as possible, including by mapping latin characters with accents\n     * to the equivalent without accents; but since CP51932 is based on the\n     * CP932 character set, we don't need to handle codepoints which are not\n     * mapped from any character in CP932 */\n    if (($codepoint >= 0xC0 && $codepoint <= 0xD6) ||\n        ($codepoint >= 0xD8 && $codepoint <= 0xF6) ||\n        ($codepoint >= 0xF8 && $codepoint <= 0xFF))\n      continue;\n    $cp51932 = ($byte2 ? (chr($byte1) . chr($byte2)) : chr($byte1));\n    $utf16 = pack('n', $codepoint);\n    $validChars[$cp51932] = $utf16;\n    $fromUnicode[$utf16] = $cp51932;\n  }\n}\n/* We map the JIS X 0208 FULLWIDTH TILDE to U+FF5E (FULLWIDTH TILDE)\n * But when converting Unicode to CP51932, we also accept U+301C (WAVE DASH) */\n$fromUnicode[\"\\x30\\x1C\"] = \"\\xA1\\xC1\";\n/* We map the JIS X 0208 MINUS SIGN to U+FF0D (FULLWIDTH HYPHEN-MINUS SIGN),\n * but when converting Unicode to CP51932, we also accept U+2212 (MINUS SIGN) */\n$fromUnicode[\"\\x22\\x12\"] = \"\\xA1\\xDD\";\n/* We map the JIS X 0208 PARALLEL TO symbol to U+2225 (PARALLEL TO),\n * but when converting Unicode to CP51932, we also accept U+2016\n * (DOUBLE VERTICAL LINE) */\n$fromUnicode[\"\\x20\\x16\"] = \"\\xA1\\xC2\";\n/* There are a number of duplicate, irreversible mappings in the CP51932 table\n * In most cases, the one which we primarily use appears last in the table,\n * but in some cases, it is first and will be overwritten in the above loop\n *\n * Interestingly, the \"collisions\" happen in both directions! Part of this is\n * because the table we are using attempts to map as many Unicode codepoints\n * as possible to CP932 characters */\n$fromUnicode[\"\\x22\\x20\"] = \"\\xA2\\xDC\";\n$fromUnicode[\"\\x22\\x29\"] = \"\\xA2\\xC1\";\n$fromUnicode[\"\\x22\\x2B\"] = \"\\xA2\\xE9\";\n$fromUnicode[\"\\x22\\x35\"] = \"\\xA2\\xE8\";\n$fromUnicode[\"\\x22\\x1A\"] = \"\\xA2\\xE5\";\n$fromUnicode[\"\\x22\\x2A\"] = \"\\xA2\\xC0\";\n$fromUnicode[\"\\x22\\x61\"] = \"\\xA2\\xE1\";\n$fromUnicode[\"\\x22\\xA5\"] = \"\\xA2\\xDD\";\n$fromUnicode[\"\\x22\\x52\"] = \"\\xA2\\xE2\";\n$fromUnicode[\"\\xFF\\xE2\"] = \"\\xA2\\xCC\";\nunset($fromUnicode[\"\\x00\\xA1\"]); // Don't map upside-down ! to ordinary !\nunset($fromUnicode[\"\\x00\\xA6\"]); // Don't map broken bar to ordinary pipe character\nunset($fromUnicode[\"\\x00\\xA9\"]); // Don't map © to c\nunset($fromUnicode[\"\\x00\\xAA\"]); // Don't map feminine ordinal indicator\nunset($fromUnicode[\"\\x00\\xAB\"]); // Don't map left double angled quote mark to \"much less than\"\nunset($fromUnicode[\"\\x00\\xAD\"]); // Don't map soft hyphen to ordinary hyphen\nunset($fromUnicode[\"\\x00\\xAE\"]); // Don't map ® to R\nunset($fromUnicode[\"\\x00\\xAF\"]); // Don't map Unicode halfwidth macron to CP932 fullwidth macron\nunset($fromUnicode[\"\\x00\\xB2\"]); // Don't map ² to ordinary 2\nunset($fromUnicode[\"\\x00\\xB3\"]); // Don't map ³ to ordinary 3\nunset($fromUnicode[\"\\x00\\xB5\"]); // Don't map micro sign to Greek mu\nunset($fromUnicode[\"\\x00\\xB7\"]); // Don't map middle dot to katakana middle dot\nunset($fromUnicode[\"\\x00\\xB8\"]); // Don't map cedilla to fullwidth comma\nunset($fromUnicode[\"\\x00\\xB9\"]); // Don't map ¹ to ordinary 1\nunset($fromUnicode[\"\\x00\\xBA\"]); // Don't map \"masculine ordinal indicator\"\nunset($fromUnicode[\"\\x00\\xBB\"]); // Don't map right double angled quote mark to \"much greater than\"\nunset($fromUnicode[\"\\x30\\x94\"]); // Don't map hiragana vu to katakana vu\nfor ($i = 0; $i <= 0x7F; $i++)\n  $validChars[chr($i)] = \"\\x00\" . chr($i);\n/* U+00A5 is YEN SIGN; convert to FULLWIDTH YEN SIGN */\n$fromUnicode[\"\\x00\\xA5\"] = \"\\xA1\\xEF\";\n/* U+203E is OVERLINE; convert to FULLWIDTH MACRON */\n$fromUnicode[\"\\x20\\x3E\"] = \"\\xA1\\xB1\";\n/* U+00AF is MACRON; convert to FULLWIDTH MACRON */\n$fromUnicode[\"\\x00\\xAF\"] = \"\\xA1\\xB1\";\ntestAllValidChars($validChars, 'CP51932', 'UTF-16BE', false);\ntestAllValidChars($fromUnicode, 'UTF-16BE', 'CP51932', false);\necho \"CP51932 verification and conversion works on all valid characters\\n\";\nfindInvalidChars($validChars, $invalidChars, $truncated, array_fill_keys(range(0xA9, 0xAF), 2) + array_fill_keys(range(0xF5, 0xF8), 2) + array(0xFD => 2, 0xFE => 2));\ntestAllInvalidChars($invalidChars, $validChars, 'CP51932', 'UTF-16BE', \"\\x00%\");\ntestTruncatedChars($truncated, 'CP51932', 'UTF-16BE', \"\\x00%\");\necho \"CP51932 verification and conversion works on all invalid characters\\n\";\nfindInvalidChars($fromUnicode, $invalidCodepoints, $unused, array_fill_keys(range(0, 0xFF), 2));\nconvertAllInvalidChars($invalidCodepoints, $fromUnicode, 'UTF-16BE', 'CP51932', '%');\necho \"Unicode -> CP51932 conversion works on all invalid codepoints\\n\";\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\x80\", \"%\", \"CP51932\", \"UTF-8\");\nconvertInvalidString(\"\\xFE\\xFF\", \"%\", \"CP51932\", \"UTF-8\");\necho \"Done!\\n\";\n?>")).toMatchSnapshot();
  });
});
