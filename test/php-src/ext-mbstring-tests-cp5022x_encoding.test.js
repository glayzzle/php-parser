// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/cp5022x_encoding.phpt
  it("Exhaustive test of CP50220, CP50221, and CP50222 encodings", function () {
    expect(parser.parseCode("<?php\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\nfunction shiftJISDecode($bytes) {\n  /* Convert CP932's default Shift-JIS representation to kuten code\n   *\n   * Shift-JIS is fun! The first byte only represents the top 7 bits of\n   * the ku number, because 94 first bytes were not available. There are\n   * two different ranges of 94 which the second byte can fall in, and\n   * we get the low bit of the ku number by seeing which one it is. */\n  $first = ($bytes >> 8) & 0xFF;\n  $second = $bytes & 0xFF;\n  $hi_bits = $first - (($first > 0x9F) ? 0xE0 - 31 : 0x81);\n  if ($second > 0x9E) {\n    $kuten = ((($hi_bits << 1) + 0x22) << 8) + ($second - 0x9F + 0x21);\n  } else if ($second > 0x7F) {\n    $kuten = ((($hi_bits << 1) + 0x21) << 8) + ($second - 0x80 + 63 + 0x21);\n  } else {\n    $kuten = ((($hi_bits << 1) + 0x21) << 8) + ($second - 0x40 + 0x21);\n  }\n  return $kuten;\n}\n/* Read in table of all characters in CP932 charset */\n$cp932Chars = array(); /* CP932 -> UTF-16BE */\n$nonInvertible = array();\n$fromUnicode = array();\n$fp = fopen(__DIR__ . '/data/CP932.txt', 'r+');\nwhile ($line = fgets($fp, 256)) {\n  if ($line[0] == '#')\n    continue;\n  if (sscanf($line, \"0x%x\\t0x%x\", $bytes, $codepoint) == 2) {\n    if ($bytes < 256)\n      continue;\n    if (isset($fromUnicode[$codepoint])) {\n      $nonInvertible[pack('n', shiftJISDecode($bytes))] = pack('n', $codepoint);\n    } else {\n      $cp932Chars[pack('n', shiftJISDecode($bytes))] = pack('n', $codepoint);\n      $fromUnicode[$codepoint] = $bytes;\n    }\n  }\n}\n/* Aside from the characters in that table, we also support a 'user' area,\n * which maps to Unicode 'private' codepoints 0xE000-E757 */\n$codepoint = 0xE000;\nfor ($i = 0xF0; $i <= 0xF9; $i++) {\n  for ($j = 0x40; $j <= 0xFC; $j++) {\n    if ($j == 0x7F)\n      continue;\n    $cp932Chars[pack('n', shiftJISDecode(($i << 8) + $j))] = pack('n', $codepoint);\n    $codepoint++;\n  }\n}\n/* Read in table of all characters in JISX-0201 charset */\n$jisx0201Chars = array(); /* JISX0201 -> UTF-16BE */\n$fp = fopen(__DIR__ . '/data/JISX0201.txt', 'r+');\nwhile ($line = fgets($fp, 256)) {\n  if ($line[0] == '#')\n    continue;\n  if (sscanf($line, \"0x%x\\t0x%x\", $byte, $codepoint) == 2)\n    $jisx0201Chars[chr($byte)] = pack('n', $codepoint);\n}\n/* Read in table of all characters in JISX-0212 charset */\n$jisx0212Chars = array();\n$fp = fopen(__DIR__ . '/data/JISX0212.txt', 'r+');\nwhile ($line = fgets($fp, 256)) {\n  if ($line[0] == '#')\n    continue;\n  if (sscanf($line, \"0x%x\\t0x%x\", $bytes, $codepoint) == 2) {\n    $jisx0212Chars[pack('n', $bytes)] = pack('n', $codepoint);\n  }\n}\n/* Our conversions between CP5022x (when CP932 charset is selected) and Unicode\n * differ in a number of places from the table provided by the Unicode Consortium */\n$cp932Chars[\"\\x21\\x41\"] = \"\\x30\\x1C\"; /* WAVE DASH instead of FULLWIDTH TILDE */\n$cp932Chars[\"\\x21\\x42\"] = \"\\x20\\x16\"; /* DOUBLE VERTICAL LINE instead of PARALLEL TO */\n$cp932Chars[\"\\x21\\x5D\"] = \"\\x22\\x12\"; /* MINUS SIGN instead of FULLWIDTH HYPHEN-MINUS */\n$cp932Chars[\"\\x21\\x71\"] = \"\\x00\\xA2\"; /* CENT SIGN instead of FULLWIDTH CENT SIGN */\n$cp932Chars[\"\\x21\\x72\"] = \"\\x00\\xA3\"; /* POUND SIGN instead of FULLWIDTH POUND SIGN */\n$cp932Chars[\"\\x22\\x4C\"] = \"\\x00\\xAC\"; /* NOT SIGN instead of FULLWIDTH NOT SIGN */\nfunction testValid($from, $to, $encoding, $bothWays = true) {\n  identifyValidString($from, $encoding);\n  convertValidString($from, $to, $encoding, 'UTF-16BE', false);\n  if ($bothWays) {\n    /* An 0xF at the beginning is redundant; it switches to ASCII mode, but\n     * ASCII mode is default */\n    if ($from[0] == \"\\x0F\")\n      $from = substr($from, 1, strlen($from) - 1);\n    /* ESC ( B at the beginning is redundant, since ASCII mode is the default */\n    if (substr($from, 0, 3) == \"\\x1B(B\")\n      $from = substr($from, 3, strlen($from) - 3);\n    /* If the string switches to a different charset, it should switch back to\n     * ASCII at the end */\n    if (strpos($from, \"\\x1B\\$B\") !== false || strpos($from, \"\\x1B(J\") !== false || strpos($from, \"\\x1B(I\") !== false)\n      $from .= \"\\x1B(B\";\n    if ($encoding == 'CP50222' && $from[0] == \"\\x0E\")\n      $from .= \"\\x0F\";\n    convertValidString($to, $from, 'UTF-16BE', $encoding, false);\n  }\n}\nfunction testInvalid($from, $to, $encoding) {\n  testInvalidString($from, $to, $encoding, 'UTF-16BE');\n}\nfor ($i = 0; $i < 0x80; $i++) {\n  if ($i == 0xE || $i == 0xF || $i == 0x1B)\n    continue;\n  testValid(chr($i),            \"\\x00\" . chr($i), 'CP50220');\n  testValid(chr($i),            \"\\x00\" . chr($i), 'CP50221');\n  testValid(chr($i),            \"\\x00\" . chr($i), 'CP50222');\n  testValid(\"\\x1B(B\" . chr($i), \"\\x00\" . chr($i), 'CP50220');\n  testValid(\"\\x1B(B\" . chr($i), \"\\x00\" . chr($i), 'CP50221');\n  testValid(\"\\x1B(B\" . chr($i), \"\\x00\" . chr($i), 'CP50222');\n  testValid(\"\\x0F\" . chr($i),   \"\\x00\" . chr($i), 'CP50222', false); /* 0xF is 'Shift Out' code */\n}\nfor ($i = 0x80; $i < 256; $i++) {\n  if ($i >= 0xA1 && $i <= 0xDF) // We convert single bytes from 0xA1-0xDF as JIS X 0201 kana\n    continue;\n  testInvalid(chr($i),            \"\\x00%\", 'CP50220');\n  testInvalid(chr($i),            \"\\x00%\", 'CP50221');\n  testInvalid(chr($i),            \"\\x00%\", 'CP50222');\n  testInvalid(\"\\x1B(B\" . chr($i), \"\\x00%\", 'CP50220');\n  testInvalid(\"\\x1B(B\" . chr($i), \"\\x00%\", 'CP50221');\n  testInvalid(\"\\x1B(B\" . chr($i), \"\\x00%\", 'CP50222');\n  testInvalid(\"\\x0F\" . chr($i),   \"\\x00%\", 'CP50220');\n  testInvalid(\"\\x0F\" . chr($i),   \"\\x00%\", 'CP50221');\n  testInvalid(\"\\x0F\" . chr($i),   \"\\x00%\", 'CP50222');\n}\n// Switch back to ASCII after a multibyte character\nconvertValidString(\"\\x30\\x00\\x00a\\x00b\\x00c\", \"\\x1B\\$B\\x21\\x21\\x1B(Babc\", 'UTF-16BE', 'CP50221', false);\nconvertValidString(\"\\x30\\x00\\x00a\\x00b\\x00c\", \"\\x1B\\$B\\x21\\x21\\x1B(Babc\", 'UTF-16BE', 'CP50222', false);\necho \"ASCII support OK\\n\";\n/* All valid JIS X 0201 characters\n * Those with a 1 in the high bit are JIS X 0201 kana */\nforeach ($jisx0201Chars as $jisx0201 => $utf16BE) {\n  if (ord($jisx0201) >= 128) { /* Kana */\n    $kana = chr(ord($jisx0201) - 128);\n    testValid(\"\\x1B(I\" . $kana, $utf16BE, 'CP50221');\n    testValid(\"\\x1B(J\\x0E\" . $kana, $utf16BE, 'CP50222', false); /* 0xE is 'Shift In' code */\n    testValid(\"\\x0E\" . $kana, $utf16BE, 'CP50222', false);\n    testValid($jisx0201, $utf16BE, 'CP50220', false);\n    testValid($jisx0201, $utf16BE, 'CP50221', false);\n    testValid($jisx0201, $utf16BE, 'CP50222', false);\n    convertValidString($utf16BE, \"\\x0E\" . chr(ord($jisx0201) - 0x80) . \"\\x0F\", 'UTF-16BE', 'CP50222', false);\n  } else { /* Latin */\n    testValid(\"\\x1B(J\" . $jisx0201, $utf16BE, 'CP50220', $utf16BE > \"\\x00\\x80\");\n    testValid(\"\\x1B(J\" . $jisx0201, $utf16BE, 'CP50221', $utf16BE > \"\\x00\\x80\");\n    testValid(\"\\x1B(J\" . $jisx0201, $utf16BE, 'CP50222', $utf16BE > \"\\x00\\x80\");\n  }\n}\nfor ($i = 0x80; $i < 256; $i++) {\n  if ($i >= 0xA1 && $i <= 0xDF)\n    continue;\n  testInvalid(\"\\x1B(I\" . chr($i), \"\\x00%\", 'CP50220');\n  testInvalid(\"\\x1B(I\" . chr($i), \"\\x00%\", 'CP50221');\n  testInvalid(\"\\x1B(I\" . chr($i), \"\\x00%\", 'CP50222');\n  testInvalid(\"\\x1B(J\" . chr($i), \"\\x00%\", 'CP50220');\n  testInvalid(\"\\x1B(J\" . chr($i), \"\\x00%\", 'CP50221');\n  testInvalid(\"\\x1B(J\" . chr($i), \"\\x00%\", 'CP50222');\n}\n/* Go from JIS X 0201 to ASCII or JIS X 0208 */\nconvertValidString(\"\\xFF\\x61\\x00A\", \"\\x0E\\x21\\x0FA\", 'UTF-16BE', 'CP50222', false);\nconvertValidString(\"\\xFF\\x61\\x22\\x25\", \"\\x0E\\x21\\x0F\\x1B\\$B\\x21\\x42\\x1B(B\", 'UTF-16BE', 'CP50222', false);\nconvertValidString(\"\\xFF\\x61\\x20\\x3E\", \"\\x0E\\x21\\x0F\\x1B(J\\x7E\\x1B(B\", 'UTF-16BE', 'CP50222');\necho \"JIS X 0201 support OK\\n\";\n/* All valid CP932 characters */\nforeach ($cp932Chars as $cp932 => $utf16BE) {\n  testValid(\"\\x1B\\$B\" . $cp932, $utf16BE, 'CP50220');\n  testValid(\"\\x1B\\$B\" . $cp932, $utf16BE, 'CP50221');\n  testValid(\"\\x1B\\$B\" . $cp932, $utf16BE, 'CP50222');\n}\nforeach ($nonInvertible as $cp932 => $utf16BE) {\n  testValid(\"\\x1B\\$B\" . $cp932, $utf16BE, 'CP50220', false);\n  testValid(\"\\x1B\\$B\" . $cp932, $utf16BE, 'CP50221', false);\n  testValid(\"\\x1B\\$B\" . $cp932, $utf16BE, 'CP50222', false);\n}\n/* There are some conversions we support from Unicode -> CP5022x, but not in the opposite direction */\nforeach (['CP50220', 'CP50221', 'CP50222'] as $encoding) {\n  convertValidString(\"\\x22\\x25\", \"\\x1B\\$B\\x21\\x42\\x1B(B\", 'UTF-16BE', $encoding, false);\n  convertValidString(\"\\xFF\\x0D\", \"\\x1B\\$B\\x21\\x5D\\x1B(B\", 'UTF-16BE', $encoding, false);\n  convertValidString(\"\\xFF\\xE0\", \"\\x1B\\$B\\x21\\x71\\x1B(B\", 'UTF-16BE', $encoding, false);\n  convertValidString(\"\\xFF\\xE1\", \"\\x1B\\$B\\x21\\x72\\x1B(B\", 'UTF-16BE', $encoding, false);\n  convertValidString(\"\\xFF\\xE2\", \"\\x1B\\$B\\x22\\x4C\\x1B(B\", 'UTF-16BE', $encoding, false);\n}\n/* All invalid 2-byte CP932 characters */\nfor ($i = 0x21; $i <= 0x97; $i++) {\n  for ($j = 0; $j < 256; $j++) {\n    $testString = chr($i) . chr($j);\n    if (!isset($cp932Chars[$testString]) && !isset($nonInvertible[$testString])) {\n      testInvalid(\"\\x1B\\$B\" . $testString, \"\\x00%\", 'CP50220');\n      testInvalid(\"\\x1B\\$B\" . $testString, \"\\x00%\", 'CP50221');\n      testInvalid(\"\\x1B\\$B\" . $testString, \"\\x00%\", 'CP50222');\n    }\n  }\n}\n/* Try truncated 2-byte characters */\nfor ($i = 0x21; $i <= 0x97; $i++) {\n  testInvalid(\"\\x1B\\$B\" . chr($i), \"\\x00%\", 'CP50220');\n  testInvalid(\"\\x1B\\$B\" . chr($i), \"\\x00%\", 'CP50221');\n  testInvalid(\"\\x1B\\$B\" . chr($i), \"\\x00%\", 'CP50222');\n}\n/* Test alternative escape sequence to select CP932 */\ntestValid(\"\\x1B\\$(B\\x21\\x21\", \"\\x30\\x00\", 'CP50220', false);\necho \"CP932 support OK\\n\";\nforeach ($jisx0212Chars as $jisx0212 => $utf16BE) {\n  testValid(\"\\x1B\\$(D\" . $jisx0212, $utf16BE, 'CP50220', false);\n  testValid(\"\\x1B\\$(D\" . $jisx0212, $utf16BE, 'CP50221', false);\n  testValid(\"\\x1B\\$(D\" . $jisx0212, $utf16BE, 'CP50222', false);\n}\nfor ($i = 0x21; $i <= 0x97; $i++) {\n  for ($j = 0; $j < 256; $j++) {\n    $testString = chr($i) . chr($j);\n    if (!isset($jisx0212Chars[$testString])) {\n      testInvalid(\"\\x1B\\$(D\" . $testString, \"\\x00%\", 'CP50220');\n      testInvalid(\"\\x1B\\$(D\" . $testString, \"\\x00%\", 'CP50221');\n      testInvalid(\"\\x1B\\$(D\" . $testString, \"\\x00%\", 'CP50222');\n    }\n  }\n}\nfor ($i = 0x21; $i <= 0x97; $i++) {\n  testInvalid(\"\\x1B\\$(D\" . chr($i), \"\\x00%\", 'CP50220');\n  testInvalid(\"\\x1B\\$(D\" . chr($i), \"\\x00%\", 'CP50221');\n  testInvalid(\"\\x1B\\$(D\" . chr($i), \"\\x00%\", 'CP50222');\n}\necho \"JIS X 0212 support OK\\n\";\n/* Unicode codepoint for halfwidth katakana -> kuten code for ordinary katakana */\n$fullwidthKatakana = array(\n  0xFF61 => 0x2123, /* Ideographic full stop */\n  0xFF62 => 0x2156, /* Left corner bracket */\n  0xFF63 => 0x2157, /* Right corner bracket */\n  0xFF64 => 0x2122, /* Ideographic comma */\n  0xFF65 => 0x2126, /* Katakana middle dot */\n  0xFF66 => 0x2572, /* Wo */\n  0xFF67 => 0x2521, /* Small A */\n  0xFF68 => 0x2523, /* Small I */\n  0xFF69 => 0x2525, /* Small U */\n  0xFF6A => 0x2527, /* Small E */\n  0xFF6B => 0x2529, /* Small O */\n  0xFF6C => 0x2563, /* Small Ya */\n  0xFF6D => 0x2565, /* Small Yu */\n  0xFF6E => 0x2567, /* Small Yo */\n  0xFF6F => 0x2543, /* Small Tsu */\n  0xFF70 => 0x213C, /* Prolonged Sound Marker */\n  0xFF71 => 0x2522, /* A */\n  0xFF72 => 0x2524, /* I */\n  0xFF73 => 0x2526, /* U */\n  0xFF74 => 0x2528, /* E */\n  0xFF75 => 0x252A, /* O */\n  0xFF76 => 0x252B, /* Ka */\n  0xFF77 => 0x252D, /* Ki */\n  0xFF78 => 0x252F, /* Ku */\n  0xFF79 => 0x2531, /* Ke */\n  0xFF7A => 0x2533, /* Ko */\n  0xFF7B => 0x2535, /* Sa */\n  0xFF7C => 0x2537, /* Shi */\n  0xFF7D => 0x2539, /* Su */\n  0xFF7E => 0x253B, /* Se */\n  0xFF7F => 0x253D, /* So */\n  0xFF80 => 0x253F, /* Ta */\n  0xFF81 => 0x2541, /* Chi */\n  0xFF82 => 0x2544, /* Tsu */\n  0xFF83 => 0x2546, /* Te */\n  0xFF84 => 0x2548, /* To */\n  0xFF85 => 0x254A, /* Na */\n  0xFF86 => 0x254B, /* Ni */\n  0xFF87 => 0x254C, /* Nu */\n  0xFF88 => 0x254D, /* Ne */\n  0xFF89 => 0x254E, /* No */\n  0xFF8A => 0x254F, /* Ha */\n  0xFF8B => 0x2552, /* Hi */\n  0xFF8C => 0x2555, /* Fu */\n  0xFF8D => 0x2558, /* He */\n  0xFF8E => 0x255B, /* Ho */\n  0xFF8F => 0x255E, /* Ma */\n  0xFF90 => 0x255F, /* Mi */\n  0xFF91 => 0x2560, /* Mu */\n  0xFF92 => 0x2561, /* Me */\n  0xFF93 => 0x2562, /* Mo */\n  0xFF94 => 0x2564, /* Ya */\n  0xFF95 => 0x2566, /* Yu */\n  0xFF96 => 0x2568, /* Yo */\n  0xFF97 => 0x2569, /* Ra */\n  0xFF98 => 0x256A, /* Ri */\n  0xFF99 => 0x256B, /* Ru */\n  0xFF9A => 0x256C, /* Re */\n  0xFF9B => 0x256D, /* Ro */\n  0xFF9C => 0x256F, /* Wa */\n  0xFF9D => 0x2573, /* N */\n  0xFF9E => 0x212B, /* Voice Mark */\n  0xFF9F => 0x212C  /* Semi-voice Mark */\n);\nforeach ($fullwidthKatakana as $cp => $kuten) {\n  convertValidString(pack('n', $cp), \"\\x1B\\$B\" . pack('n', $kuten) . \"\\x1B(B\", 'UTF-16BE', 'CP50220', false);\n}\necho \"Folding of fullwidth katakana for CP50220 OK\\n\";\ntestInvalidString(\"\\xD8\\x00\", '%', 'UTF-16BE', 'CP50220');\ntestInvalidString(\"\\xD8\\x00\", '%', 'UTF-16BE', 'CP50221');\ntestInvalidString(\"\\xD8\\x00\", '%', 'UTF-16BE', 'CP50222');\necho \"Invalid Unicode is flagged when converting to CP5022x\\n\";\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\x80\", \"%\", \"CP50220\", \"UTF-8\");\nconvertInvalidString(\"\\x80\", \"%\", \"CP50221\", \"UTF-8\");\nconvertInvalidString(\"\\x80\", \"%\", \"CP50222\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$B1\", \"%\", \"CP50220\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$B1\", \"%\", \"CP50221\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$B1\", \"%\", \"CP50222\", \"UTF-8\");\necho \"Long error markers OK\\n\";\n?>")).toMatchSnapshot();
  });
});
