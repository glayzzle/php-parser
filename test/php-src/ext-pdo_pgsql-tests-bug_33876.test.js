// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_pgsql/tests/bug_33876.phpt
  it("PDO PgSQL Bug #33876 (PDO misquotes/miscasts bool(false))", function () {
    expect(parser.parseCode("<?php\nrequire __DIR__ . '/../../../ext/pdo/tests/pdo_test.inc';\n$db = PDOTest::test_factory(__DIR__ . '/common.phpt');\n$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);\n$db->exec(\"SET LC_MESSAGES='C'\");\n$db->exec('CREATE TABLE test (foo varchar(5) NOT NULL, bar bool NOT NULL)');\n$db->exec(\"INSERT INTO test VALUES('false','f')\");\n$db->exec(\"INSERT INTO test VALUES('true', 't')\");\n$res = $db->prepare('SELECT foo from test where bar = ?');\n# this is the portable approach to binding a bool\n$res->bindValue(1, false, PDO::PARAM_BOOL);\nif (!$res->execute())\n    print_r($res->errorInfo());\nelse\n    print_r($res->fetchAll(PDO::FETCH_ASSOC));\n# this is the portable approach to binding a bool\n$res->bindValue(1, true, PDO::PARAM_BOOL);\nif (!$res->execute())\n    print_r($res->errorInfo());\nelse\n    print_r($res->fetchAll(PDO::FETCH_ASSOC));\n# true gets cast to string (because the implied default is string)\n# true-as-string is 1, so this \"works\"\nif (!$res->execute(array(true)))\n    print_r($res->errorInfo());\nelse\n    print_r($res->fetchAll(PDO::FETCH_ASSOC));\n# Expected to fail; unless told otherwise, PDO assumes string inputs\n# false -> \"\" as string, which pgsql doesn't like\nif (!$res->execute(array(false)))\n    print_r(normalizeErrorInfo($res->errorInfo()));\nelse\n    print_r($res->fetchAll(PDO::FETCH_ASSOC));\n# And now using emulator prepares\necho \"EMUL\\n\";\n$res = $db->prepare('SELECT foo from test where bar = ?', array(\n    PDO::ATTR_EMULATE_PREPARES => true));\n# this is the portable approach to binding a bool\n$res->bindValue(1, false, PDO::PARAM_BOOL);\nif (!$res->execute())\n    print_r($res->errorInfo());\nelse\n    print_r($res->fetchAll(PDO::FETCH_ASSOC));\n# this is the portable approach to binding a bool\n$res->bindValue(1, true, PDO::PARAM_BOOL);\nif (!$res->execute())\n    print_r($res->errorInfo());\nelse\n    print_r($res->fetchAll(PDO::FETCH_ASSOC));\n# true gets cast to string (because the implied default is string)\n# true-as-string is 1, so this \"works\"\nif (!$res->execute(array(true)))\n    print_r($res->errorInfo());\nelse\n    print_r($res->fetchAll(PDO::FETCH_ASSOC));\n# Expected to fail; unless told otherwise, PDO assumes string inputs\n# false -> \"\" as string, which pgsql doesn't like\nif (!$res->execute(array(false))) {\n    print_r(normalizeErrorInfo($res->errorInfo()));\n} else {\n    print_r($res->fetchAll(PDO::FETCH_ASSOC));\n}\nfunction normalizeErrorInfo(array $err): array {\n    // Strip additional lines outputted by recent PgSQL versions\n    $err[2] = trim(current(explode(\"\\n\", $err[2])));\n    return $err;\n}\n?>")).toMatchSnapshot();
  });
});
