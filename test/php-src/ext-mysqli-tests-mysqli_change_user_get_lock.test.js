// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mysqli/tests/mysqli_change_user_get_lock.phpt
  it("mysqli_change_user() - GET_LOCK()", function () {
    expect(parser.parseCode("<?php\n    require_once('connect.inc');\n    require_once('table.inc');\n    // We need this little hack to be able to re-run the test\n    $lock = 'phptest_' . mt_rand(0, 100000);\n    $thread_id = mysqli_thread_id($link);\n    printf(\"Testing GET_LOCK()...\\n\");\n    if (!$res = mysqli_query($link, sprintf('SELECT GET_LOCK(\"%s\", 2) AS _ok', $lock)))\n        printf(\"[001] [%d] %s\\n\", mysqli_errno($link), mysqli_error($link));\n    if (!$row = mysqli_fetch_assoc($res))\n        printf(\"[002] [%d] %s\\n\", mysqli_errno($link), mysqli_error($link));\n    if ($row['_ok'] != 1)\n        printf(\"[003] [%d] %s\\n\", mysqli_errno($link), mysqli_error($link));\n    else\n        printf(\"... lock '%s' acquired by thread %d\\n\", $lock, $thread_id);\n    mysqli_free_result($res);\n    // GET_LOCK(\"phptest\") should be released\n    /* From the mysql_change_user documentation:\nThis command resets the state as if one had done a new connect. (See Section 25.2.13, “Controlling Automatic Reconnect Behavior”.) It always performs a ROLLBACK of any active transactions, closes and drops all temporary tables, and unlocks all locked tables. Session system variables are reset to the values of the corresponding global system variables. Prepared statements are released and HANDLER variables are closed. Locks acquired with GET_LOCK() are released. These effects occur even if the user didn't change.\n    */\n    mysqli_change_user($link, $user, $passwd, $db);\nsleep(5);\n    $new_thread_id = mysqli_thread_id($link);\n    printf(\"... calling IS_USED_LOCK() on '%s' using thread '%d'\\n\", $lock, $new_thread_id);\n    if (!$res = mysqli_query($link, 'SELECT IS_USED_LOCK(\"phptest\") AS _ok'))\n        printf(\"[004] [%d] %s\\n\", mysqli_errno($link), mysqli_error($link));\n    if (!$row = mysqli_fetch_assoc($res))\n        printf(\"[005] [%d] %s\\n\", mysqli_errno($link), mysqli_error($link));\n    if ($row['_ok'] != NULL)\n        printf(\"[006] Lock '%s' should have been released, [%d] %s\\n\",\n            $lock,\n            mysqli_errno($link), mysqli_error($link));\n    printf(\"... calling IS_FREE_LOCK() on '%s' using thread '%d'\\n\", $lock, $new_thread_id);\n    if (!$res = mysqli_query($link, 'SELECT IS_FREE_LOCK(\"phptest\") AS _ok'))\n        printf(\"[007] [%d] %s\\n\", mysqli_errno($link), mysqli_error($link));\n    if (!$row = mysqli_fetch_assoc($res))\n        printf(\"[008] [%d] %s\\n\", mysqli_errno($link), mysqli_error($link));\n    if ($row['_ok'] != 1)\n        printf(\"[009] Lock '%s' should have been released, [%d] %s\\n\",\n            $lock,\n            mysqli_errno($link), mysqli_error($link));\n    mysqli_free_result($res);\n    /* Ok, let's try a NEW connection and a NEW lock! */\n    mysqli_close($link);\n    if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket))\n        printf(\"[010] Cannot open new connection, [%d] %s\\n\",\n            mysqli_connect_errno(), mysqli_connect_error());\n    do {\n        $newlock = 'phptest_' . mt_rand(0, 100000);\n    } while ($lock == $newlock);\n    $new_thread_id = mysqli_thread_id($link);\n    printf(\"... calling IS_USED_LOCK() on '%s' using new connection with thread '%d'\\n\", $newlock, $new_thread_id);\n    if (!$res = mysqli_query($link, 'SELECT IS_USED_LOCK(\"phptest\") AS _ok'))\n        printf(\"[011] [%d] %s\\n\", mysqli_errno($link), mysqli_error($link));\n    if (!$row = mysqli_fetch_assoc($res))\n        printf(\"[012] [%d] %s\\n\", mysqli_errno($link), mysqli_error($link));\n    if ($row['_ok'] != NULL)\n        printf(\"[013] Lock '%s' should have been released, [%d] %s\\n\",\n            $lock,\n            mysqli_errno($link), mysqli_error($link));\n    print \"done!\";\n?>")).toMatchSnapshot();
  });
});
