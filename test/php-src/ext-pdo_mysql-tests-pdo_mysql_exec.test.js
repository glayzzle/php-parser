// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_mysql/tests/pdo_mysql_exec.phpt
  it("MySQL PDO->exec(), affected rows", function () {
    expect(parser.parseCode("<?php\n    function exec_and_count($offset, &$db, $sql, $exp = NULL) {\n        try {\n            $ret = $db->exec($sql);\n            if (!is_null($exp) && ($ret !== $exp)) {\n                printf(\"[%03d] Expecting '%s'/%s got '%s'/%s when running '%s', [%s] %s\\n\",\n                    $offset, $exp, gettype($exp), $ret, gettype($ret), $sql,\n                    $db->errorCode(), implode(' ', $db->errorInfo()));\n                return false;\n            }\n        } catch (PDOException $e) {\n            printf(\"[%03d] '%s' has failed, [%s] %s\\n\",\n                $offset, $sql, $db->errorCode(), implode(' ', $db->errorInfo()));\n            return false;\n        }\n        return true;\n    }\n    require_once(__DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');\n    $db = MySQLPDOTest::factory();\n    MySQLPDOTest::createTestTable($db, MySQLPDOTest::detect_transactional_mysql_engine($db));\n    /* affected rows related */\n    try {\n        exec_and_count(2, $db, 'DROP TABLE IF EXISTS test', 0);\n        exec_and_count(3, $db, sprintf('CREATE TABLE test(id INT NOT NULL PRIMARY KEY, col1 CHAR(10)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE), 0);\n        exec_and_count(4, $db, \"INSERT INTO test(id, col1) VALUES (1, 'a')\", 1);\n        exec_and_count(5, $db, \"INSERT INTO test(id, col1) VALUES (2, 'b'), (3, 'c')\", 2);\n        exec_and_count(6, $db, \"UPDATE test SET id = 4 WHERE id = 3\", 1);\n        exec_and_count(7, $db, \"INSERT INTO test(id, col1) VALUES (1, 'd') ON DUPLICATE KEY UPDATE id = 3\", 2);\n        exec_and_count(8, $db, \"UPDATE test SET id = 5 WHERE id = 5\", 0);\n        exec_and_count(9, $db, \"INSERT INTO test(id, col1) VALUES (5, 'e') ON DUPLICATE KEY UPDATE id = 6\", 1);\n        exec_and_count(10, $db, \"REPLACE INTO test(id, col1) VALUES (5, 'f')\", 2);\n        exec_and_count(11, $db, \"REPLACE INTO test(id, col1) VALUES (6, 'g')\", 1);\n        exec_and_count(12, $db, 'DELETE FROM test WHERE id > 2', 4);\n        exec_and_count(13, $db, 'DROP TABLE test', 0);\n        exec_and_count(14, $db, 'SET @myvar = 1', 0);\n        exec_and_count(15, $db, 'THIS IS NOT VALID SQL, I HOPE', false);\n        printf(\"[016] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n        exec_and_count(36, $db, sprintf('CREATE TABLE test(id INT NOT NULL PRIMARY KEY, col1 CHAR(10)) ENGINE=%s', PDO_MYSQL_TEST_ENGINE), 0);\n        exec_and_count(37, $db, \"INSERT INTO test(id, col1) VALUES (1, 'a')\", 1);\n        // Results may vary. Typically you will get 1. But the MySQL 5.1 manual states: Truncation operations do not return the number of deleted rows.\n        // Don't rely on any return value!\n        exec_and_count(38, $db, 'TRUNCATE TABLE test', NULL);\n    } catch (PDOException $e) {\n        printf(\"[001] %s, [%s] %s\\n\",\n            $e->getMessage(),\n            $db->errorCode(), implode(' ', $db->errorInfo()));\n    }\n    /* CREATE, DROP, CALL SP and SF */\n    if (MySQLPDOTest::getServerVersion($db) > 50000) {\n        // let's try to play with stored procedures\n        try {\n            $ignore_exception = true;\n            exec_and_count(18, $db, 'DROP PROCEDURE IF EXISTS p', 0);\n            exec_and_count(19, $db, 'CREATE PROCEDURE p(OUT ver_param VARCHAR(255)) BEGIN SELECT VERSION() INTO ver_param; END;', 0);\n            // we got this far without problems. If there's an issue from now on, its a failure\n            $ignore_exception = false;\n            exec_and_count(20, $db, 'CALL p(@version)', 1);\n            $stmt = $db->query('SELECT @version AS p_version');\n            $tmp = $stmt->fetchAll(PDO::FETCH_ASSOC);\n            if (count($tmp) > 1 || !isset($tmp[0]['p_version'])) {\n                printf(\"[022] Data seems wrong, dumping\\n\");\n                var_dump($tmp);\n            } else {\n                $p_version = $tmp[0]['p_version'];\n            }\n            $stmt = $db->query('SELECT VERSION() AS _version');\n            $tmp  = $stmt->fetchAll(PDO::FETCH_ASSOC);\n            if (count($tmp) > 1 || !isset($tmp[0]['_version'])) {\n                printf(\"[023] Data seems wrong, dumping\\n\");\n                var_dump($tmp);\n            } else {\n                if ($p_version !== $tmp[0]['_version']) {\n                    printf(\"[024] Found different version strings, SP returned '%s'/%s, SELECT returned '%s'/%s\\n\",\n                        $p_version, gettype($p_version),\n                        $tmp[0]['_version'], gettype($tmp[0]['_version']));\n                }\n            }\n            exec_and_count(25, $db, 'DROP PROCEDURE IF EXISTS p', 0);\n        } catch (PDOException $e) {\n            // ignore it, we might not have sufficient permissions\n            if (!$ignore_exception)\n                printf(\"[021] %s, [%s] %s\\n\",\n                    $e->getMessage(),\n                    $db->errorCode(), implode(' ', $db->errorInfo()));\n        }\n        // stored function\n        try {\n            $ignore_exception = true;\n            exec_and_count(27, $db, 'DROP FUNCTION IF EXISTS f', 0);\n            exec_and_count(28, $db, 'CREATE FUNCTION f( ver_param VARCHAR(255)) RETURNS VARCHAR(255) DETERMINISTIC RETURN ver_param;', 0);\n            // we got this far without problems. If there's an issue from now on, its a failure\n            $ignore_exception = false;\n            $stmt = $db->query('SELECT f(VERSION()) AS f_version');\n            $tmp = $stmt->fetchAll(PDO::FETCH_ASSOC);\n            if (count($tmp) > 1 || !isset($tmp[0]['f_version'])) {\n                printf(\"[029] Data seems wrong, dumping\\n\");\n                var_dump($tmp);\n            } else {\n                $f_version = $tmp[0]['f_version'];\n            }\n            $stmt = $db->query('SELECT VERSION() AS _version');\n            $tmp  = $stmt->fetchAll(PDO::FETCH_ASSOC);\n            if (count($tmp) > 1 || !isset($tmp[0]['_version'])) {\n                printf(\"[030] Data seems wrong, dumping\\n\");\n                var_dump($tmp);\n            } else {\n                if ($f_version !== $tmp[0]['_version']) {\n                    printf(\"[031] Found different version strings, SF returned '%s'/%s, SELECT returned '%s'/%s\\n\",\n                        $f_version, gettype($f_version),\n                        $tmp[0]['_version'], gettype($tmp[0]['_version']));\n                }\n            }\n            exec_and_count(32, $db, 'DROP FUNCTION IF EXISTS f', 0);\n        } catch (PDOException $e) {\n            // ignore it, we might not have sufficient permissions\n            if (!$ignore_exception)\n                printf(\"[026] %s, [%s] %s\\n\",\n                    $e->getMessage(),\n                    $db->errorCode(), implode(' ', $db->errorInfo()));\n        }\n    }\n    // multi query\n    try {\n        $db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);\n        $exp = 0;\n        $tmp = @$db->exec(sprintf('DROP TABLE IF EXISTS test; CREATE TABLE test(id INT) ENGINE=%s', PDO_MYSQL_TEST_ENGINE));\n        if ($exp !== $tmp)\n            printf(\"[034] Expecting %s/%s got %s/%s, [%s] %s\\n\",\n                $exp, gettype($exp),\n                $tmp, gettype($tmp),\n                $db->errorCode(), var_export($db->errorInfo(), true));\n        // this is interesting: if we get sort of affected rows, what will happen now?\n        $tmp = @$db->exec('INSERT INTO test(id) VALUES (1); INSERT INTO test(id) VALUES (2)');\n        printf(\"[035] With emulated PS it works but makes no sense given that exec() returns sort of affected rows...\\n\");\n    } catch (PDOException $e) {\n        printf(\"[033] %s, [%s] %s\\n\",\n            $e->getMessage(),\n            $db->errorCode(), implode(' ', $db->errorInfo()));\n    }\n    $db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);\n    print \"done!\";\n?>")).toMatchSnapshot();
  });
});
