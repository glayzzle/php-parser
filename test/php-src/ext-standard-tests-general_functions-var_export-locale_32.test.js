// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/standard/tests/general_functions/var_export-locale_32.phpt
  it("Test var_export() function with locale", function () {
    expect(parser.parseCode("<?php\nsetlocale(LC_ALL, \"german\", \"de\",\"de_DE\",\"de_DE.ISO8859-1\",\"de_DE.ISO_8859-1\",\"de_DE.UTF-8\");\necho \"*** Testing var_export() with integer values ***\\n\";\n// different integer values\n$valid_ints = array(\n                '0',\n                '1',\n                '-1',\n                '-2147483648', // max negative integer value\n                '-2147483647',\n                2147483647,  // max positive integer value\n                2147483640,\n                0x123B,      // integer as hexadecimal\n                '0x12ab',\n                '0Xfff',\n                '0XFA',\n                -0x7fffffff - 1, // max negative integer as hexadecimal\n                '0x7fffffff',  // max positive integer as hexadecimal\n                0x7FFFFFFF,  // max positive integer as hexadecimal\n                '0123',        // integer as octal\n                01,       // should be quivalent to octal 1\n                -017777777777 - 1, // max negative integer as octal\n                017777777777,  // max positive integer as octal\n               );\n$counter = 1;\n/* Loop to check for above integer values with var_export() */\necho \"\\n*** Output for integer values ***\\n\";\nforeach($valid_ints as $int_value) {\necho \"\\nIteration \".$counter.\"\\n\";\nvar_export( $int_value );\necho \"\\n\";\nvar_export( $int_value, FALSE);\necho \"\\n\";\nvar_dump( var_export( $int_value, TRUE) );\necho \"\\n\";\n$counter++;\n}\necho \"*** Testing var_export() with valid boolean values ***\\n\";\n// different valid  boolean values\n$valid_bool = array(\n            1,\n            TRUE,\n                true,\n                0,\n            FALSE,\n            false\n               );\n$counter = 1;\n/* Loop to check for above boolean values with var_export() */\necho \"\\n*** Output for boolean values ***\\n\";\nforeach($valid_bool as $bool_value) {\necho \"\\nIteration \".$counter.\"\\n\";\nvar_export( $bool_value );\necho \"\\n\";\nvar_export( $bool_value, FALSE);\necho \"\\n\";\nvar_dump( var_export( $bool_value, TRUE) );\necho \"\\n\";\n$counter++;\n}\necho \"*** Testing var_export() with valid float values ***\\n\";\n// different valid  float values\n$valid_floats = array(\n  (float)-2147483649, // float value\n  (float)2147483648,  // float value\n  (float)-0x80000001, // float value, beyond max negative int\n  (float)0x800000001, // float value, beyond max positive int\n  (float)020000000001, // float value, beyond max positive int\n  (float)-020000000001, // float value, beyond max negative int\n  0.0,\n  -0.1,\n  10.0000000000000000005,\n  10.5e+5,\n  1e5,\n  1e-5,\n  1e+5,\n  1E5,\n  1E+5,\n  1E-5,\n  .5e+7,\n  .6e-19,\n  .05E+44,\n  .0034E-30\n);\n$counter = 1;\n/* Loop to check for above float values with var_export() */\necho \"\\n*** Output for float values ***\\n\";\nforeach($valid_floats as $float_value) {\necho \"\\nIteration \".$counter.\"\\n\";\nvar_export( $float_value );\necho \"\\n\";\nvar_export( $float_value, FALSE);\necho \"\\n\";\nvar_dump( var_export( $float_value, TRUE) );\necho \"\\n\";\n$counter++;\n}\necho \"*** Testing var_export() with valid strings ***\\n\";\n// different valid  string\n$valid_strings = array(\n            \"\",\n            \" \",\n            '',\n            ' ',\n            \"string\",\n            'string',\n            \"NULL\",\n            'null',\n            \"FALSE\",\n            'false',\n            \"\\x0b\",\n            \"\\0\",\n            '\\0',\n            '\\060',\n            \"\\070\"\n          );\n$counter = 1;\n/* Loop to check for above strings with var_export() */\necho \"\\n*** Output for strings ***\\n\";\nforeach($valid_strings as $str) {\necho \"\\nIteration \".$counter.\"\\n\";\nvar_export( $str );\necho \"\\n\";\nvar_export( $str, FALSE);\necho \"\\n\";\nvar_dump( var_export( $str, TRUE) );\necho \"\\n\";\n$counter++;\n}\necho \"*** Testing var_export() with valid arrays ***\\n\";\n// different valid  arrays\n$valid_arrays = array(\n           array(),\n           array(NULL),\n           array(null),\n           array(true),\n           array(\"\"),\n           array(''),\n           array(array(), array()),\n           array(array(1, 2), array('a', 'b')),\n           array(1 => 'One'),\n           array(\"test\" => \"is_array\"),\n           array(0),\n           array(-1),\n           array(10.5, 5.6),\n           array(\"string\", \"test\"),\n           array('string', 'test')\n          );\n$counter = 1;\n/* Loop to check for above arrays with var_export() */\necho \"\\n*** Output for arrays ***\\n\";\nforeach($valid_arrays as $arr) {\necho \"\\nIteration \".$counter.\"\\n\";\nvar_export( $arr );\necho \"\\n\";\nvar_export( $arr, FALSE);\necho \"\\n\";\nvar_dump( var_export( $arr, TRUE) );\necho \"\\n\";\n$counter++;\n}\necho \"*** Testing var_export() with valid objects ***\\n\";\n// class with no members\nclass foo\n{\n// no members\n}\n// abstract class\nabstract class abstractClass\n{\n  abstract protected function getClassName();\n  public function printClassName () {\n    echo $this->getClassName() . \"\\n\";\n  }\n}\n// implement abstract class\nclass concreteClass extends abstractClass\n{\n  protected function getClassName() {\n    return \"concreteClass\";\n  }\n}\n// interface class\ninterface iValue\n{\n   public function setVal ($name, $val);\n   public function dumpVal ();\n}\n// implement the interface\nclass Value implements iValue\n{\n  private $vars = array ();\n  public function setVal ( $name, $val ) {\n    $this->vars[$name] = $val;\n  }\n  public function dumpVal () {\n    var_export ( $vars );\n  }\n}\n// a gereral class\nclass myClass\n{\n  var $foo_object;\n  public $public_var;\n  public $public_var1;\n  private $private_var;\n  protected $protected_var;\n  function __construct ( ) {\n    $this->foo_object = new foo();\n    $this->public_var = 10;\n    $this->public_var1 = new foo();\n    $this->private_var = new foo();\n    $this->proected_var = new foo();\n  }\n}\n// create a object of each class defined above\n$myClass_object = new myClass();\n$foo_object = new foo();\n$Value_object = new Value();\n$concreteClass_object = new concreteClass();\n$valid_objects = array(\n                  new stdclass,\n                  new foo,\n                  new concreteClass,\n                  new Value,\n                  new myClass,\n                  $myClass_object,\n                  $myClass_object->foo_object,\n                  $myClass_object->public_var1,\n                  $foo_object,\n                  $Value_object,\n                  $concreteClass_object\n                 );\n $counter = 1;\n/* Loop to check for above objects with var_export() */\necho \"\\n*** Output for objects ***\\n\";\nforeach($valid_objects as $obj) {\necho \"\\nIteration \".$counter.\"\\n\";\nvar_export( $obj );\necho \"\\n\";\nvar_export( $obj, FALSE);\necho \"\\n\";\nvar_dump( var_export( $obj, TRUE) );\necho \"\\n\";\n$counter++;\n}\necho \"*** Testing var_export() with valid null values ***\\n\";\n// different valid  null values\n$unset_var = array();\nunset ($unset_var); // now a null\n$null_var = NULL;\n$valid_nulls = array(\n                NULL,\n                null,\n                $null_var,\n               );\n $counter = 1;\n/* Loop to check for above null values with var_export() */\necho \"\\n*** Output for null values ***\\n\";\nforeach($valid_nulls as $null_value) {\necho \"\\nIteration \".$counter.\"\\n\";\nvar_export( $null_value );\necho \"\\n\";\nvar_export( $null_value, FALSE);\necho \"\\n\";\nvar_dump( var_export( $null_value, true) );\necho \"\\n\";\n$counter++;\n}\necho \"\\nDone\";\n?>")).toMatchSnapshot();
  });
});
