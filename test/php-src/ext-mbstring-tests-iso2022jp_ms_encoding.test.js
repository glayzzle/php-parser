// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/iso2022jp_ms_encoding.phpt
  it("Exhaustive test of ISO-2022-JP-MS text encoding", function () {
    expect(parser.parseCode("<?php\nsrand(444); /* Make results consistent */\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\nfunction shiftJISDecode($bytes) {\n  /* Convert CP932's default Shift-JIS representation to kuten code */\n  $first = ($bytes >> 8) & 0xFF;\n  $second = $bytes & 0xFF;\n  $hi_bits = $first - (($first > 0x9F) ? 0xE0 - 31 : 0x81);\n  if ($second > 0x9E) {\n    $kuten = ((($hi_bits << 1) + 0x22) << 8) + ($second - 0x9F + 0x21);\n  } else if ($second > 0x7F) {\n    $kuten = ((($hi_bits << 1) + 0x21) << 8) + ($second - 0x80 + 63 + 0x21);\n  } else {\n    $kuten = ((($hi_bits << 1) + 0x21) << 8) + ($second - 0x40 + 0x21);\n  }\n  return $kuten;\n}\n/* Read in the table of all characters in CP932 */\n$cp932Chars = array(); /* CP932 string -> UTF-32BE string */\n$fp = fopen(realpath(__DIR__ . '/data/CP932.txt'), 'r+');\nwhile ($line = fgets($fp, 256)) {\n  if ($line[0] == '#')\n    continue;\n  if (sscanf($line, \"0x%x\\t0x%x\", $bytes, $codepoint) == 2) {\n    if ($bytes < 256)\n      continue;\n    /* ISO-2022-JP-MS only uses the first two ranges of MS vendor extensions */\n    if ($bytes >= 0xFA00)\n      continue;\n    $cp932Chars[pack('n', shiftJISDecode($bytes))] = pack('N', $codepoint);\n  }\n}\n/* Windows-932 has many cases where two different kuten codes map to the same\n * Unicode codepoints */\nforeach ([0x8790, 0x8791, 0x8792, 0x8795, 0x8796, 0x8797, 0x879A, 0x879B, 0x879C, 0xEEF9] as $i) {\n  $bytes = pack('n', shiftJISDecode($i));\n  $nonInvertible[$bytes] = $cp932Chars[$bytes];\n}\n/* Add User Defined codes (which use ESC $ ( ? escape sequence)) */\n$udcChars = array();\nfor ($cp = 0xE000; $cp < (0xE000 + (20 * 94)); $cp++) {\n  $i = $cp - 0xE000;\n  $bytes = (((int)($i / 94) + 0x21) << 8) + (($i % 94) + 0x21);\n  $udcChars[pack('n', $bytes)] = pack('N', $cp);\n}\n/* Read in table of all characters in JISX-0201 charset */\n$jisx0201Chars = array(); /* JISX0201 -> UTF-32BE */\n$fp = fopen(realpath(__DIR__ . '/data/JISX0201.txt'), 'r+');\nwhile ($line = fgets($fp, 256)) {\n  if ($line[0] == '#')\n    continue;\n  if (sscanf($line, \"0x%x\\t0x%x\", $byte, $codepoint) == 2)\n    $jisx0201Chars[chr($byte)] = pack('N', $codepoint);\n}\nfunction testValid($from, $to, $encoding, $bothWays = true) {\n  identifyValidString($from, $encoding);\n  convertValidString($from, $to, $encoding, 'UTF-32BE', false);\n  if ($bothWays) {\n    /* ESC ( B at the beginning is redundant, since ASCII mode is the default */\n    if (substr($from, 0, 3) == \"\\x1B(B\")\n      $from = substr($from, 3, strlen($from) - 3);\n    /* If the string switches to a different charset, it should switch back to\n     * ASCII at the end */\n    if (strpos($from, \"\\x1B\\$B\") !== false || strpos($from, \"\\x1B(I\") !== false || strpos($from, \"\\x1B\\$@\") !== false || strpos($from, \"\\x1B\\$(B\") !== false || strpos($from, \"\\x1B\\$(@\") !== false || strpos($from, \"\\x1B\\$(?\") !== false)\n      $from .= \"\\x1B(B\";\n    convertValidString($to, $from, 'UTF-32BE', $encoding, false);\n  }\n}\nfunction testInvalid($from, $to, $encoding) {\n  testInvalidString($from, $to, $encoding, 'UTF-32BE');\n}\nfor ($i = 0; $i < 0x80; $i++) {\n  if ($i == 0x1B)\n    continue;\n  testValid(chr($i),            \"\\x00\\x00\\x00\" . chr($i), 'ISO-2022-JP-MS');\n  testValid(\"\\x1B(B\" . chr($i), \"\\x00\\x00\\x00\" . chr($i), 'ISO-2022-JP-MS', false);\n  testValid(\"\\x1B(J\" . chr($i), \"\\x00\\x00\\x00\" . chr($i), 'ISO-2022-JP-MS', false);\n}\nfor ($i = 0x80; $i < 256; $i++) {\n  if ($i >= 0xA1 && $i <= 0xDF) // We convert single bytes from 0xA1-0xDF as JIS X 0201 kana\n    continue;\n  testInvalid(chr($i),            \"\\x00\\x00\\x00%\", 'ISO-2022-JP-MS');\n  testInvalid(\"\\x1B(B\" . chr($i), \"\\x00\\x00\\x00%\", 'ISO-2022-JP-MS');\n  testInvalid(\"\\x1B(J\" . chr($i), \"\\x00\\x00\\x00%\", 'ISO-2022-JP-MS');\n}\necho \"ASCII support OK\\n\";\n/* All valid JIS X 0201 characters\n * Those with a 1 in the high bit are JIS X 0201 kana */\nforeach ($jisx0201Chars as $jisx0201 => $utf32BE) {\n  if (ord($jisx0201) >= 128) {\n    $kana = chr(ord($jisx0201) - 128);\n    testValid(\"\\x1B(I\" . $kana, $utf32BE, 'ISO-2022-JP-MS', false);\n    testValid($jisx0201, $utf32BE, 'ISO-2022-JP-MS', false);\n  }\n}\nfor ($i = 0x80; $i < 256; $i++) {\n  if ($i >= 0xA1 && $i <= 0xDF)\n    continue;\n  testInvalid(\"\\x1B(I\" . chr($i), \"\\x00\\x00\\x00%\", 'ISO-2022-JP-MS');\n  testInvalid(\"\\x1B(J\" . chr($i), \"\\x00\\x00\\x00%\", 'ISO-2022-JP-MS');\n}\necho \"JIS X 0201 support OK\\n\";\nfunction testAllValidCharsWithPrefix($validChars, $prefix, $bothWays) {\n  $good = array_keys($validChars);\n  shuffle($good);\n  while (!empty($good)) {\n    $length = min(rand(5,10), count($good));\n    $from = $to = '';\n    while ($length--) {\n      $goodChar = array_pop($good);\n      $from .= $goodChar;\n      $to .= $validChars[$goodChar];\n    }\n    testValid($prefix . $from, $to, 'ISO-2022-JP-MS', $bothWays);\n  }\n}\n$validChars = $cp932Chars;\n/* We allow ASCII/JIS X 0201 characters to appear even in JIS X 0208 mode */\nfor ($i = 0; $i <= 0x7F; $i++)\n  $validChars[chr($i)] = chr($i);\nfor ($i = 0xA1; $i <= 0xDF; $i++)\n  $validChars[chr($i)] = $jisx0201Chars[chr($i)];\n$lenTable = array_fill_keys(range(0xE0, 0xFC), 2) + array_fill_keys(range(0x81, 0x9F), 2);\nfindInvalidChars($validChars, $invalidChars, $truncatedChars, $lenTable);\nforeach ($nonInvertible as $bytes => $char)\n  unset($cp932Chars[$bytes]);\ntestAllValidCharsWithPrefix($cp932Chars, \"\\x1B\\$B\", true);\ntestAllValidCharsWithPrefix($nonInvertible, \"\\x1B\\$B\", false);\nforeach (array_keys($invalidChars) as $invalid) {\n  $firstByte = ord($invalid[0]);\n  if (($firstByte > 0x80 && $firstByte < 0xA0) || $firstByte >= 0xE0) {\n    /* The first byte of this 2-byte character will be rejected and result in % being sent\n     * to the output. Then the second byte will do something else. It is easier to write the\n     * test if we only check with the 1st byte. */\n    testInvalidString(\"\\x1B\\$B\" . $invalid[0], \"\\x00\\x00\\x00%\", 'ISO-2022-JP-MS', 'UTF-32BE');\n  } else {\n    testInvalidString(\"\\x1B\\$B\" . $invalid, \"\\x00\\x00\\x00%\", 'ISO-2022-JP-MS', 'UTF-32BE');\n  }\n}\nforeach (array_keys($truncatedChars) as $truncated)\n  testInvalidString(\"\\x1B\\$B\" . $truncated, \"\\x00\\x00\\x00%\", 'ISO-2022-JP-MS', 'UTF-32BE');\necho \"JIS X 0208 (with MS extensions) support OK\\n\";\n$validChars = $udcChars;\nfor ($i = 0; $i <= 0x7F; $i++)\n  $validChars[chr($i)] = chr($i);\nfor ($i = 0xA1; $i <= 0xDF; $i++)\n  $validChars[chr($i)] = $jisx0201Chars[chr($i)];\nfindInvalidChars($validChars, $invalidChars, $truncatedChars, array_fill_keys(range(0x21, 0x7F), 2));\ntestAllValidCharsWithPrefix($udcChars, \"\\x1B\\$(?\", true);\nforeach (array_keys($invalidChars) as $invalid) {\n  $firstByte = ord(substr($invalid, 0, 1));\n  if (($firstByte > 0x80 && $firstByte < 0xA0) || $firstByte >= 0xE0) {\n    testInvalidString(\"\\x1B\\$(?\" . $invalid[0], \"\\x00\\x00\\x00%\", 'ISO-2022-JP-MS', 'UTF-32BE');\n  } else {\n    testInvalidString(\"\\x1B\\$(?\" . $invalid, \"\\x00\\x00\\x00%\", 'ISO-2022-JP-MS', 'UTF-32BE');\n  }\n}\nforeach (array_keys($truncatedChars) as $truncated)\n  testInvalidString(\"\\x1B\\$(?\" . $truncated, \"\\x00\\x00\\x00%\", 'ISO-2022-JP-MS', 'UTF-32BE');\necho \"UDC support OK\\n\";\ntestValidString(\"\\x00\\xA5\", \"\\x1B\\$B!o\\x1B(B\", \"UTF-16BE\", \"ISO-2022-JP-MS\", false);\ntestValidString(\"\\x20\\x3E\", \"\\x1B\\$B!1\\x1B(B\", \"UTF-16BE\", \"ISO-2022-JP-MS\", false);\ntestValidString(\"\\xFF\\x5E\", \"\\x1B\\$B!A\\x1B(B\", \"UTF-16BE\", \"ISO-2022-JP-MS\", false);\necho \"Other mappings from Unicode -> ISO-2022-JP-MS OK\\n\";\n// Alternative escape sequences for 2-byte characters\ntestValidString(\"\\x1B\\$(B\\x21\\x21\", \"\\x30\\x00\", \"ISO-2022-JP-MS\", \"UTF-16BE\", false);\ntestValidString(\"\\x1B\\$(@\\x21\\x21\", \"\\x30\\x00\", \"ISO-2022-JP-MS\", \"UTF-16BE\", false);\n// Switching between different character types\ntestValidString(\"\\x00a\\x00b\\x00c\\xFF\\x61\\x00a\\x00b\\x00c\", \"abc\\x1B(I\\x21\\x1B(Babc\", \"UTF-16BE\", \"ISO-2022-JP-MS\", false);\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\xE0\", \"%\", \"ISO-2022-JP-MS\", \"UTF-8\");\n// Invalid escapes:\nconvertInvalidString(\"\\x1B\", \"%\", \"ISO-2022-JP-MS\", \"UTF-8\");\nconvertInvalidString(\"\\x1B.\", \"%\", \"ISO-2022-JP-MS\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$\", \"%\", \"ISO-2022-JP-MS\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$.\", \"%\", \"ISO-2022-JP-MS\", \"UTF-8\");\nconvertInvalidString(\"\\x1B(\", \"%\", \"ISO-2022-JP-MS\", \"UTF-8\");\nconvertInvalidString(\"\\x1B(.\", \"%\", \"ISO-2022-JP-MS\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$(\", \"%\", \"ISO-2022-JP-MS\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$(X\", \"%\", \"ISO-2022-JP-MS\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$B\\x9F\", \"%\", \"ISO-2022-JP-MS\", \"UTF-8\"); // 0x9F does not start any 2-byte character\necho \"Done!\\n\";\n?>")).toMatchSnapshot();
  });
});
