// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/utf8_mobile_encodings.phpt
  it("Exhaustive test of UTF-8 text encoding (DoCoMo, KDDI, SoftBank variants)", function () {
    expect(parser.parseCode("<?php\nsrand(855); /* Make results consistent */\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\n$badUTF8 = array(\n  // Codepoints outside of valid 0-0x10FFFF range for Unicode\n  \"\\xF4\\x90\\x80\\x80\" => str_repeat(\"\\x00\\x00\\x00%\", 4), // CP 0x110000\n  \"\\xF7\\x80\\x80\\x80\" => str_repeat(\"\\x00\\x00\\x00%\", 4), // CP 0x1C0000\n  \"\\xF7\\xBF\\xBF\\xBF\" => str_repeat(\"\\x00\\x00\\x00%\", 4), // CP 0x1FFFFF\n  // Reserved range for UTF-16 surrogate pairs\n  \"\\xED\\xA0\\x80\" => str_repeat(\"\\x00\\x00\\x00%\", 3),     // CP 0xD800\n  \"\\xED\\xAF\\xBF\" => str_repeat(\"\\x00\\x00\\x00%\", 3),     // CP 0xDBFF\n  \"\\xED\\xBF\\xBF\" => str_repeat(\"\\x00\\x00\\x00%\", 3),     // CP 0xDFFF\n  // Truncated characters\n  \"\\xDF\" => \"\\x00\\x00\\x00%\",         // should have been 2-byte\n  \"\\xEF\\xBF\" => \"\\x00\\x00\\x00%\",     // should have been 3-byte\n  \"\\xF0\\xBF\\xBF\" => \"\\x00\\x00\\x00%\", // should have been 4-byte\n  // Multi-byte characters which end too soon and go to ASCII\n  \"\\xDFA\" => \"\\x00\\x00\\x00%\\x00\\x00\\x00A\",\n  \"\\xEF\\xBFA\" => \"\\x00\\x00\\x00%\\x00\\x00\\x00A\",\n  \"\\xF0\\xBFA\" => \"\\x00\\x00\\x00%\\x00\\x00\\x00A\",\n  \"\\xF0\\xBF\\xBFA\" => \"\\x00\\x00\\x00%\\x00\\x00\\x00A\",\n  // Multi-byte characters which end too soon and go to another MB char\n  \"\\xDF\\xDF\\xBF\" => \"\\x00\\x00\\x00%\\x00\\x00\\x07\\xFF\",\n  \"\\xEF\\xBF\\xDF\\xBF\" => \"\\x00\\x00\\x00%\\x00\\x00\\x07\\xFF\",\n  \"\\xF0\\xBF\\xBF\\xDF\\xBF\" => \"\\x00\\x00\\x00%\\x00\\x00\\x07\\xFF\",\n  // Continuation bytes which appear outside of a MB char\n  \"\\x80\" => \"\\x00\\x00\\x00%\",\n  \"A\\x80\" => \"\\x00\\x00\\x00A\\x00\\x00\\x00%\",\n  \"\\xDF\\xBF\\x80\" => \"\\x00\\x00\\x07\\xFF\\x00\\x00\\x00%\",\n  // Overlong code units\n  // (Using more bytes than needed to encode a character)\n  \"\\xC1\\xBF\" => str_repeat(\"\\x00\\x00\\x00%\", 2),        // didn't need 2 bytes\n  \"\\xE0\\x9F\\xBF\" => str_repeat(\"\\x00\\x00\\x00%\", 3),    // didn't need 3 bytes\n  \"\\xF0\\x8F\\xBF\\xBF\" => str_repeat(\"\\x00\\x00\\x00%\", 4) // didn't need 4 bytes\n);\nfunction intToString($value) {\n  if ($value <= 0xFF)\n      return chr($value);\n  else if ($value <= 0xFFFF)\n      return pack('n', $value);\n  else if ($value <= 0xFFFFFF)\n      return chr($value >> 16) . pack('n', $value & 0xFFFF);\n  else\n      return pack('N', $value);\n}\nfunction readUTF8ConversionTable($path, &$from, &$to, &$invalid) {\n    $from = array();\n    $to   = array();\n    $invalid = array();\n    $fp = fopen($path, 'r+');\n    while ($line = fgets($fp, 256)) {\n        if (sscanf($line, \"0x%x\\t0x%x\", $codepoint, $char) == 2) {\n            $codepoint = pack('N', $codepoint);\n            $char = intToString($char);\n            $from[$char] = $codepoint;\n            $to[$codepoint] = $char;\n        } else if (sscanf($line, \"0x%x\\tBAD\", $codepoint) == 1) {\n          $codepoint = pack('N', $codepoint);\n          $invalid[$codepoint] = true;\n        }\n    }\n}\nfunction testUTF8Variant($encoding, $filename) {\n    readUTF8ConversionTable(__DIR__ . $filename, $toUnicode, $fromUnicode, $invalidCodepoints);\n    // Test some plain, vanilla codepoints (to/from mobile encoding)\n    testValidString(\"\\x00\\x00\", \"\\x00\", \"UTF-16BE\", $encoding);\n    for ($i = 0; $i < 1000; $i++) {\n      $cp = pack('N', rand(1, 0x10FFFF));\n      if (isset($fromUnicode[$cp]))\n        continue;\n      if (mb_convert_encoding($cp, $encoding, 'UTF-32BE') !== mb_convert_encoding($cp, 'UTF-8', 'UTF-32BE'))\n        die(\"Expected U+\" . bin2hex($cp) . \" to be the same in UTF-8 and \" . $encoding);\n    }\n    if ($encoding === 'UTF-8-Mobile#DOCOMO') {\n      // In Docomo Shift-JIS, we have mappings for U+FEE16 up to U+FEE25 and\n      // then U+FEE29-U+FEE2B, U+FEE2D-U+FEE33\n      // These correspond to sequential Docomo SJIS codes, but in the middle there is\n      // one emoji which converts to U+25EA (SQUARE WITH LOWER RIGHT DIAGONAL HALF BLACK)\n      // However, when converting Unicode to Docomo vendor-specific encodings, we still\n      // accept U+FEE26 and convert it to the same SQUARE WITH LOWER RIGHT DIAGONAL HALF BLACK emoji\n      // So our mapping for U+FEE26 is not reversible\n      // Encoded as UTF-8, that's EE9B80\n      unset($toUnicode[\"\\xEE\\x9B\\x80\"]);\n      // Similar for U+FEE27, U+FEE28, U+FEE2C\n      unset($toUnicode[\"\\xEE\\x9B\\x81\"]);\n      unset($toUnicode[\"\\xEE\\x9B\\x82\"]);\n      unset($toUnicode[\"\\xEE\\x9B\\x86\"]);\n    }\n    // Test all characters which are different in mobile encoding (from standard UTF-8)\n    foreach ($toUnicode as $char => $cp)\n      testValidString($char, $cp, $encoding, 'UCS-4BE', false);\n    foreach ($fromUnicode as $cp => $char)\n      testValidString($cp, $char, 'UCS-4BE', $encoding, false);\n    foreach ($invalidCodepoints as $cp => $_)\n      convertInvalidString($cp, '%', 'UCS-4BE', $encoding);\n    // Try malformed UTF-8 sequences\n    global $badUTF8;\n    foreach ($badUTF8 as $invalidText => $expectedResult)\n      testInvalidString($invalidText, $expectedResult, $encoding, 'UCS-4BE');\n    echo \"$encoding OK\\n\";\n}\ntestUTF8Variant('UTF-8-Mobile#DOCOMO', '/data/UTF-8-DOCOMO.txt');\ntestUTF8Variant('UTF-8-Mobile#KDDI-A', '/data/UTF-8-KDDI-A.txt');\ntestUTF8Variant('UTF-8-Mobile#KDDI-B', '/data/UTF-8-KDDI-B.txt');\ntestUTF8Variant('UTF-8-Mobile#SOFTBANK', '/data/UTF-8-SOFTBANK.txt');\n?>")).toMatchSnapshot();
  });
});
