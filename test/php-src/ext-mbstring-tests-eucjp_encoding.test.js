// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/eucjp_encoding.phpt
  it("Exhaustive test of EUC-JP encoding verification and conversion", function () {
    expect(parser.parseCode("<?php\nsrand(555); /* Make results consistent */\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\n/* Read in the table of all characters in EUC-JP */\nreadConversionTable(__DIR__ . '/data/EUC-JP.txt', $validChars, $fromUnicode, true);\n/* The JIS X 0208 character set does not have a single, straightforward\n * mapping to the Unicode character set */\n/* Kuten code 0x2140 (EUC-JP 0xA1C0) is a backslash; this can be mapped to\n * 0x005C for an ordinary backslash, or 0xFF3C for a _fullwidth_ one\n * We go with fullwidth */\n$validChars[\"\\xA1\\xC0\"] = \"\\x00\\x00\\xFF\\x3C\";\n$fromUnicode[\"\\x00\\x00\\xFF\\x3C\"] = \"\\xA1\\xC0\";\n/* Unicode has both halfwidth and fullwidth NOT SIGN; convert both of them\n * to JIS X 0208 NOT SIGN */\n$fromUnicode[\"\\x00\\x00\\xFF\\xE2\"] = \"\\xA2\\xCC\";\n/* Likewise for fullwidth and halfwidth POUND SIGN */\n$fromUnicode[\"\\x00\\x00\\xFF\\xE1\"] = \"\\xA1\\xF2\";\n/* Likewise for fullwidth and halfwidth CENT SIGN */\n$fromUnicode[\"\\x00\\x00\\xFF\\xE0\"] = \"\\xA1\\xF1\";\n/* Convert Unicode FULLWIDTH TILDE to JIS X 0208 WAVE DASH */\n$fromUnicode[\"\\x00\\x00\\xFF\\x5E\"] = \"\\xA1\\xC1\";\n/* Convert Unicode FULLWIDTH HYPHEN-MINUS to JIS X 0208 MINUS SIGN */\n$fromUnicode[\"\\x00\\x00\\xFF\\x0D\"] = \"\\xA1\\xDD\";\n/* Convert Unicode PARALLEL TO to JIS X 0208 DOUBLE VERTICAL LINE */\n$fromUnicode[\"\\x00\\x00\\x22\\x25\"] = \"\\xA1\\xC2\";\n/* Unicode 0x007E (tilde) can be represented in two different ways in EUC-JP\n * When converting Unicode to EUC-JP, use the simpler representation */\n$fromUnicode[\"\\x00\\x00\\x00\\x7E\"] = \"\\x7E\";\n/* Likewise with 0x005C */\n$fromUnicode[\"\\x00\\x00\\x00\\x5C\"] = \"\\x5C\";\n/* U+203E is OVERLINE; convert to FULLWIDTH MACRON */\n$fromUnicode[\"\\x00\\x00\\x20\\x3E\"] = \"\\xA1\\xB1\";\nfindInvalidChars($validChars, $invalidChars, $truncated, array_fill_keys(range(0xA1, 0xFE), 2) + array(0x8E => 2, 0x8F => 3));\n/* In the JIS X 0212 character set, kuten code 0x2237 (EUC-JP 0x8FA2B7)\n * is an ordinary tilde character\n * This mapping is not reversible, because ASCII 0x7E also represents\n * the same character */\nunset($validChars[\"\\x8F\\xA2\\xB7\"]);\ntestAllValidChars($validChars, 'EUC-JP', 'UTF-32BE');\necho \"Encoding verification and conversion work for all valid characters\\n\";\ntestAllInvalidChars($invalidChars, $validChars, 'EUC-JP', 'UTF-32BE', \"\\x00\\x00\\x00%\");\ntestTruncatedChars($truncated, 'EUC-JP', 'UTF-32BE', \"\\x00\\x00\\x00%\");\necho \"Encoding verification and conversion work for all invalid characters\\n\";\ntestValidString(\"\\x8F\\xA2\\xB7\", \"\\x00\\x00\\x00~\", 'EUC-JP', 'UTF-32BE', false);\necho \"Irreversible mapping of 0x8FA2B7 follows JIS X 0212 correctly\\n\";\ntestAllValidChars($fromUnicode, 'UTF-32BE', 'EUC-JP', false);\necho \"Unicode -> EUC-JP conversion works on all valid characters\\n\";\n$invalidChars = array();\nfor ($cp = 0; $cp <= 0xFFFF; $cp++) {\n  $char = pack('N', $cp);\n  if (!isset($fromUnicode[$char]))\n    $invalidChars[$char] = true;\n}\nconvertAllInvalidChars($invalidChars, $fromUnicode, 'UTF-32BE', 'EUC-JP', '%');\necho \"Unicode -> EUC-JP conversion works on all invalid characters\\n\";\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\x80\", \"%\", \"EUC-JP\", \"UTF-8\");\nconvertInvalidString(\"\\xFE\\xFF\", \"%\", \"EUC-JP\", \"UTF-8\");\necho \"Done!\\n\";\n?>")).toMatchSnapshot();
  });
});
