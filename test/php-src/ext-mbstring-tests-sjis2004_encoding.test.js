// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/sjis2004_encoding.phpt
  it("Exhaustive test of SJIS-2004 encoding verification and conversion", function () {
    expect(parser.parseCode("<?php\nsrand(101); /* Make results consistent */\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\n/* Read in the table of all characters in SJIS-2004 */\n$validChars = array(); /* SJIS-2004 string -> UTF-32BE string */\n$fromUnicode = array(); /* UTF-16BE -> SJIS-2004 */\n$fp = fopen(__DIR__ . '/data/SJIS-2004.txt', 'r+');\nwhile ($line = fgets($fp, 256)) {\n\tif ($line[0] == '#')\n\t\tcontinue;\n\t$codepoint2 = null;\n\tif (sscanf($line, \"0x%x\\tU+%x+%x\", $bytes, $codepoint1, $codepoint2) >= 2) {\n\t\t$sjis = ($bytes < 256) ? chr($bytes) : pack('n', $bytes);\n\t\tif ($codepoint2) {\n\t\t\t$validChars[$sjis] = pack('NN', $codepoint1, $codepoint2);\n\t\t} else {\n\t\t\t/* Two input byte sequences can translate to either a 'halfwidth' or a\n\t\t\t * 'fullwidth' version of a character; our implementation of SJIS-2004\n\t\t\t * translates them to the fullwidth versions */\n\t\t\tif (preg_match('/Fullwidth: U\\+([0-9A-F]+)/', $line, $match))\n\t\t\t\t$codepoint1 = hexdec($match[1]);\n\t\t\t$validChars[$sjis] = pack('N', $codepoint1);\n\t\t\tif ($codepoint1 <= 0xFFFF)\n\t\t\t\t$fromUnicode[pack('n', $codepoint1)] = $sjis;\n\t\t}\n\t}\n}\n/* U+007E is TILDE, Shift-JIS 0x8160 is WAVE DASH */\n$fromUnicode[\"\\x00\\x7E\"] = \"\\x81\\x60\";\n/* U+005C is backslash, Shift-JIS 0x815F is REVERSE SOLIDUS\n * (ie. a fancy way to say \"backslash\") */\n$fromUnicode[\"\\x00\\x5C\"] = \"\\x81\\x5F\";\ntestAllValidChars($validChars, 'SJIS-2004', 'UTF-32BE');\necho \"SJIS-2004 verification and conversion works for all valid characters\\n\";\nfindInvalidChars($validChars, $invalidChars, $truncated,\n\tarray_fill_keys(range(0x81, 0x9F), 2) + array_fill_keys(range(0xE0, 0xFC), 2));\ntestAllInvalidChars($invalidChars, $validChars, 'SJIS-2004', 'UTF-32BE', \"\\x00\\x00\\x00%\");\ntestTruncatedChars($truncated, 'SJIS-2004', 'UTF-32BE', \"\\x00\\x00\\x00%\");\necho \"SJIS-2004 verification and conversion rejects all invalid characters\\n\";\ntestAllValidChars($fromUnicode, 'UTF-16BE', 'SJIS-2004', false);\necho \"Unicode -> SJIS-2004 conversion works on all valid characters\\n\";\nfindInvalidChars($fromUnicode, $invalidChars, $unused, array_fill_keys(range(0, 0xFF), 2));\nconvertAllInvalidChars($invalidChars, $fromUnicode, 'UTF-16BE', 'SJIS-2004', '%');\necho \"Unicode -> SJIS-2004 conversion works on all invalid characters\\n\";\n// Some pairs of Unicode codepoints are represented by a single character in SJIS-2004\n// Test the case where the first codepoint looks like it might be one of these pairs...\n// but the second one doesn't match\nconvertValidString(\"\\x30\\x4B\\x00A\", \"\\x82\\xA9A\", 'UTF-16BE', 'SJIS-2004', false);\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\x80\", \"%\", \"SJIS-2004\", \"UTF-8\");\nconvertInvalidString(\"\\x81\\x20\", \"%\", \"SJIS-2004\", \"UTF-8\");\nconvertInvalidString(\"\\xFC\\xF5\", \"%\", \"SJIS-2004\", \"UTF-8\");\necho \"Done!\\n\";\n?>")).toMatchSnapshot();
  });
});
