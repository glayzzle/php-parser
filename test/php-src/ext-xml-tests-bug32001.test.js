// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/xml/tests/bug32001.phpt
  it("Bug #32001 (xml_parse*() goes into infinite loop when autodetection in effect), using UTF-*", function () {
    expect(parser.parseCode("<?php\nclass testcase {\n    private $encoding;\n    private $bom;\n    private $prologue;\n    private $tags;\n    private $chunk_size;\n    function __construct($enc, $chunk_size = 0, $bom = 0, $omit_prologue = 0) {\n        $this->encoding = $enc;\n        $this->chunk_size = $chunk_size;\n        $this->bom = $bom;\n        $this->prologue = !$omit_prologue;\n        $this->tags = array();\n    }\n    function start_element($parser, $name, $attrs) {\n        $attrs = array_map('bin2hex', $attrs);\n        $this->tags[] = bin2hex($name).\": \".implode(', ', $attrs);\n    }\n    function end_element($parser, $name) {\n    }\n    function run() {\n        $data = '';\n        if ($this->prologue) {\n            $canonical_name = preg_replace('/BE|LE/i', '', $this->encoding);\n            $data .= \"<?xml version=\\\"1.0\\\" encoding=\\\"$canonical_name\\\" ?>\\n\";\n        }\n        $data .= <<<HERE\n<テスト:テスト1 xmlns:テスト=\"http://www.example.com/テスト/\" テスト=\"テスト\">\n  <テスト:テスト2 テスト=\"テスト\">\n    <テスト:テスト3>\n      test!\n    </テスト:テスト3>\n  </テスト:テスト2>\n</テスト:テスト1>\nHERE;\n        $data = iconv(\"UTF-8\", $this->encoding, $data);\n        if ($this->bom) {\n            switch (strtoupper($this->encoding)) {\n                case 'UTF-8':\n                case 'UTF8':\n                    $data = \"\\xef\\xbb\\xbf\".$data;\n                    break;\n                case 'UTF-16':\n                case 'UTF16':\n                case 'UTF-16BE':\n                case 'UTF16BE':\n                case 'UCS-2':\n                case 'UCS2':\n                case 'UCS-2BE':\n                case 'UCS2BE':\n                    $data = \"\\xfe\\xff\".$data;\n                    break;\n                case 'UTF-16LE':\n                case 'UTF16LE':\n                case 'UCS-2LE':\n                case 'UCS2LE':\n                    $data = \"\\xff\\xfe\".$data;\n                    break;\n                case 'UTF-32':\n                case 'UTF32':\n                case 'UTF-32BE':\n                case 'UTF32BE':\n                case 'UCS-4':\n                case 'UCS4':\n                case 'UCS-4BE':\n                case 'UCS4BE':\n                    $data = \"\\x00\\x00\\xfe\\xff\".$data;\n                    break;\n                case 'UTF-32LE':\n                case 'UTF32LE':\n                case 'UCS-4LE':\n                case 'UCS4LE':\n                    $data = \"\\xff\\xfe\\x00\\x00\".$data;\n                    break;\n            }\n        }\n        $parser = xml_parser_create(NULL);\n        xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);\n        xml_set_element_handler($parser, \"start_element\", \"end_element\");\n        xml_set_object($parser, $this);\n        if ($this->chunk_size == 0) {\n            $success = @xml_parse($parser, $data, true);\n        } else {\n            for ($offset = 0; $offset < strlen($data);\n                    $offset += $this->chunk_size) {\n                $success = @xml_parse($parser, substr($data, $offset, $this->chunk_size), false);\n                if (!$success) {\n                    break;\n                }\n            }\n            if ($success) {\n                $success = @xml_parse($parser, \"\", true);\n            }\n        }\n        echo \"Encoding: $this->encoding\\n\";\n        echo \"XML Prologue: \".($this->prologue ? 'present': 'not present'), \"\\n\";\n        echo \"Chunk size: \".($this->chunk_size ? \"$this->chunk_size byte(s)\\n\": \"all data at once\\n\");\n        echo \"BOM: \".($this->bom ? 'prepended': 'not prepended'), \"\\n\";\n        if ($success) {\n            var_dump($this->tags);\n        } else {\n            echo \"[Error] \", xml_error_string(xml_get_error_code($parser)), \"\\n\";\n        }\n    }\n}\n$suite = array(\n    new testcase(\"UTF-8\",     0, 0, 0),\n    new testcase(\"UTF-8\",     0, 0, 1),\n    new testcase(\"UTF-8\",     0, 1, 0),\n    new testcase(\"UTF-8\",     0, 1, 1),\n    new testcase(\"UTF-16BE\",  0, 0, 0),\n    new testcase(\"UTF-16BE\",  0, 1, 0),\n    new testcase(\"UTF-16BE\",  0, 1, 1),\n    new testcase(\"UTF-16LE\",  0, 0, 0),\n    new testcase(\"UTF-16LE\",  0, 1, 0),\n    new testcase(\"UTF-16LE\",  0, 1, 1),\n    new testcase(\"UTF-8\",     1, 0, 0),\n    new testcase(\"UTF-8\",     1, 0, 1),\n    new testcase(\"UTF-8\",     1, 1, 0),\n    new testcase(\"UTF-8\",     1, 1, 1),\n    new testcase(\"UTF-16BE\",  1, 0, 0),\n    new testcase(\"UTF-16BE\",  1, 1, 0),\n    new testcase(\"UTF-16BE\",  1, 1, 1),\n    new testcase(\"UTF-16LE\",  1, 0, 0),\n    new testcase(\"UTF-16LE\",  1, 1, 0),\n    new testcase(\"UTF-16LE\",  1, 1, 1),\n);\nif (XML_SAX_IMPL == 'libxml') {\n  echo \"libxml2 Version => \" . LIBXML_DOTTED_VERSION. \"\\n\";\n} else {\n  echo \"libxml2 Version => NONE\\n\";\n}\nforeach ($suite as $testcase) {\n    $testcase->run();\n}\n?>")).toMatchSnapshot();
  });
});
