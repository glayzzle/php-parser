// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // tests/lang/bug20175.phpt
  it("Bug #20175 (Static vars can't store ref to new instance)", function () {
    expect(parser.parseCode("<?php\nprint zend_version().\"\\n\";\n/* Part 1:\n * Storing the result of a function in a static variable.\n * foo_global() increments global variable $foo_count whenever it is executed.\n * When foo_static() is called it checks for the static variable $foo_value\n * being initialized. In case initialisation is necessary foo_global() will be\n * called. Since that must happen only once the return value should be equal.\n */\n$foo_count = 0;\nfunction foo_global() {\n    global $foo_count;\n    echo \"foo_global()\\n\";\n    return 'foo:' . ++$foo_count;\n}\nfunction foo_static() {\n    static $foo_value;\n    echo \"foo_static()\\n\";\n    if (!isset($foo_value)) {\n        $foo_value = foo_global();\n    }\n    return $foo_value;\n}\n/* Part 2:\n * Storing a reference to the result of a function in a static variable.\n * Same as Part 1 but:\n * The return statement transports a copy of the value to return. In other\n * words the return value of bar_global() is a temporary variable only valid\n * after the function call bar_global() is done in current local scope.\n */\n$bar_count = 0;\nfunction bar_global() {\n    global $bar_count;\n    echo \"bar_global()\\n\";\n    return 'bar:' . ++$bar_count;\n}\nfunction bar_static() {\n    static $bar_value;\n    echo \"bar_static()\\n\";\n    if (!isset($bar_value)) {\n        $bar_value = &bar_global();\n    }\n    return $bar_value;\n}\n/* Part 3: TO BE DISCUSSED\n *\n * Storing a reference to the result of a function in a static variable.\n * Same as Part 2 but wow_global() returns a reference so $wow_value\n * should store a reference to $wow_global. Therefore $wow_value is already\n * initialized in second call to wow_static() and hence shouldn't call\n * wow_global() again.\n */ /*\n$wow_count = 0;\n$wow_name = '';\nfunction &wow_global() {\n    global $wow_count, $wow_name;\n    echo \"wow_global()\\n\";\n    $wow_name = 'wow:' . ++$wow_count;\n    return $wow_name;\n}\nfunction wow_static() {\n    static $wow_value;\n    echo \"wow_static()\\n\";\n    if (!isset($wow_value)) {\n        $wow_value = &wow_global();\n    }\n    return $wow_value;\n}*/\n/* Part 4:\n * Storing a reference to a new instance (that's where the name of the  test\n * comes from). First there is the global counter $oop_global again which\n * counts the calls to the constructor of oop_class and hence counts the\n * creation of oop_class instances.\n * The class oop_test uses a static reference to a oop_class instance.\n * When another oop_test instance is created it must reuse the statically\n * stored reference oop_value. This way oop_class gets some singleton behavior\n * since it will be created only once for all instances of oop_test.\n */\n$oop_global = 0;\nclass oop_class {\n    var $oop_name;\n    function __construct() {\n        global $oop_global;\n        echo \"oop_class()\\n\";\n        $this->oop_name = 'oop:' . ++$oop_global;\n    }\n}\nclass oop_test {\n    static $oop_value;\n    function __construct() {\n        echo \"oop_test()\\n\";\n    }\n    function oop_static() {\n        echo \"oop_static()\\n\";\n        if (!isset(self::$oop_value)) {\n            self::$oop_value = new oop_class;\n        }\n        echo self::$oop_value->oop_name;\n    }\n}\nprint foo_static().\"\\n\";\nprint foo_static().\"\\n\";\nprint bar_static().\"\\n\";\nprint bar_static().\"\\n\";\n//print wow_static().\"\\n\";\n//print wow_static().\"\\n\";\necho \"wow_static()\nwow_global()\nwow:1\nwow_static()\nwow:1\n\";\n$oop_tester = new oop_test;\nprint $oop_tester->oop_static().\"\\n\";\nprint $oop_tester->oop_static().\"\\n\";\n$oop_tester = new oop_test; // repeated.\nprint $oop_tester->oop_static().\"\\n\";\n?>")).toMatchSnapshot();
  });
});
