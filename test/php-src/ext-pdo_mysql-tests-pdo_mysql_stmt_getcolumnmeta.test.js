// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_mysql/tests/pdo_mysql_stmt_getcolumnmeta.phpt
  it("MySQL: PDOStatement->getColumnMeta()", function () {
    expect(parser.parseCode("<?php\nrequire_once(__DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');\n$db = MySQLPDOTest::factory();\n$db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);\nMySQLPDOTest::createTestTable($db);\ntry {\n    $stmt = $db->prepare('SELECT id FROM test ORDER BY id ASC');\n    // execute() has not been called yet\n    // NOTE: no warning\n    if (false !== ($tmp = $stmt->getColumnMeta(0)))\n        printf(\"[002] Expecting false got %s\\n\", var_export($tmp, true));\n    $stmt->execute();\n    // invalid offset\n    try {\n        $stmt->getColumnMeta(-1);\n    } catch (\\ValueError $e) {\n        echo $e->getMessage(), \\PHP_EOL;\n    }\n    $emulated =  $stmt->getColumnMeta(0);\n    printf(\"Testing native PS...\\n\");\n    $db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);\n        if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))\n            printf(\"[007] Unable to turn off emulated prepared statements\\n\");\n    $stmt = $db->prepare('SELECT id FROM test ORDER BY id ASC');\n    $stmt->execute();\n    $native = $stmt->getColumnMeta(0);\n    if (count($native) == 0) {\n        printf(\"[008] Meta data seems wrong, %s / %s\\n\",\n            var_export($native, true), var_export($emulated, true));\n    }\n    // invalid offset\n    if (false !== ($tmp = $stmt->getColumnMeta(1)))\n        printf(\"[009] Expecting false because of invalid offset got %s\\n\", var_export($tmp, true));\n    function test_meta(&$db, $offset, $sql_type, $value, $native_type, $pdo_type) {\n        $db->exec('DROP TABLE IF EXISTS test');\n        $sql = sprintf('CREATE TABLE test(id INT, label %s) ENGINE=%s', $sql_type, MySQLPDOTest::getTableEngine());\n        if (!($stmt = @$db->prepare($sql)) || (!@$stmt->execute())) {\n            // Some engines and/or MySQL server versions might not support the data type\n            return true;\n        }\n        if (!$db->exec(sprintf(\"INSERT INTO test(id, label) VALUES (1, '%s')\", $value))) {\n            printf(\"[%03d] + 1] Insert failed, %d - %s\\n\", $offset,\n                $db->errorCode(), var_export($db->errorInfo(), true));\n            return false;\n        }\n        $stmt = $db->prepare('SELECT id, label FROM test');\n        $stmt->execute();\n        $meta = $stmt->getColumnMeta(1);\n        $row = $stmt->fetch(PDO::FETCH_ASSOC);\n        if (empty($meta)) {\n            printf(\"[%03d + 2] getColumnMeta() failed, %d - %s\\n\", $offset,\n                $stmt->errorCode(), var_export($stmt->errorInfo(), true));\n            return false;\n        }\n        $elements = array('flags', 'table', 'name', 'len', 'precision', 'pdo_type');\n        foreach ($elements as $k => $element)\n            if (!isset($meta[$element])) {\n                printf(\"[%03d + 3] Element %s missing, %s\\n\", $offset,\n                    $element, var_export($meta, true));\n                return false;\n            }\n        if (($meta['table'] != 'test') || ($meta['name'] != 'label')) {\n            printf(\"[%03d + 4] Table or field name is wrong, %s\\n\", $offset,\n                var_export($meta, true));\n            return false;\n        }\n        if (!is_null($native_type)) {\n            if (!isset($meta['native_type'])) {\n                printf(\"[%03d + 5] Element native_type missing, %s\\n\", $offset,\n                    var_export($meta, true));\n                return false;\n            }\n            if (!is_array($native_type))\n                $native_type = array($native_type);\n            $found = false;\n            foreach ($native_type as $k => $type) {\n                if ($meta['native_type'] == $type) {\n                    $found = true;\n                    break;\n                }\n            }\n            if (!$found) {\n                printf(\"[%03d + 6] Expecting native type %s, %s\\n\", $offset,\n                    var_export($native_type, true), var_export($meta, true));\n                return false;\n            }\n        }\n        if (!is_null($pdo_type) && ($meta['pdo_type'] != $pdo_type)) {\n            printf(\"[%03d + 6] Expecting PDO type %s got %s (%s)\\n\", $offset,\n                $pdo_type, var_export($meta, true), var_export($meta['native_type']));\n            return false;\n        }\n        return true;\n    }\n    $stmt = $db->prepare('SELECT @@sql_mode AS _mode');\n    $stmt->execute();\n    $row = $stmt->fetch(PDO::FETCH_ASSOC);\n    $real_as_float = (false === stristr($row['_mode'], \"REAL_AS_FLOAT\")) ? false : true;\n    $db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, false);\n    test_meta($db, 20, 'BIT(8)', 1, 'BIT', PDO::PARAM_INT);\n    test_meta($db, 30, 'TINYINT', -127, 'TINY', PDO::PARAM_INT);\n    test_meta($db, 40, 'TINYINT UNSIGNED', 255, 'TINY', PDO::PARAM_INT);\n    test_meta($db, 50, 'BOOLEAN', 1, NULL, PDO::PARAM_INT);\n    test_meta($db, 60, 'SMALLINT', -32768, 'SHORT', PDO::PARAM_INT);\n    test_meta($db, 70, 'SMALLINT UNSIGNED', 65535, 'SHORT', PDO::PARAM_INT);\n    test_meta($db, 80, 'MEDIUMINT', -8388608, 'INT24', PDO::PARAM_INT);\n    test_meta($db, 90, 'MEDIUMINT UNSIGNED', 16777215, 'INT24', PDO::PARAM_INT);\n    test_meta($db, 100, 'INT', -2147483648, 'LONG', PDO::PARAM_INT);\n    test_meta($db, 110, 'INT UNSIGNED', 4294967295, 'LONG', PDO::PARAM_INT);\n    test_meta($db, 120, 'BIGINT', '-9223372036854775808', 'LONGLONG', (PHP_INT_SIZE == 4) ? PDO::PARAM_STR : PDO::PARAM_INT);\n    test_meta($db, 130, 'BIGINT UNSIGNED', '18446744073709551615', 'LONGLONG', (PHP_INT_SIZE == 4) ? PDO::PARAM_STR : PDO::PARAM_INT);\n    test_meta($db, 130, 'REAL', -1.01, ($real_as_float) ? 'FLOAT' : 'DOUBLE', PDO::PARAM_STR);\n    test_meta($db, 140, 'REAL UNSIGNED', 1.01, ($real_as_float) ? 'FLOAT' : 'DOUBLE', PDO::PARAM_STR);\n    test_meta($db, 150, 'REAL ZEROFILL', 1.01, ($real_as_float) ? 'FLOAT' : 'DOUBLE', PDO::PARAM_STR);\n    test_meta($db, 160, 'REAL UNSIGNED ZEROFILL', 1.01, ($real_as_float) ? 'FLOAT' : 'DOUBLE', PDO::PARAM_STR);\n    test_meta($db, 170, 'DOUBLE', -1.01, 'DOUBLE', PDO::PARAM_STR);\n    test_meta($db, 180, 'DOUBLE UNSIGNED', 1.01, 'DOUBLE', PDO::PARAM_STR);\n    test_meta($db, 190, 'DOUBLE ZEROFILL', 1.01, 'DOUBLE', PDO::PARAM_STR);\n    test_meta($db, 200, 'DOUBLE UNSIGNED ZEROFILL', 1.01, 'DOUBLE', PDO::PARAM_STR);\n    test_meta($db, 210, 'FLOAT', -1.01, 'FLOAT', PDO::PARAM_STR);\n    test_meta($db, 220, 'FLOAT UNSIGNED', 1.01, 'FLOAT', PDO::PARAM_STR);\n    test_meta($db, 230, 'FLOAT ZEROFILL', 1.01, 'FLOAT', PDO::PARAM_STR);\n    test_meta($db, 240, 'FLOAT UNSIGNED ZEROFILL', 1.01, 'FLOAT', PDO::PARAM_STR);\n    test_meta($db, 250, 'DECIMAL', -1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);\n    test_meta($db, 260, 'DECIMAL UNSIGNED', 1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);\n    test_meta($db, 270, 'DECIMAL ZEROFILL', 1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);\n    test_meta($db, 280, 'DECIMAL UNSIGNED ZEROFILL', 1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);\n    test_meta($db, 290, 'NUMERIC', -1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);\n    test_meta($db, 300, 'NUMERIC UNSIGNED', 1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);\n    test_meta($db, 310, 'NUMERIC ZEROFILL', 1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);\n    test_meta($db, 320, 'NUMERIC UNSIGNED ZEROFILL', 1.01, array('DECIMAL', 'NEWDECIMAL'), PDO::PARAM_STR);\n    test_meta($db, 330, 'DATE', '2008-04-23', array('DATE', 'NEWDATE'), PDO::PARAM_STR);\n    test_meta($db, 340, 'TIME', '14:37:00', 'TIME', PDO::PARAM_STR);\n    test_meta($db, 350, 'TIMESTAMP', '2008-03-23 14:38:00', 'TIMESTAMP', PDO::PARAM_STR);\n    test_meta($db, 360, 'DATETIME', '2008-03-23 14:38:00', 'DATETIME', PDO::PARAM_STR);\n    test_meta($db, 370, 'YEAR', '2008', 'YEAR', PDO::PARAM_INT);\n    test_meta($db, 380, 'CHAR(1)', 'a', 'STRING', PDO::PARAM_STR);\n    test_meta($db, 390, 'CHAR(10)', '0123456789', 'STRING', PDO::PARAM_STR);\n    test_meta($db, 400, 'CHAR(255)', str_repeat('z', 255), 'STRING', PDO::PARAM_STR);\n    test_meta($db, 410, 'VARCHAR(1)', 'a', 'VAR_STRING', PDO::PARAM_STR);\n    test_meta($db, 420, 'VARCHAR(10)', '0123456789', 'VAR_STRING', PDO::PARAM_STR);\n    test_meta($db, 430, 'VARCHAR(255)', str_repeat('z', 255), 'VAR_STRING', PDO::PARAM_STR);\n    test_meta($db, 440, 'BINARY(1)', str_repeat('a', 1), 'STRING', PDO::PARAM_STR);\n    test_meta($db, 450, 'BINARY(255)', str_repeat('b', 255), 'STRING', PDO::PARAM_STR);\n    test_meta($db, 460, 'VARBINARY(1)', str_repeat('a', 1), 'VAR_STRING', PDO::PARAM_STR);\n    test_meta($db, 470, 'VARBINARY(255)', str_repeat('b', 255), 'VAR_STRING', PDO::PARAM_STR);\n    test_meta($db, 480, 'TINYBLOB', str_repeat('b', 255), 'BLOB', PDO::PARAM_STR);\n    test_meta($db, 490, 'BLOB', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);\n    test_meta($db, 500, 'MEDIUMBLOB', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);\n    test_meta($db, 510, 'LONGBLOB', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);\n    test_meta($db, 520, 'TINYTEXT', str_repeat('b', 255), 'BLOB', PDO::PARAM_STR);\n    test_meta($db, 530, 'TINYTEXT BINARY', str_repeat('b', 255), 'BLOB', PDO::PARAM_STR);\n    test_meta($db, 560, 'TEXT', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);\n    test_meta($db, 570, 'TEXT BINARY', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);\n    test_meta($db, 580, 'MEDIUMTEXT', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);\n    test_meta($db, 590, 'MEDIUMTEXT BINARY', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);\n    test_meta($db, 600, 'LONGTEXT', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);\n    test_meta($db, 610, 'LONGTEXT BINARY', str_repeat('b', 256), 'BLOB', PDO::PARAM_STR);\n    test_meta($db, 620, \"ENUM('yes', 'no') DEFAULT 'yes'\", 'no', NULL, PDO::PARAM_STR);\n    test_meta($db, 630, \"SET('yes', 'no') DEFAULT 'yes'\", 'no', NULL, PDO::PARAM_STR);\n/*\n  | spatial_type\n*/\n    // unique key\n    $db->exec('DROP TABLE IF EXISTS test');\n    $sql = sprintf('CREATE TABLE test(id INT, label INT UNIQUE) ENGINE = %s', MySQLPDOTest::getTableEngine());\n    if (($stmt = @$db->prepare($sql)) && @$stmt->execute()) {\n        $db->exec('INSERT INTO test(id, label) VALUES (1, 2)');\n        $stmt = $db->query('SELECT id, label FROM test');\n        $meta = $stmt->getColumnMeta(1);\n        if (!isset($meta['flags'])) {\n            printf(\"[1000] No flags contained in metadata %s\\n\", var_export($meta, true));\n        } else {\n            $flags = $meta['flags'];\n            $found = false;\n            foreach ($flags as $k => $flag) {\n                if ($flag == 'unique_key')\n                    $found = true;\n            }\n            if (!$found)\n                printf(\"[1001] Flags seem wrong %s\\n\", var_export($meta, true));\n        }\n    }\n    // primary key\n    $db->exec('DROP TABLE IF EXISTS test');\n    $sql = sprintf('CREATE TABLE test(id INT PRIMARY KEY NOT NULL AUTO_INCREMENT) ENGINE = %s', MySQLPDOTest::getTableEngine());\n    if (($stmt = @$db->prepare($sql)) && @$stmt->execute()) {\n        $db->exec('INSERT INTO test(id) VALUES (1)');\n        $stmt = $db->query('SELECT id FROM test');\n        $meta = $stmt->getColumnMeta(0);\n        if (!isset($meta['flags'])) {\n            printf(\"[1002] No flags contained in metadata %s\\n\", var_export($meta, true));\n        } else {\n            $flags = $meta['flags'];\n            $found = false;\n            foreach ($flags as $k => $flag) {\n                if ($flag == 'primary_key')\n                    $found = true;\n            }\n            if (!$found)\n                printf(\"[1003] Flags seem wrong %s\\n\", var_export($meta, true));\n        }\n    }\n    // multiple key\n    $db->exec('DROP TABLE IF EXISTS test');\n    $sql = sprintf('CREATE TABLE test(id INT, label1 INT, label2 INT, INDEX idx1(label1, label2)) ENGINE = %s', MySQLPDOTest::getTableEngine());\n    if (($stmt = @$db->prepare($sql)) && @$stmt->execute()) {\n        $db->exec('INSERT INTO test(id, label1, label2) VALUES (1, 2, 3)');\n        $stmt = $db->query('SELECT id, label1, label2 FROM test');\n        $meta = $stmt->getColumnMeta(1);\n        if (!isset($meta['flags'])) {\n            printf(\"[1004] No flags contained in metadata %s\\n\", var_export($meta, true));\n        } else {\n            $flags = $meta['flags'];\n            $found = false;\n            foreach ($flags as $k => $flag) {\n                if ($flag == 'multiple_key')\n                    $found = true;\n            }\n            if (!$found)\n                printf(\"[1005] Flags seem wrong %s\\n\", var_export($meta, true));\n        }\n    }\n    $stmt = $db->query('SELECT NULL AS col1');\n    $meta = $stmt->getColumnMeta(0);\n    if ('NULL' !== $meta['native_type'])\n        printf(\"[1006] Expecting NULL got %s\\n\", $meta['native_type']);\n} catch (PDOException $e) {\n    // we should never get here, we use warnings, but never trust a system...\n    printf(\"[001] %s, [%s} %s\\n\",\n        $e->getMessage(), $db->errorInfo(), implode(' ', $db->errorInfo()));\n}\n$db->exec('DROP TABLE IF EXISTS test');\nprint \"done!\";\n?>")).toMatchSnapshot();
  });
});
