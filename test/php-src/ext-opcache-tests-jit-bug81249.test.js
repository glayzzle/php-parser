// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/opcache/tests/jit/bug81249.phpt
  it("Bug #81249: Intermittent property assignment failure with JIT enabled", function () {
    expect(parser.parseCode("<?php\ndeclare(strict_types=1);\nfinal class EucJpDecoder\n{\n    private const JIS0212_INDEX = [108 => 728];\n    private const JIS0208_INDEX = [];\n    private const CONTINUE = -1;\n    private const FINISHED = -2;\n    private const ERROR = -3;\n    /**\n     * @var int\n     */\n    private $lead;\n    /**\n     * @var bool\n     */\n    private $isJis0212;\n    public function __construct()\n    {\n        $this->lead = 0x00;\n        $this->isJis0212 = false;\n    }\n    public function handle(array &$ioQueue, string $byte): int\n    {\n        if ($byte === '') {\n            if ($this->lead !== 0x00) {\n                $this->lead = 0x00;\n                return self::ERROR;\n            }\n            return self::FINISHED;\n        }\n        $byte = ord($byte);\n        if ($this->lead === 0x8E && ($byte >= 0xA1 && $byte <= 0xDF)) {\n            $this->lead = 0x00;\n            return 0xFF61 - 0xA1 + $byte;\n        }\n        if ($this->lead === 0x8F && ($byte >= 0xA1 && $byte <= 0xFE)) {\n            $this->isJis0212 = true;\n            $this->lead = $byte;\n            return self::CONTINUE;\n        }\n        if ($this->lead !== 0x00) {\n            $lead = $this->lead;\n            $this->lead = 0x00;\n            $codePoint = null;\n            if (($lead >= 0xA1 && $lead <= 0xFE) && ($byte >= 0xA1 && $byte <= 0xFE)) {\n                $index = self::JIS0208_INDEX;\n                if ($this->isJis0212) {\n                    $index = self::JIS0212_INDEX;\n                }\n                $codePoint = $index[($lead - 0xA1) * 94 + $byte - 0xA1] ?? null;\n            }\n            $this->isJis0212 = false;\n            if ($codePoint !== null) {\n                return $codePoint;\n            }\n            if ($byte <= 0x7F) {\n                array_unshift($ioQueue, chr($byte));\n            }\n            return self::ERROR;\n        }\n        if ($byte <= 0x7F) {\n            return $byte;\n        }\n        if ($byte === 0x8E || $byte === 0x8F || ($byte >= 0xA1 && $byte <= 0xFE)) {\n            $this->lead = $byte;\n            return self::CONTINUE;\n        }\n        return self::ERROR;\n    }\n}\nfor ($i = 0; $i < 2000; ++$i) {\n    $decoder = new EucJpDecoder();\n    $bytes = [\"\\x8F\", \"\\xA2\", \"\\xAF\", ''];\n    $out = null;\n    foreach ($bytes as $byte) {\n        $result = $decoder->handle($bytes, $byte);\n        if ($result >= 0) {\n            $out = $result;\n        }\n    }\n    // $bytes array should be decoded to U+2D8, decimal 728\n    assert($out === 728);\n}\n?>\nOK")).toMatchSnapshot();
  });
});
