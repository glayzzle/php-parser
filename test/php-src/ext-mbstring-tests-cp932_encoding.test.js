// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/cp932_encoding.phpt
  it("Exhaustive test of CP932 encoding verification and conversion", function () {
    expect(parser.parseCode("<?php\nsrand(4321); /* Make results consistent */\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\n/* Read in the table of all characters in CP932 */\nreadConversionTable(__DIR__ . '/data/CP932.txt', $validChars, $fromUnicode);\n/* Aside from the characters in that table, we also support a 'user' area\n * from 0xF040-0xF9FC, which map to Unicode 'private' codepoints 0xE000-E757 */\n$codepoint = 0xE000;\nfor ($i = 0xF0; $i <= 0xF9; $i++) {\n\tfor ($j = 0x40; $j <= 0xFC; $j++) {\n\t\tif ($j == 0x7F)\n\t\t\tcontinue;\n\t\t$utf16 = pack('n', $codepoint);\n\t\t$cp932 = chr($i) . chr($j);\n\t\t$validChars[$cp932] = $utf16;\n\t\t$fromUnicode[$utf16] = $cp932;\n\t\t$codepoint++;\n\t}\n}\n/* U+00A2 is CENT SIGN; convert to FULLWIDTH CENT SIGN */\n$fromUnicode[\"\\x00\\xA2\"] = \"\\x81\\x91\";\n/* U+00A3 is POUND SIGN; convert to FULLWIDTH POUND SIGN */\n$fromUnicode[\"\\x00\\xA3\"] = \"\\x81\\x92\";\n/* U+00A5 is YEN SIGN; convert to FULLWIDTH YEN SIGN */\n$fromUnicode[\"\\x00\\xA5\"] = \"\\x81\\x8F\";\n/* We map the JIS X 0208 FULLWIDTH TILDE to U+FF5E (FULLWIDTH TILDE)\n * But when converting Unicode to CP932, we also accept U+301C (WAVE DASH) */\n$fromUnicode[\"\\x30\\x1C\"] = \"\\x81\\x60\";\n/* We map the JIS X 0208 MINUS SIGN to U+FF0D (FULLWIDTH HYPHEN-MINUS SIGN),\n * but when converting Unicode to CP932, we also accept U+2212 (MINUS SIGN) */\n$fromUnicode[\"\\x22\\x12\"] = \"\\x81\\x7C\";\n/* We map the JIS X 0208 PARALLEL TO symbol to U+2225 (PARALLEL TO),\n * but when converting Unicode to CP932, we also accept U+2016\n * (DOUBLE VERTICAL LINE) */\n$fromUnicode[\"\\x20\\x16\"] = \"\\x81\\x61\";\n/* We map the JIS X 0208 NOT SIGN to U+FFE2 (FULLWIDTH NOT SIGN),\n * but when converting Unicode to CP932, we also accept U+00AC (NOT SIGN) */\n$fromUnicode[\"\\x00\\xAC\"] = \"\\x81\\xCA\";\n/* U+203E is OVERLINE; convert to JIS X 0208 FULLWIDTH MACRON */\n$fromUnicode[\"\\x20\\x3E\"] = \"\\x81\\x50\";\n/* U+00AF is MACRON; it can also go to FULLWIDTH MACRON */\n$fromUnicode[\"\\x00\\xAF\"] = \"\\x81\\x50\";\nfindInvalidChars($validChars, $invalidChars, $truncated, array_fill_keys(range(0x81, 0x9F), 2) + array_fill_keys(range(0xE0, 0xFC), 2));\nfindInvalidChars($fromUnicode, $invalidCodepoints, $unused, array_fill_keys(range(0, 0xFF), 2));\n/* There are 396 Unicode codepoints which are non-invertible in CP932\n * (multiple CP932 byte sequences map to the same codepoint)\n * Some of these are 3-way pile-ups. I wonder what the fine folks at MS\n * were thinking when they designed this text encoding. */\n/* Everything from 0xED00-0xEEFF falls in this unfortunate category\n * (Other sequences in 0xFA00-0xFBFF map to the same codepoints, and when\n * converting from Unicode back to CP932, we favor the F's rather than the E's) */\n$nonInvertible = array();\nfor ($i = 0xED00; $i <= 0xEEFF; $i++) {\n\t$bytes = pack('n', $i);\n\tif (isset($validChars[$bytes])) {\n\t\tunset($fromUnicode[$validChars[$bytes]]);\n\t\t$nonInvertible[$bytes] = $validChars[$bytes];\n\t\tunset($validChars[$bytes]); // will test these separately\n\t}\n}\n/* There are 23 other collisions between 2-byte sequences which variously\n * start with 0x81, 0x87, or 0xFA\n * We _love_ 0x81 and use it when possible. 0x87 is a second favorite */\nfor ($i = 0xFA4A; $i <= 0xFA53; $i++) {\n\t$bytes = pack('n', $i);\n\tunset($fromUnicode[$validChars[$bytes]]);\n\t$nonInvertible[$bytes] = $validChars[$bytes];\n\tunset($validChars[$bytes]); // will test these separately\n}\nforeach ([0x8790, 0x8791, 0x8792, 0x8795, 0x8796, 0x8797, 0x879A, 0x879B, 0x879C, 0xFA54, 0xFA58, 0xFA59, 0xFA5A, 0xFA5B] as $i) {\n\t$bytes = pack('n', $i);\n\tunset($fromUnicode[$validChars[$bytes]]);\n\t$nonInvertible[$bytes] = $validChars[$bytes];\n\tunset($validChars[$bytes]); // will test these separately\n}\ntestAllValidChars($validChars, 'CP932', 'UTF-16BE');\nforeach ($nonInvertible as $cp932 => $unicode)\n\ttestValidString($cp932, $unicode, 'CP932', 'UTF-16BE', false);\necho \"CP932 verification and conversion works on all valid characters\\n\";\ntestAllInvalidChars($invalidChars, $validChars, 'CP932', 'UTF-16BE', \"\\x00%\");\necho \"CP932 verification and conversion works on all invalid characters\\n\";\nconvertAllInvalidChars($invalidCodepoints, $fromUnicode, 'UTF-16BE', 'CP932', '%');\necho \"Unicode -> CP932 conversion works on all invalid codepoints\\n\";\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\x80\", \"%\", \"CP932\", \"UTF-8\");\nconvertInvalidString(\"\\xEA\", \"%\", \"CP932\", \"UTF-8\");\nconvertInvalidString(\"\\x81\\x20\", \"%\", \"CP932\", \"UTF-8\");\nconvertInvalidString(\"\\xEA\\xA9\", \"%\", \"CP932\", \"UTF-8\");\necho \"Done!\\n\";\n?>")).toMatchSnapshot();
  });
});
