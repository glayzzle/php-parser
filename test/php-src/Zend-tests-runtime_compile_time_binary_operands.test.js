// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // Zend/tests/runtime_compile_time_binary_operands.phpt
  it("Test binary operands exposing the same behavior at compile as at run time", function () {
    expect(parser.parseCode("<?php\n$binaryOperators = [\n    \"==\",\n    \"!=\",\n    \"===\",\n    \"!==\",\n    \"<\",\n    \"<=\",\n    \">\",\n    \">=\",\n    \"<=>\",\n    \"+\",\n    \"-\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"**\",\n    \".\",\n    \"|\",\n    \"&\",\n    \"^\",\n    \"or\",\n    \"and\",\n    \"xor\",\n    \"||\",\n    \"&&\",\n];\n$unaryOperators = [\n    \"~\",\n    \"-\",\n    \"+\",\n    \"!\",\n];\n$input = [\n    0,\n    1,\n    2,\n    -1,\n    2.0,\n    2.1,\n    -2.0,\n    -2.1,\n    PHP_INT_MAX,\n    PHP_INT_MIN,\n    PHP_INT_MAX * 2,\n    PHP_INT_MIN * 2,\n    INF,\n    NAN,\n    [],\n    [1, 2],\n    [1, 2, 3],\n    [1 => 2, 0 => 1],\n    [1, 'a' => 2],\n    [1, 4],\n    [1, 'a'],\n    [1, 2 => 2],\n    [1, [ 2 ]],\n    null,\n    false,\n    true,\n    \"\",\n    \" \",\n    \"banana\",\n    \"Banana\",\n    \"banan\",\n    \"0\",\n    \"200\",\n    \"20\",\n    \"20a\",\n    \" \\t\\n\\r\\v\\f20\",\n    \"20  \",\n    \"2e1\",\n    \"2e150\",\n    \"9179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368\",\n    \"-9179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368\",\n    \"0.1\",\n    \"-0.1\",\n    \"1e-1\",\n    \"-20\",\n    \"-20.0\",\n    \"0x14\",\n    (string) PHP_INT_MAX * 2,\n    (string) PHP_INT_MIN * 2,\n];\nfunction makeParam($param) {\n    if ($param === PHP_INT_MIN) {\n        return \"PHP_INT_MIN\";\n    }\n    if ($param === PHP_INT_MAX) {\n        return \"PHP_INT_MAX\";\n    }\n    if (is_string($param)) {\n        return '\"' . strtr($param, [\"\\t\" => '\\t', \"\\n\" => '\\n', \"\\r\" => '\\r', \"\\v\" => '\\v', \"\\f\" => '\\f', '$' => '\\$', '\"' => '\\\"']) . '\"';\n    }\n    return \"(\" . str_replace(\"\\n\", \"\", var_export($param, true)) . \")\";\n}\n$c = 0;\n$f = 0;\nfunction prepareBinaryLine($op1, $op2, $cmp, $operator) {\n    $op1_p = makeParam($op1);\n    $op2_p = makeParam($op2);\n    $error = \"echo '\" . addcslashes(\"$op1_p $operator $op2_p\", \"\\\\'\") . '\\', \"\\n\"; $f++;';\n    $compare = \"@($op1_p $operator $op2_p)\";\n    $line = \"\\$c++; \";\n    try {\n        $result = makeParam($cmp());\n        $line .= \"if (\" . ($result === \"(NAN)\" ? \"!is_nan($compare)\" : \"$compare !== $result\") . \") { $error }\";\n    } catch (Error $e) {\n        $msg = makeParam($e->getMessage());\n        $line .= \"try { $compare; $error } catch (Error \\$e) { if (\\$e->getMessage() !== $msg) { $error } }\";\n    }\n    return $line;\n}\nfunction prepareUnaryLine($op, $cmp, $operator) {\n    $op_p = makeParam($op);\n    $error = \"echo '\" . addcslashes(\"$operator $op_p\", \"\\\\'\") . '\\', \"\\n\"; $f++;';\n    $compare = \"@($operator $op_p)\";\n    $line = \"\\$c++; \";\n    try {\n        $result = makeParam($cmp());\n        $line .= \"if (\" . ($result === \"(NAN)\" ? \"!is_nan($compare)\" : \"$compare !== $result\") . \") { $error }\";\n    } catch (Error $e) {\n        $msg = makeParam($e->getMessage());\n        $line .= \"try { $compare; $error } catch (Error \\$e) { if (\\$e->getMessage() !== $msg) { $error } }\";\n    }\n    return $line;\n}\n$filename = __DIR__ . DIRECTORY_SEPARATOR . 'compare_binary_operands_temp.php';\n$file = fopen($filename, \"w\");\nfwrite($file, \"<?php\\n\");\nforeach ($input as $left) {\n    foreach ($input as $right) {\n        foreach ($binaryOperators as $operator) {\n            $line = prepareBinaryLine($left, $right, function() use ($left, $right, $operator) {\n                return eval(\"return @(\\$left $operator \\$right);\");\n            }, $operator);\n            fwrite($file, $line . \"\\n\");\n        }\n    }\n}\nforeach ($input as $right) {\n    foreach ($unaryOperators as $operator) {\n        $line = prepareUnaryLine($right, function() use ($right, $operator) {\n            return eval(\"return @($operator \\$right);\");\n        }, $operator);\n        fwrite($file, $line . \"\\n\");\n    }\n}\nfclose($file);\ninclude $filename;\nif($c === 0) {\n    echo \"Completely failed\\n\";\n} else {\n    echo \"Failed: $f\\n\";\n}\n?>")).toMatchSnapshot();
  });
});
