// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_mysql/tests/pdo_mysql_stmt_fetch_serialize.phpt
  it("MySQL PDOStatement->fetch(), PDO::FETCH_SERIALIZE", function () {
    expect(parser.parseCode("<?php\n    require_once(__DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');\n    $db = MySQLPDOTest::factory();\n    try {\n        class myclass implements Serializable {\n            private static $instance = null;\n            protected $myprotected = 'a protected property';\n            // Good old magic stuff\n            private function __construct($caller = NULL) {\n                printf(\"%s(%s)\\n\", __METHOD__, $caller);\n            }\n            public function __destruct() {\n                // printf(\"%s()\\n\", __METHOD__);\n            }\n            public function __sleep() {\n                printf(\"%s()\\n\", __METHOD__);\n            }\n            public function __wakeup() {\n                printf(\"%s()\\n\", __METHOD__);\n            }\n            public function __call($method, $params) {\n                printf(\"%s(%s, %s)\\n\", __METHOD__, $method, var_export($params, true));\n            }\n            public function __set($prop, $value) {\n                printf(\"%s(%s, %s)\\n\", __METHOD__, $prop, var_export($value, true));\n                $this->{$prop} = $value;\n            }\n            public function __get($prop) {\n                printf(\"%s(%s)\\n\", __METHOD__, $prop);\n                return NULL;\n            }\n            // Singleton\n            public static function singleton($caller) {\n                printf(\"%s(%s)\\n\", __METHOD__, $caller);\n                if (!self::$instance) {\n                    $c = __CLASS__;\n                    self::$instance = new $c($caller);\n                }\n                return self::$instance;\n            }\n            // Serializable\n            public function serialize() {\n                printf(\"%s()\\n\", __METHOD__);\n                return 'Data from serialize';\n            }\n            public function unserialize($data) {\n                printf(\"%s(%s)\\n\", __METHOD__, var_export($data, true));\n            }\n        }\n        $db->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);\n        if (0 != $db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))\n            printf(\"[002] Unable to turn off emulated prepared statements\\n\");\n        $db->exec('DROP TABLE IF EXISTS test');\n        $db->exec(sprintf('CREATE TABLE test(id INT, myobj BLOB) ENGINE=%s',\n            MySQLPDOTest::getTableEngine()));\n        printf(\"Creating an object, serializing it and writing it to DB...\\n\");\n        $id = 1;\n        $obj = myclass::singleton('Creating object');\n        $myobj = serialize($obj);\n        $stmt = $db->prepare('INSERT INTO test(id, myobj) VALUES (?, ?)');\n        $stmt->bindValue(1, $id);\n        $stmt->bindValue(2, $myobj);\n        $stmt->execute();\n        printf(\"\\nUnserializing the previously serialized object...\\n\");\n        var_dump(unserialize($myobj));\n        printf(\"\\nUsing PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE to fetch the object from DB and unserialize it...\\n\");\n        $stmt = $db->prepare('SELECT myobj FROM test');\n        $stmt->setFetchMode(PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE, 'myclass', array('PDO shall not call __construct()'));\n        $stmt->execute();\n        var_dump($stmt->fetch());\n        printf(\"\\nUsing PDO::FETCH_CLASS to fetch the object from DB and unserialize it...\\n\");\n        $stmt = $db->prepare('SELECT myobj FROM test');\n        $stmt->setFetchMode(PDO::FETCH_CLASS, 'myclass', array('PDO shall call __construct()'));\n        $stmt->execute();\n        var_dump($stmt->fetch());\n    } catch (PDOException $e) {\n        printf(\"[001] %s [%s] %s\\n\",\n            $e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));\n    }\n    print \"done!\\n\";\n?>")).toMatchSnapshot();
  });
});
