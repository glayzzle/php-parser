// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/iso2022kr_encoding.phpt
  it("Test of ASCII and KS X 1001-1992 support in ISO-2022-KR encoding", function () {
    expect(parser.parseCode("<?php\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\nreadConversionTable(__DIR__ . '/data/KSX1001.txt', $ksxChars, $unused);\nfunction testValid($from, $to, $bothWays = true) {\n  identifyValidString($from, 'ISO-2022-KR');\n  convertValidString($from, $to, 'ISO-2022-KR', 'UTF-16BE', false);\n  if ($bothWays) {\n    /* 0xF at the beginning of an ISO-2022 string is redundant; it switches\n     * to ASCII mode, but ASCII mode is default */\n    if (strlen($from) > 0 && $from[0] == \"\\x0F\")\n      $from = substr($from, 1, strlen($from) - 1);\n    /* If the string switches to a different charset, it should switch back to\n     * ASCII at the end */\n    if (strpos($from, \"\\x1B\\$C\") !== false)\n      $from .= \"\\x0F\";\n    convertValidString($to, $from, 'UTF-16BE', 'ISO-2022-KR', false);\n  }\n}\nfunction testInvalid($from, $to) {\n  testInvalidString($from, $to, 'ISO-2022-KR', 'UTF-16BE');\n}\ntestValid(\"\", \"\");\necho \"Empty string OK\\n\";\nfor ($i = 0; $i < 0x80; $i++) {\n  if ($i == 0xE || $i == 0xF || $i == 0x1B)\n    continue;\n  testValid(chr($i),          \"\\x00\" . chr($i));\n  testValid(\"\\x0F\" . chr($i), \"\\x00\" . chr($i)); /* 0xF is 'Shift In' code */\n}\nfor ($i = 0x80; $i < 256; $i++) {\n  testInvalid(chr($i),          \"\\x00%\");\n  testInvalid(\"\\x0F\" . chr($i), \"\\x00%\");\n}\necho \"ASCII support OK\\n\";\nforeach ($ksxChars as $ksx => $utf16BE) {\n  testValid(\"\\x0E\" . $ksx, $utf16BE, false);\n  testValid(\"\\x1B$)C\\x0E\" . $ksx, $utf16BE, false);\n  testValid(\"\\x1B$)C\\x0E\" . $ksx . \"\\x0F\", $utf16BE);\n}\nfindInvalidChars($ksxChars, $invalidKsx, $truncatedKsx);\n$badChars = array_keys($invalidKsx);\nforeach ($badChars as $badChar) {\n  if ($badChar[0] == \"\\x0E\" || $badChar[0] == \"\\x0F\" || $badChar[0] == \"\\x1B\")\n    continue;\n  testInvalid(\"\\x1B$)C\\x0E\" . $badChar, \"\\x00%\");\n}\n$badChars = array_keys($truncatedKsx);\nforeach ($badChars as $badChar) {\n  testInvalid(\"\\x1B$)C\\x0E\" . $badChar, \"\\x00%\");\n}\necho \"KS X 1001 support OK\\n\";\n/* After a valid ESC sequence, we are still in ASCII mode; 'Shift Out' is needed to start KS X 1001 */\ntestValid(\"\\x1B$)Cabc\", \"\\x00a\\x00b\\x00c\", false);\n/* Test invalid and truncated ESC sequences */\ntestInvalid(\"\\x1B\", \"\\x00%\");\ntestInvalid(\"\\x1B$\", \"\\x00%\");\ntestInvalid(\"\\x1B$)\", \"\\x00%\");\nfor ($i = 0; $i < 256; $i++) {\n  if (chr($i) != '$')\n    testInvalid(\"\\x1B\" . chr($i), \"\\x00%\");\n  if (chr($i) != ')')\n    testInvalid(\"\\x1B$\" . chr($i), \"\\x00%\");\n  if (chr($i) != 'C')\n    testInvalid(\"\\x1B$)\" . chr($i), \"\\x00%\");\n}\n/* We can switch back and forth between ASCII and KS X 1001 */\ntestValid(\"\\x0E\\x0E\\x0F\\x0E\\x0Fabc\", \"\\x00a\\x00b\\x00c\", false);\necho \"Escapes behave as expected\\n\";\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\x1B\", \"%\", \"ISO-2022-KR\", \"UTF-8\");\nconvertInvalidString(\"\\x1B$\", \"%\", \"ISO-2022-KR\", \"UTF-8\");\nconvertInvalidString(\"\\x1B$)\", \"%\", \"ISO-2022-KR\", \"UTF-8\");\nconvertInvalidString(\"\\x1B$)C\\x0E\\x7C\\x84\", \"%\", \"ISO-2022-KR\", \"UTF-8\");\necho \"Done!\\n\";\n?>")).toMatchSnapshot();
  });
});
