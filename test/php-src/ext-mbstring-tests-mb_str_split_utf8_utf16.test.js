// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/mb_str_split_utf8_utf16.phpt
  it("mb_str_split() tests UTF-8 illegal chars & UTF-16 surrogate pairs", function () {
    expect(parser.parseCode("<?php\nini_set('include_path','.');\ninclude_once('common.inc');\n/* 123 string and 4-bytes length character 0xf09280a9 */\n$utf8 = pack(\"H*\", \"313233f09280a9\");\n/* 123 string and 4-bytes length character 0xf09280a9 head without tail */\n$utf8_bad = pack(\"H*\", \"313233f092\");\n/* very first and very last utf-16 4-bytes characters  */\n$utf16_first_be = pack(\"H*\", \"d800dc00\");\n$utf16_first_le = pack(\"H*\", \"00d800dc\");\n$utf16_last_be = pack(\"H*\", \"dbffdfff\");\n$utf16_last_le = pack(\"H*\", \"ffdbffdf\");\n$utf16be_char_bad = pack(\"H*\", \"dc00dc00\"); /* this char is illegal because it starts from low surrogate char */\n$utf16le_char_bad = pack(\"H*\", \"00dc00dc\"); /* this char is illegal because it starts from low surrogate char */\n$utf16be = $utf16_first_be . $utf16_last_be;\n$utf16le = $utf16_first_le . $utf16_last_le;\n$utf16be_bad = $utf16_first_be . $utf16be_char_bad;\n$utf16le_bad = $utf16_first_le . $utf16le_char_bad;\n/* print each chunk as HEX string */\necho \"UTF-8:\";\nforeach(mb_str_split($utf8, 2) as $chunk){\n    printf(\" l:%d v:%s\", strlen($chunk), unpack(\"H*\", $chunk)[1]);\n}\necho PHP_EOL;\necho \"BAD UTF-8:\";\nforeach(mb_str_split($utf8_bad, 2) as $chunk){\n    printf(\" l:%d v:%s\", strlen($chunk), unpack(\"H*\", $chunk)[1]);\n}\necho PHP_EOL;\necho \"UTF-16BE:\";\nforeach(mb_str_split($utf16be, 1, \"UTF-16BE\") as $chunk){\n    printf(\" l:%d v:%s\", strlen($chunk), unpack(\"H*\", $chunk)[1]);\n}\necho PHP_EOL;\necho \"UTF-16LE:\";\nforeach(mb_str_split($utf16le, 1, \"UTF-16LE\") as $chunk){\n    printf(\" l:%d v:%s\", strlen($chunk), unpack(\"H*\", $chunk)[1]);\n}\necho PHP_EOL;\necho \"BAD UTF-16BE:\";\nforeach(mb_str_split($utf16be_bad, 1, \"UTF-16BE\") as $chunk){\n    printf(\" l:%d v:%s\", strlen($chunk), unpack(\"H*\", $chunk)[1]);\n}\necho PHP_EOL;\necho \"BAD UTF-16LE:\";\nforeach(mb_str_split($utf16le_bad, 1, \"UTF-16LE\") as $chunk){\n    printf(\" l:%d v:%s\", strlen($chunk), unpack(\"H*\", $chunk)[1]);\n}\necho PHP_EOL;\nvar_dump(mb_str_split(\"\", 1, \"ASCII\"));\nvar_dump(mb_str_split(\"\", 1, \"UTF-8\"));\nvar_dump(mb_str_split(\"\", 1, \"UTF-16LE\"));\n?>")).toMatchSnapshot();
  });
});
