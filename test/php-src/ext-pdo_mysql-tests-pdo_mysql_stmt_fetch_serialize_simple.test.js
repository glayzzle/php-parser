// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_mysql/tests/pdo_mysql_stmt_fetch_serialize_simple.phpt
  it("MySQL PDOStatement->fetch(), PDO::FETCH_SERIALIZE", function () {
    expect(parser.parseCode("<?php\n    require_once(__DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');\n    $db = MySQLPDOTest::factory();\n    try {\n        class myclass implements Serializable {\n            public function __construct($caller = null) {\n                printf(\"%s(%s) - note that it must not be called when unserializing\\n\", __METHOD__, var_export($caller, true));\n            }\n            public function __set($prop, $value) {\n                printf(\"%s(%s, %s)\\n\", __METHOD__, var_export($prop, true), var_export($value, true));\n                $this->{$prop} = $value;\n            }\n            public function serialize() {\n                printf(\"%s()\\n\", __METHOD__);\n                return 'Value from serialize()';\n            }\n            public function unserialize($data) {\n                printf(\"%s(%s)\\n\", __METHOD__, var_export($data, true));\n            }\n        }\n        printf(\"Lets see what the Serializeable interface makes our object behave like...\\n\");\n        $obj = new myclass('Called by script');\n        $tmp = unserialize(serialize($obj));\n        var_dump($tmp);\n        printf(\"\\nAnd now magic PDO using fetchAll(PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE)...\\n\");\n        $db->exec('DROP TABLE IF EXISTS test');\n        $db->exec(sprintf('CREATE TABLE test(myobj BLOB) ENGINE=%s', MySQLPDOTest::getTableEngine()));\n        $db->exec(\"INSERT INTO test(myobj) VALUES ('Data fetched from DB to be given to unserialize()')\");\n        $stmt = $db->prepare('SELECT myobj FROM test');\n        $stmt->execute();\n        $rows = $stmt->fetchAll(PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE, 'myclass', array('Called by PDO'));\n        var_dump($rows[0]);\n        $stmt->execute();\n        $rows = $stmt->fetchAll(PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE, 'myclass');\n        var_dump($rows[0]);\n        printf(\"\\nAnd now PDO using setFetchMode(PDO::FETCH:CLASS|PDO::FETCH_SERIALIZE) + fetch()...\\n\");\n        $stmt = $db->prepare('SELECT myobj FROM test');\n        $stmt->setFetchMode(PDO::FETCH_CLASS|PDO::FETCH_SERIALIZE, 'myclass', array('Called by PDO'));\n        $stmt->execute();\n        var_dump($stmt->fetch());\n    } catch (PDOException $e) {\n        printf(\"[001] %s [%s] %s\\n\",\n            $e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));\n    }\n    $db->exec('DROP TABLE IF EXISTS test');\n    print \"done!\\n\";\n?>")).toMatchSnapshot();
  });
});
