// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/openssl/tests/stream_server_reneg_limit.phpt
  it("TLS server rate-limits client-initiated renegotiation", function () {
    expect(parser.parseCode("<?php\n$certFile = __DIR__ . DIRECTORY_SEPARATOR . 'stream_server_reneg_limit.pem.tmp';\n/**\n * This test uses the openssl binary directly to initiate renegotiation. At this time it's not\n * possible renegotiate the TLS handshake in PHP userland, so using the openssl s_client binary\n * command is the only feasible way to test renegotiation limiting functionality. It's not an ideal\n * solution, but it's really the only way to get test coverage on the rate-limiting functionality\n * given current limitations.\n */\n$serverCode = <<<'CODE'\n    $printed = false;\n    $serverUri = \"ssl://127.0.0.1:64321\";\n    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;\n    $serverCtx = stream_context_create(['ssl' => [\n        'local_cert' => '%s',\n        // TLS 1.3 does not support renegotiation.\n        'max_proto_version' => STREAM_CRYPTO_PROTO_TLSv1_2,\n        'reneg_limit' => 0,\n        'reneg_window' => 30,\n        'reneg_limit_callback' => function($stream) use (&$printed) {\n            if (!$printed) {\n                $printed = true;\n                var_dump($stream);\n            }\n        }\n    ]]);\n    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);\n    phpt_notify();\n    $clients = [];\n    while (1) {\n        $r = array_merge([$server], $clients);\n        $w = $e = [];\n        stream_select($r, $w, $e, $timeout=42);\n        foreach ($r as $sock) {\n            if ($sock === $server && ($client = stream_socket_accept($server, $timeout = 42))) {\n                $clientId = (int) $client;\n                $clients[$clientId] = $client;\n            } elseif ($sock !== $server) {\n                $clientId = (int) $sock;\n                $buffer = fread($sock, 1024);\n                if (strlen($buffer)) {\n                    continue;\n                } elseif (!is_resource($sock) || feof($sock)) {\n                    unset($clients[$clientId]);\n                    break 2;\n                }\n            }\n        }\n    }\nCODE;\n$serverCode = sprintf($serverCode, $certFile);\n$clientCode = <<<'CODE'\n    phpt_wait();\n    $cmd = 'openssl s_client -connect 127.0.0.1:64321';\n    $descriptorSpec = [[\"pipe\", \"r\"], [\"pipe\", \"w\"], [\"pipe\", \"w\"]];\n    $process = proc_open($cmd, $descriptorSpec, $pipes);\n    list($stdin, $stdout, $stderr) = $pipes;\n    // Trigger renegotiation twice\n    // Server settings only allow one per second (should result in disconnection)\n    fwrite($stdin, \"R\\nR\\nR\\nR\\n\");\n    $lines = [];\n    while(!feof($stderr)) {\n        fgets($stderr);\n    }\n    fclose($stdin);\n    fclose($stdout);\n    fclose($stderr);\n    proc_terminate($process);\nCODE;\ninclude 'CertificateGenerator.inc';\n$certificateGenerator = new CertificateGenerator();\n$certificateGenerator->saveNewCertAsFileWithKey('stream_security_level', $certFile);\ninclude 'ServerClientTestCase.inc';\nServerClientTestCase::getInstance()->run($serverCode, $clientCode);\n?>")).toMatchSnapshot();
  });
});
