// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/spl/tests/bug65328.phpt
  it("Bug #65328 (Segfault when getting SplStack object Value)", function () {
    expect(parser.parseCode("<?php\n/**\n * @author AlexanderC\n */\nclass Tree\n{\n    /**\n     * @var Node\n     */\n    protected $head;\n    public function __construct(Node $head = null)\n    {\n        $this->head = $head ? : new Node('HEAD');\n    }\n    /**\n     * @return Node\n     */\n    public function getHead()\n    {\n        return $this->head;\n    }\n    /**\n     * @param mixed $uid\n     * @return Node|bool\n     */\n    public function find($uid)\n    {\n        $iterator = $this->getIterator();\n        /** @var Node $node */\n        foreach($iterator as $node) {\n            if($node->getUid() === $uid) {\n                return $node;\n            }\n        }\n        return false;\n    }\n    /**\n     * @param mixed $uid\n     * @return \\SplStack\n     */\n    public function & findAll($uid)\n    {\n        $result = new \\SplStack();\n        /** @var Node $node */\n        foreach($this->getIterator() as $node) {\n            if($node->getUid() == $uid) {\n                $result->push($node);\n            }\n        }\n        return $result;\n    }\n    /**\n     * @return \\RecursiveIteratorIterator\n     */\n    public function getIterator(): Traversable\n    {\n        return new \\RecursiveIteratorIterator(\n            $this->head->getChildren(),\n            \\RecursiveIteratorIterator::SELF_FIRST\n        );\n    }\n}\nclass Node extends \\RecursiveArrayIterator implements \\Countable\n{\n    /**\n     * @var array\n     */\n    protected $children = [];\n    /**\n     * @var Node\n     */\n    protected $parent;\n    /**\n     * @var mixed\n     */\n    protected $data;\n    /**\n     * @var mixed\n     */\n    protected $uid;\n    /**\n     * @var int\n     */\n    protected $index = 0;\n    /**\n     * @var bool\n     */\n    protected $assureUnique;\n    /**\n     * @param mixed $data\n     * @param mixed $uid\n     * @param Node $parent\n     * @param bool $assureUnique\n     */\n    public function __construct($data, $uid = null, Node $parent = null, $assureUnique = false)\n    {\n        if(null !== $parent) {\n            $this->parent = $parent;\n        }\n        $this->data = $data;\n        $this->uid = $uid ? : uniqid(sha1(serialize($data)), true);\n        $this->assureUnique = $assureUnique;\n    }\n    /**\n     * @param mixed $uid\n     */\n    public function setUid($uid)\n    {\n        $this->uid = $uid;\n    }\n    /**\n     * @return mixed\n     */\n    public function getUid()\n    {\n        return $this->uid;\n    }\n    /**\n     * @param Node $child\n     */\n    public function addChild(Node $child)\n    {\n        $child->setParent($this);\n        $this->children[] = $child;\n    }\n    /**\n     * @param array $children\n     */\n    public function setChildren(array $children)\n    {\n        $this->children = $children;\n    }\n    /**\n     * @return array\n     */\n    public function getChildrenArray()\n    {\n        return $this->children;\n    }\n    /**\n     * @param mixed $data\n     */\n    public function setData($data)\n    {\n        $this->data = $data;\n    }\n    /**\n     * @return mixed\n     */\n    public function getData()\n    {\n        return $this->data;\n    }\n    /**\n     * @param Node $parent\n     * @throws \\RuntimeException\n     */\n    public function setParent(Node $parent)\n    {\n        if(true === $this->assureUnique && !self::checkUnique($parent, $this->uid)) {\n            throw new \\RuntimeException(\"Node uid is not unique in assigned node tree\");\n        }\n        $this->parent = $parent;\n    }\n    /**\n     * @param Node $node\n     * @param mixed $uid\n     * @return bool\n     */\n    protected static function checkUnique(Node $node, $uid)\n    {\n        $headNode = $node;\n        do {\n            $headNode = $node;\n        } while($node = $node->getParent());\n        $tree = new Tree($headNode);\n        return !$tree->find($uid);\n    }\n    /**\n     * @return \\IJsonRPC\\Helpers\\Tree\\Node\n     */\n    public function getParent()\n    {\n        return $this->parent;\n    }\n    public function current(): Node\n    {\n        return $this->children[$this->index];\n    }\n    /**\n     * @return scalar\n     */\n    public function key(): string|int|null\n    {\n        return $this->index;\n    }\n    public function next(): void\n    {\n        ++$this->index;\n    }\n    public function rewind(): void\n    {\n        $this->index = 0;\n    }\n    public function valid(): bool\n    {\n        return array_key_exists($this->index, $this->children);\n    }\n    public function count(): int\n    {\n        return count($this->children);\n    }\n    public function hasChildren(): bool\n    {\n        return !empty($this->children);\n    }\n    public function getChildren(): RecursiveArrayIterator\n    {\n        return new \\RecursiveArrayIterator($this->children);\n    }\n}\n$tree = new Tree();\n$node1 = new Node('value1', 1);\n$tree->getHead()->addChild($node1);\n$node2 = new Node('value2', 2);\n$node1->addChild($node2);\nprint_r($tree->findAll(2)->offsetGet(0));\n?>")).toMatchSnapshot();
  });
});
