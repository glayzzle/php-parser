// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_mysql/tests/pdo_mysql_attr_autocommit.phpt
  it("PDO::ATTR_AUTOCOMMIT", function () {
    expect(parser.parseCode("<?php\n    require_once(__DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');\n    $db = MySQLPDOTest::factory();\n    // autocommit should be on by default\n    if (1 !== ($tmp = $db->getAttribute(PDO::ATTR_AUTOCOMMIT)))\n        printf(\"[001] Expecting int/1 got %s\\n\", var_export($tmp, true));\n    // lets see if the server agrees to that\n    $row = $db->query('SELECT @@autocommit AS _autocommit')->fetch(PDO::FETCH_ASSOC);\n    if (!$row['_autocommit'])\n        printf(\"[002] Server autocommit mode should be on, got '%s'\\n\", var_export($row['_autocommit']));\n    // on -> off\n    if (!$db->setAttribute(PDO::ATTR_AUTOCOMMIT, 0))\n        printf(\"[003] Cannot turn off autocommit\\n\");\n    $row = $db->query('SELECT @@autocommit AS _autocommit')->fetch(PDO::FETCH_ASSOC);\n    if ($row['_autocommit'])\n        printf(\"[004] Server autocommit mode should be off, got '%s'\\n\", var_export($row['_autocommit']));\n    // PDO thinks autocommit is off, but its manually turned on...\n    if (!$db->query('SET autocommit = 1'))\n        printf(\"[005] Cannot turn on server autocommit mode, %s\\n\", var_export($db->errorInfo(), true));\n    if (0 !== ($tmp = $db->getAttribute(PDO::ATTR_AUTOCOMMIT)))\n        printf(\"[006] Expecting int/0 got %s\\n\", var_export($tmp, true));\n    // off -> on\n    if (!$db->query('SET autocommit = 0'))\n        printf(\"[007] Cannot turn off server autocommit mode, %s\\n\", var_export($db->errorInfo(), true));\n    if (!$db->setAttribute(PDO::ATTR_AUTOCOMMIT, 1))\n        printf(\"[008] Cannot turn on autocommit\\n\");\n    $row = $db->query('SELECT @@autocommit AS _autocommit')->fetch(PDO::FETCH_ASSOC);\n    if (!$row['_autocommit'])\n        printf(\"[009] Server autocommit mode should be on, got '%s'\\n\", var_export($row['_autocommit']));\n    if (1 !== ($tmp = $db->getAttribute(PDO::ATTR_AUTOCOMMIT)))\n        printf(\"[010] Expecting int/1 got %s\\n\", var_export($tmp, true));\n    if (MySQLPDOTest::detect_transactional_mysql_engine($db)) {\n        // nice, we have a transactional engine to play with\n        MySQLPDOTest::createTestTable($db, MySQLPDOTest::detect_transactional_mysql_engine($db));\n        $row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);\n        $num = $row['_num'];\n        $db->query(\"INSERT INTO test(id, label) VALUES (100, 'z')\");\n        $num++;\n        $row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);\n        if ($row['_num'] != $num)\n            printf(\"[011] Insert has failed, test will fail\\n\");\n        // autocommit is on, no rollback possible\n        $db->query('ROLLBACK');\n        $row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);\n        if ($row['_num'] != $num)\n            printf(\"[012] ROLLBACK should not have undone anything\\n\");\n        if (!$db->setAttribute(PDO::ATTR_AUTOCOMMIT, 0))\n            printf(\"[013] Cannot turn off autocommit\\n\");\n        $db->query('DELETE FROM test WHERE id = 100');\n        $db->query('ROLLBACK');\n        $row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);\n        if ($row['_num'] != $num)\n            printf(\"[014] ROLLBACK should have undone the DELETE\\n\");\n        $db->query('DELETE FROM test WHERE id = 100');\n        $db->query('COMMIT');\n        $num--;\n        $row = $db->query('SELECT COUNT(*) AS _num FROM test')->fetch(PDO::FETCH_ASSOC);\n        if ($row['_num'] != $num)\n            printf(\"[015] DELETE should have been committed\\n\");\n    }\n    print \"done!\";\n?>")).toMatchSnapshot();
  });
});
