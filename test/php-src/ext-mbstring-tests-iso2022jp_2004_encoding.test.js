// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/iso2022jp_2004_encoding.phpt
  it("Exhaustive test of ISO-2022-JP-2004 encoding verification and conversion", function () {
    expect(parser.parseCode("<?php\nsrand(111); /* Make results consistent */\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\n/* Read in table of all characters in JISX-0208 charset */\n$jisx0208Chars = array(); /* JISX0208 -> UTF-16BE */\n$fp = fopen(__DIR__ . '/data/JISX0208.txt', 'r+');\nwhile ($line = fgets($fp, 256)) {\n\tif ($line[0] == '#')\n\t\tcontinue;\n\tif (sscanf($line, \"0x%x\\t0x%x\\t0x%x\", $shiftJIS, $jis0208Code, $unicodeCP) == 3) {\n\t\t$jisx0208Chars[pack('n', $jis0208Code)] = pack('n', $unicodeCP);\n\t}\n}\n/* The JIS X 0208 character set does not have a single, straightforward\n * mapping to the Unicode character set\n * mbstring converts one character differently from the mappings in\n * data/JISX0208.txt, which comes from the Unicode Consortium */\n/* 0x2140 is a backslash; this can be mapped to 0x005C for an ordinary\n * backslash, or 0xFF3C for a _fullwidth_ one */\n$jisx0208Chars[\"\\x21\\x40\"] = \"\\xFF\\x3C\";\n/* Single bytes from 0x0-0x20 are allowed */\nfor ($i = 0; $i <= 0x20; $i++) {\n\tif ($i != 0x1B)\n\t\t$jisx0208Chars[chr($i)] = \"\\x00\" . chr($i);\n}\n/* As is 0x7F */\n$jisx0208Chars[\"\\x7F\"] = \"\\x00\\x7F\";\n/* Now read table of JISX-0213:2004 plane 1 and JISX-0213:2000 plane 2 chars */\n$jisx0213_2004_1Chars = array();\n$jisx0213_2000_2Chars = array();\n$fp = fopen(__DIR__ . '/data/ISO-2022-JP-2004-JISX0213.txt', 'r+');\nwhile ($line = fgets($fp, 256)) {\n\tif ($line[0] == '#')\n\t\tcontinue;\n\t$cp2 = null;\n\tif (sscanf($line, \"%d-%x\\tU+%x+%x\", $type, $bytes, $cp1, $cp2) >= 3) {\n\t\tif ($cp1 <= 0xFFFF)\n\t\t\t$unicode = pack('n', $cp1);\n\t\telse\n\t\t\t$unicode = mb_convert_encoding(pack('N', $cp1), 'UTF-16BE', 'UTF-32BE');\n\t\tif ($cp2)\n\t\t\t$unicode .= pack('n', $cp2);\n\t\tif ($type == 3)\n\t\t\t$jisx0213_2004_1Chars[pack('n', $bytes)] = $unicode;\n\t\telse if ($type == 4)\n\t\t\t$jisx0213_2000_2Chars[pack('n', $bytes)] = $unicode;\n\t}\n}\n/* JISX 0213 plane 1 0x2131 is an overline; Unicode has a halfwidth overline\n * at 0x203E and a fullwidth overline at 0xFFE3\n * We'll use the fullwidth version when converting JISX 0213 to Unicode */\n$jisx0213_2004_1Chars[\"\\x21\\x31\"] = \"\\xFF\\xE3\";\n/* Same deal with the Yen sign; use the fullwidth one */\n$jisx0213_2004_1Chars[\"\\x21\\x6F\"] = \"\\xFF\\xE5\";\n/* Since JISX 0213 is an extension of JISX 0208, allow the same single-byte chars */\nfor ($i = 0; $i <= 0x20; $i++) {\n\tif ($i != 0x1B)\n\t\t$jisx0213_2004_1Chars[chr($i)] = \"\\x00\" . chr($i);\n}\n$jisx0213_2004_1Chars[\"\\x7F\"] = \"\\x00\\x7F\";\nfor ($i = 0; $i <= 0x20; $i++) {\n\tif ($i != 0x1B)\n\t\t$jisx0213_2000_2Chars[chr($i)] = \"\\x00\" . chr($i);\n}\n$jisx0213_2000_2Chars[\"\\x7F\"] = \"\\x00\\x7F\";\nfunction testValid($from, $to, $bothWays = true) {\n\tidentifyValidString($from, 'ISO-2022-JP-2004');\n\tconvertValidString($from, $to, 'ISO-2022-JP-2004', 'UTF-16BE', false);\n\tif ($bothWays) {\n\t\t/* Try going in the opposite direction too\n\t\t * ESC ( B at the beginning of ISO-2022-JP-2004 string is redundant,\n\t\t * since ASCII mode is the default */\n\t\tif (substr($from, 0, 3) == \"\\x1B(B\")\n\t\t\t$from = substr($from, 3, strlen($from) - 3);\n\t\t/* If the ISO-2022-JP-2004 string switches to a different charset, it\n\t\t * should switch back to ASCII at the end */\n\t\tif (strpos($from, \"\\x1B\\$B\") !== false || strpos($from, \"\\x1B\\$(Q\") !== false || strpos($from, \"\\x1B\\$(P\") !== false)\n\t\t\t$from .= \"\\x1B(B\";\n\t\tconvertValidString($to, $from, 'UTF-16BE', 'ISO-2022-JP-2004', false);\n\t}\n}\nfunction testInvalid($from, $to) {\n\ttestInvalidString($from, $to, 'ISO-2022-JP-2004', 'UTF-16BE');\n}\n/* Try all ASCII characters */\nfor ($i = 0; $i <= 0x7F; $i++) {\n\tif ($i == 0x1B)\n\t\tcontinue;\n\ttestValid(chr($i), \"\\x00\" . chr($i));\n}\n/* Try all ASCII characters, with explicit ASCII escape */\nfor ($i = 0; $i <= 0x7F; $i++) {\n\tif ($i == 0x1B)\n\t\tcontinue;\n\ttestValid(\"\\x1B(B\" . chr($i), \"\\x00\" . chr($i));\n}\necho \"Encoding verification and conversion works for all ASCII characters\\n\";\n/* Try a bare ESC */\nidentifyInvalidString(\"\\x1B\", 'ISO-2022-JP-2004');\n/* Try all non-ASCII, non-ESC single bytes */\nfor ($i = 0x80; $i <= 0xFF; $i++) {\n\ttestInvalid(chr($i), \"\\x00%\");\n}\necho \"Encoding verification and conversion rejects all invalid single bytes\\n\";\n/* All valid JISX0208 characters */\nforeach ($jisx0208Chars as $jisx0208 => $utf16BE) {\n\t/* Since JIS X 0213 charset is a superset of JIS X 0208, we don't bother\n\t * using JIS X 0208 when converting Unicode to ISO-2022-JP-2004\n\t * Therefore, don't test conversion in both directions here */\n\ttestValid(\"\\x1B\\$B\" . $jisx0208, $utf16BE, false);\n}\n/* All invalid 1-byte JISX0208 characters */\nfor ($i = 0; $i < 256; $i++) {\n\tif ($i == 0x1B)\n\t\tcontinue;\n\tif ($i >= 0x21 && $i <= 0x7E)\n\t\tcontinue;\n\t$testString = chr($i);\n\tif (!isset($jisx0208Chars[$testString])) {\n\t\ttestInvalid(\"\\x1B\\$B\" . $testString, \"\\x00%\");\n\t}\n}\n/* All invalid 2-byte JISX0208 characters */\nfor ($i = 0x21; $i <= 0x7E; $i++) {\n\tfor ($j = 0; $j < 256; $j++) {\n\t\t$testString = chr($i) . chr($j);\n\t\tif (!isset($jisx0208Chars[$testString])) {\n\t\t\ttestInvalid(\"\\x1B\\$B\" . $testString, \"\\x00%\");\n\t\t}\n\t}\n}\necho \"Encoding verification and conversion work on JISX-0208 characters\\n\";\n/* All JISX0213 plane 1 characters */\nforeach ($jisx0213_2004_1Chars as $jisx0213_2004 => $utf16BE) {\n\t/* For single bytes, don't try conversion in both directions */\n\ttestValid(\"\\x1B$(Q\" . $jisx0213_2004, $utf16BE, $utf16BE > \"\\x01\\x00\");\n}\n/* All invalid 2-byte JISX0213 plane 1 characters */\nfor ($i = 0x21; $i <= 0x7E; $i++) {\n\tfor ($j = 0; $j < 256; $j++) {\n\t\t$testString = chr($i) . chr($j);\n\t\tif (!isset($jisx0213_2004_1Chars[$testString])) {\n\t\t\ttestInvalid(\"\\x1B$(Q\" . $testString, \"\\x00%\");\n\t\t}\n\t}\n}\necho \"Encoding verification and conversion work on JISX-0213:2004 plane 1 characters\\n\";\n/* All JISX0213 plane 2 characters */\nforeach ($jisx0213_2000_2Chars as $jisx0213_2000 => $utf16BE) {\n\t/* For single bytes, don't try conversion in both directions */\n\ttestValid(\"\\x1B$(P\" . $jisx0213_2000, $utf16BE, $utf16BE > \"\\x01\\x00\");\n}\n/* All invalid 2-byte JISX0213 plane 2 characters */\nfor ($i = 0x21; $i <= 0x7E; $i++) {\n\tfor ($j = 0; $j < 256; $j++) {\n\t\t$testString = chr($i) . chr($j);\n\t\tif (!isset($jisx0213_2000_2Chars[$testString])) {\n\t\t\ttestInvalid(\"\\x1B$(P\" . $testString, \"\\x00%\");\n\t\t}\n\t}\n}\necho \"Encoding verification and conversion work on JISX-0213:2000 plane 2 characters\\n\";\n/* All possible escape sequences */\n$validEscapes = [\"\\x1B\\$B\" => true, \"\\x1B(B\" => true, \"\\x1B$(Q\" => true, \"\\x1B$(P\" => true];\nfor ($i = 0; $i <= 0xFF; $i++) {\n\tfor ($j = 0; $j <= 0xFF; $j++) {\n\t\t$escapeSequence = \"\\x1B\" . chr($i) . chr($j);\n\t\tif (isset($validEscapes[$escapeSequence])) {\n\t\t\ttestValid($escapeSequence, \"\", false);\n\t\t} else {\n\t\t\tidentifyInvalidString($escapeSequence, 'ISO-2022-JP-2004');\n\t\t}\n\t}\n}\necho \"All escape sequences work as expected\\n\";\nidentifyInvalidString(\"\\x1B$\", 'ISO-2022-JP-2004');\nidentifyInvalidString(\"\\x1B(\", 'ISO-2022-JP-2004');\nidentifyInvalidString(\"\\x1B$(\", 'ISO-2022-JP-2004');\necho \"All incomplete escape sequences are rejected\\n\";\n/* Try all combinations of 2 different charsets in the same string */\n$ascii = \"\\x1B(Ba\";\n$jisx0208 = \"\\x1B\\$B\" . array_keys($jisx0208Chars)[rand(0,1000)];\n$jisx0213_1 = \"\\x1B$(Q\" . array_keys($jisx0213_2004_1Chars)[rand(0,1000)];\n$jisx0213_2 = \"\\x1B$(P\" . array_keys($jisx0213_2000_2Chars)[rand(0,1000)];\n$differentCharsets = [$ascii, $jisx0208, $jisx0213_1, $jisx0213_2];\nforeach ($differentCharsets as $a) {\n\tforeach ($differentCharsets as $b) {\n\t\tidentifyValidString($a . $b, 'ISO-2022-JP-2004');\n\t}\n}\n/* Try redundant escape sequences (switching mode but including any characters\n * in the new mode) */\n$ascii_Esc = \"\\x1B(B\";\n$jisx0208_Esc = \"\\x1B\\$B\";\n$jisx0213_1_Esc = \"\\x1B$(Q\";\n$jisx0213_2_Esc = \"\\x1B$(P\";\n$differentCharsets = [$ascii_Esc, $jisx0208_Esc, $jisx0213_1_Esc, $jisx0213_2_Esc];\nforeach ($differentCharsets as $a) {\n\tforeach ($differentCharsets as $b) {\n\t\ttestValid($a . $b, \"\", false);\n\t}\n}\necho \"Combining multiple charsets in the same string works as expected\\n\";\n/* Try ending in the middle of a JISX0208 character */\ntestInvalid(substr($jisx0208, 0, strlen($jisx0208) - 1), \"\\x00%\");\n/* Try ending in the middle of a JISX0213 plane 1 character */\ntestInvalid(substr($jisx0213_1, 0, strlen($jisx0213_1) - 1), \"\\x00%\");\n/* Try ending in the middle of a JISX0213 plane 2 character */\ntestInvalid(substr($jisx0213_2, 0, strlen($jisx0213_2) - 1), \"\\x00%\");\necho \"Strings with truncated multi-byte characters are rejected\\n\";\n/* We have tried converting all kinds of strings with single characters;\n * now try some random examples of strings with multiple characters */\n$jisx0208 = array_keys($jisx0208Chars);\nshuffle($jisx0208);\n$jisx0213_1 = array_keys($jisx0213_2004_1Chars);\nshuffle($jisx0213_1);\n$jisx0213_2 = array_keys($jisx0213_2000_2Chars);\nshuffle($jisx0213_2);\nfor ($i = 0; $i < 100; $i++) {\n\t$size = rand(5,20);\n\t$testString = '';\n\t$convertsTo = '';\n\t/* Build a string from a random combination of characters in the supported\n\t * character sets */\n\twhile ($size--) {\n\t\t$type  = rand(0,4);\n\t\t$chars = rand(0,10);\n\t\tif ($type == 0) { /* ASCII */\n\t\t\t$testString .= \"\\x1B(B\";\n\t\t\twhile ($chars--) {\n\t\t\t\t$ascii = chr(rand(0x20, 0x7E));\n\t\t\t\t$testString .= $ascii;\n\t\t\t\t$convertsTo .= \"\\x00\" . $ascii;\n\t\t\t}\n\t\t} else if ($type == 1) { /* JIS X 0208 */\n\t\t\t$testString .= \"\\x1B\\$B\";\n\t\t\twhile ($chars--) {\n\t\t\t\t$jis = array_pop($jisx0208);\n\t\t\t\t$testString .= $jis;\n\t\t\t\t$convertsTo .= $jisx0208Chars[$jis];\n\t\t\t}\n\t\t} else if ($type == 2) { /* JIS X 0213:2004 plane 1 */\n\t\t\t$testString .= \"\\x1B$(Q\";\n\t\t\twhile ($chars--) {\n\t\t\t\t$jis = array_pop($jisx0213_1);\n\t\t\t\t$testString .= $jis;\n\t\t\t\t$convertsTo .= $jisx0213_2004_1Chars[$jis];\n\t\t\t}\n\t\t} else { /* JIS X 0213:2000 plane 2 */\n\t\t\t$testString .= \"\\x1B$(P\";\n\t\t\twhile ($chars-- && !empty($jisx0213_2)) {\n\t\t\t\t$jis = array_pop($jisx0213_2);\n\t\t\t\t$testString .= $jis;\n\t\t\t\t$convertsTo .= $jisx0213_2000_2Chars[$jis];\n\t\t\t}\n\t\t}\n\t}\n\ttestValid($testString, $convertsTo, false);\n}\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\xE0\", \"%\", \"ISO-2022-JP-2004\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$(X\", \"%\", \"ISO-2022-JP-2004\", \"UTF-8\"); // Invalid escape\nconvertInvalidString(\"\\x1B\\$B!\", \"%\", \"ISO-2022-JP-2004\", \"UTF-8\"); // Truncated character\necho \"All done!\\n\";\n?>")).toMatchSnapshot();
  });
});
