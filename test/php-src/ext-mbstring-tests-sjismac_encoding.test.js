// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/sjismac_encoding.phpt
  it("Exhaustive test of MacJapanese encoding verification and conversion", function () {
    expect(parser.parseCode("<?php\nsrand(300); /* Make results consistent */\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\n/* Read in the table of all characters in MacJapanese */\n$validChars = array(); /* MacJapanese string -> UTF-32BE string */\n$fromUnicode = array(); /* UTF-16BE -> MacJapanese */\n$fp = fopen(__DIR__ . '/data/MacJapanese-SJIS.txt', 'r+');\nwhile ($line = fgets($fp, 256)) {\n\tif ($line[0] == '#')\n\t\tcontinue;\n\t$cp1 = $cp2 = $cp3 = $cp4 = $cp5 = null;\n\tif (sscanf($line, \"0x%x\\t0x%x+0x%x+0x%x+0x%x+0x%x\", $bytes, $cp1, $cp2, $cp3, $cp4, $cp5) >= 2) {\n\t\tif ($bytes < 256) {\n\t\t\t$macJap = chr($bytes);\n\t\t} else {\n\t\t\t$macJap = pack('n', $bytes);\n\t\t}\n\t\tif ($cp5) {\n\t\t\t$validChars[$macJap] = pack('NNNNN', $cp1, $cp2, $cp3, $cp4, $cp5);\n\t\t\t$fromUnicode[pack('nnnnn', $cp1, $cp2, $cp3, $cp4, $cp5)] = $macJap;\n\t\t} else if ($cp4) {\n\t\t\t$validChars[$macJap] = pack('NNNN', $cp1, $cp2, $cp3, $cp4);\n\t\t\t$fromUnicode[pack('nnnn', $cp1, $cp2, $cp3, $cp4)] = $macJap;\n\t\t} else if ($cp3) {\n\t\t\t$validChars[$macJap] = pack('NNN', $cp1, $cp2, $cp3);\n\t\t\t$fromUnicode[pack('nnn', $cp1, $cp2, $cp3)] = $macJap;\n\t\t} else if ($cp2) {\n\t\t\t$validChars[$macJap] = pack('NN', $cp1, $cp2);\n\t\t\t$fromUnicode[pack('nn', $cp1, $cp2)] = $macJap;\n\t\t} else {\n\t\t\t$validChars[$macJap] = pack('N', $cp1);\n\t\t\t$fromUnicode[pack('n', $cp1)] = $macJap;\n\t\t}\n\t}\n}\n/* Although not included in the table, 0x0-0x1F and 0x7F are valid;\n * these are 'control characters' */\nfor ($i = 0; $i < 0x20; $i++) {\n\t$validChars[chr($i)] = pack('N', $i);\n\t$fromUnicode[pack('n', $i)] = chr($i);\n}\n$validChars[\"\\x7F\"] = pack('N', 0x7F);\n$fromUnicode[\"\\x00\\x7F\"] = \"\\x7F\";\n/* While Shift-JIS 0x815C normally corresponds to U+2015 (HORIZONTAL BAR),\n * for MacJapanese we convert 0x815C to U+2014 (EM DASH)\n * (See recommendations in JAPANESE.txt from the Unicode Consortium, under\n * 'Unicode mapping issues', point 3)\n * However, when converting Unicode -> MacJapanese, we accept both U+2014\n * and U+2015 */\n$fromUnicode[\"\\x20\\x15\"] = \"\\x81\\x5C\";\n/* Convert U+203E (OVERLINE) to 0x8150 (FULLWIDTH MACRON) */\n$fromUnicode[\"\\x20\\x3E\"] = \"\\x81\\x50\";\n/* And also U+00AF (MACRON) */\n$fromUnicode[\"\\x00\\xAF\"] = \"\\x81\\x50\";\n/* Convert U+FF5E (FULLWIDTH TILDE) to 0x8160 (WAVE DASH) */\n$fromUnicode[\"\\xFF\\x5E\"] = \"\\x81\\x60\";\ntestAllValidChars($validChars, 'SJIS-mac', 'UTF-32BE');\necho \"MacJapanese verification and conversion works on all valid characters\\n\";\nfindInvalidChars($validChars, $invalidChars, $truncated,\n\tarray_fill_keys(range(0x81, 0x9F), 2) + array_fill_keys(range(0xE0, 0xED), 2));\ntestAllInvalidChars($invalidChars, $validChars, 'SJIS-mac', 'UTF-32BE', \"\\x00\\x00\\x00%\");\ntestTruncatedChars($truncated, 'SJIS-mac', 'UTF-32BE', \"\\x00\\x00\\x00%\");\necho \"MacJapanese verification and conversion rejects all invalid characters\\n\";\ntestAllValidChars($fromUnicode, 'UTF-16BE', 'SJIS-mac', false);\necho \"Unicode -> SJIS-mac conversion works on all valid characters\\n\";\nfindInvalidChars($fromUnicode, $invalidChars, $unused, array_fill_keys(range(0, 0xFF), 2));\nconvertAllInvalidChars($invalidChars, $fromUnicode, 'UTF-16BE', 'SJIS-mac', '%');\necho \"Unicode -> SJIS-mac conversion works on all invalid characters\\n\";\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\x81\", \"%\", \"SJIS-mac\", \"UTF-8\");\nconvertInvalidString(\"\\x81\\x20\", \"%\", \"SJIS-mac\", \"UTF-8\");\nconvertInvalidString(\"\\xED\\x9F\", \"%\", \"SJIS-mac\", \"UTF-8\");\necho \"Done!\\n\";\n?>")).toMatchSnapshot();
  });
});
