// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/standard/tests/serialize/005.phpt
  it("serialize()/unserialize() objects", function () {
    expect(parser.parseCode("<?php\n// This test verifies that old and new style (un)serializing do not interfere.\nfunction do_autoload($class_name)\n{\n    if ($class_name != 'autoload_not_available')\n    {\n        require_once(__DIR__ . '/' . strtolower($class_name) . '.inc');\n    }\n    echo __FUNCTION__ . \"($class_name)\\n\";\n}\nfunction unserializer($class_name)\n{\n    echo __METHOD__ . \"($class_name)\\n\";\n    switch($class_name)\n    {\n    case 'TestNAOld':\n        eval(\"class TestNAOld extends TestOld {}\");\n        break;\n    case 'TestNANew':\n        eval(\"class TestNANew extends TestNew {}\");\n        break;\n    case 'TestNANew2':\n        eval(\"class TestNANew2 extends TestNew {}\");\n        break;\n    default:\n        echo \"Try autoloader\\n\";\n        if (!spl_autoload_functions()) {\n            spl_autoload_register(function ($class_name) { do_autoload($class_name); });\n        }\n        spl_autoload_call($class_name);\n        break;\n    }\n}\nini_set('unserialize_callback_func', 'unserializer');\nclass TestOld\n{\n    function serialize()\n    {\n        echo __METHOD__ . \"()\\n\";\n    }\n    function unserialize($serialized)\n    {\n        echo __METHOD__ . \"()\\n\";\n    }\n    function __wakeup()\n    {\n        echo __METHOD__ . \"()\\n\";\n    }\n    function __sleep()\n    {\n        echo __METHOD__ . \"()\\n\";\n        return array();\n    }\n}\nclass TestNew implements Serializable\n{\n    protected static $check = 0;\n    function serialize()\n    {\n        echo __METHOD__ . \"()\\n\";\n        switch(++self::$check)\n        {\n        case 1:\n            return NULL;\n        case 2:\n            return \"2\";\n        }\n    }\n    function unserialize($serialized)\n    {\n        echo __METHOD__ . \"()\\n\";\n    }\n    function __wakeup()\n    {\n        echo __METHOD__ . \"()\\n\";\n    }\n    function __sleep()\n    {\n        echo __METHOD__ . \"()\\n\";\n    }\n}\necho \"===O1===\\n\";\nvar_dump($ser = serialize(new TestOld));\nvar_dump(unserialize($ser));\necho \"===N1===\\n\";\nvar_dump($ser = serialize(new TestNew));\nvar_dump(unserialize($ser));\necho \"===N2===\\n\";\nvar_dump($ser = serialize(new TestNew));\nvar_dump(unserialize($ser));\necho \"===NAOld===\\n\";\nvar_dump(unserialize('O:9:\"TestNAOld\":0:{}'));\necho \"===NANew===\\n\";\nvar_dump(unserialize('O:9:\"TestNANew\":0:{}'));\necho \"===NANew2===\\n\";\nvar_dump(unserialize('C:10:\"TestNANew2\":0:{}'));\necho \"===AutoOld===\\n\";\nvar_dump(unserialize('O:19:\"autoload_implements\":0:{}'));\n// Now we have an autoloader, that will be called before the old style header.\n// If the old style handler also fails to register the class then the object\n// becomes an incomplete class instance.\necho \"===AutoNA===\\n\";\nvar_dump(unserialize('O:22:\"autoload_not_available\":0:{}'));\n?>")).toMatchSnapshot();
  });
});
