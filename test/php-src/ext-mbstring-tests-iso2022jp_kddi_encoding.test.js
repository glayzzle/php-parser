// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/iso2022jp_kddi_encoding.phpt
  it("Exhaustive test of ISO-2022-JP-KDDI text encoding", function () {
    expect(parser.parseCode("<?php\nsrand(390); /* Make results consistent */\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\nfunction shiftJISDecode($bytes) {\n  /* Convert CP932's default Shift-JIS representation to kuten code */\n  $first = ($bytes >> 8) & 0xFF;\n  $second = $bytes & 0xFF;\n  $hi_bits = $first - (($first > 0x9F) ? 0xE0 - 31 : 0x81);\n  if ($second > 0x9E) {\n    $kuten = ((($hi_bits << 1) + 0x22) << 8) + ($second - 0x9F + 0x21);\n  } else if ($second > 0x7F) {\n    $kuten = ((($hi_bits << 1) + 0x21) << 8) + ($second - 0x80 + 63 + 0x21);\n  } else {\n    $kuten = ((($hi_bits << 1) + 0x21) << 8) + ($second - 0x40 + 0x21);\n  }\n  return $kuten;\n}\n/* Read in the table of all characters in CP932 */\n$cp932Chars = array(); /* CP932 string -> UTF-32BE string */\n$fp = fopen(realpath(__DIR__ . '/data/CP932.txt'), 'r+');\nwhile ($line = fgets($fp, 256)) {\n  if ($line[0] == '#')\n    continue;\n  if (sscanf($line, \"0x%x\\t0x%x\", $bytes, $codepoint) == 2) {\n    if ($bytes < 256)\n      continue;\n    /* For ISO-2022-JP-KDDI, we only accept the first range of MicroSoft\n     * vendor extensions, in ku 13 */\n    if ($bytes > 0xEAA4)\n      continue;\n    $cp932Chars[pack('n', shiftJISDecode($bytes))] = pack('N', $codepoint);\n  }\n}\n/* Add KDDI-specific emoji to the CP932 characters\n * They are mapped in 22 ku (or 'rows') above the places where they are mapped\n * in the Shift-JIS representation of KDDI emoji */\n$fp = fopen(realpath(__DIR__ . '/data/EmojiSources.txt'), 'r+');\nwhile ($line = fgets($fp, 256)) {\n  if ($line[0] == '#')\n    continue;\n  $fields = explode(';', rtrim($line));\n  if (count($fields) >= 4) {\n    if (sscanf($fields[0], \"%x %x\", $cp1, $cp2) == 2)\n      $utf32 = pack('N', $cp1) . pack('N', $cp2);\n    else\n      $utf32 = pack('N', hexdec($fields[0]));\n    if ($fields[2]) {\n      $kuten = shiftJISDecode(hexdec($fields[2]));\n      $ku = $kuten >> 8;\n      if ($ku >= 106 && $ku <= 112)\n        $cp932Chars[pack('n', $kuten - (22 * 0x100))] = $utf32;\n    }\n  }\n}\n/* Duplicate mappings for the same characters in CP932 */\n$nonInvertible = array();\nforeach ([0x8790, 0x8791, 0x8792, 0x8795, 0x8796, 0x8797, 0x879A, 0x879B, 0x879C] as $i) {\n  $bytes = pack('n', shiftJISDecode($i));\n  $nonInvertible[$bytes] = $cp932Chars[$bytes];\n}\n/* Read in table of all characters in JISX-0201 charset */\n$jisx0201Chars = array(); /* JISX0201 -> UTF-32BE */\n$fp = fopen(realpath(__DIR__ . '/data/JISX0201.txt'), 'r+');\nwhile ($line = fgets($fp, 256)) {\n  if ($line[0] == '#')\n    continue;\n  if (sscanf($line, \"0x%x\\t0x%x\", $byte, $codepoint) == 2)\n    $jisx0201Chars[chr($byte)] = pack('N', $codepoint);\n}\nfunction testValid($from, $to, $encoding, $bothWays = true) {\n  identifyValidString($from, $encoding);\n  convertValidString($from, $to, $encoding, 'UTF-32BE', false);\n  if ($bothWays) {\n    /* ESC ( B at the beginning is redundant, since ASCII mode is the default */\n    if (substr($from, 0, 3) == \"\\x1B(B\")\n      $from = substr($from, 3, strlen($from) - 3);\n    /* If the string switches to a different charset, it should switch back to\n     * ASCII at the end */\n    if (strpos($from, \"\\x1B\\$B\") !== false || strpos($from, \"\\x1B(I\") !== false || strpos($from, \"\\x1B\\$@\") !== false || strpos($from, \"\\x1B\\$(B\") !== false)\n      $from .= \"\\x1B(B\";\n    convertValidString($to, $from, 'UTF-32BE', $encoding, false);\n  }\n}\nfunction testInvalid($from, $to, $encoding) {\n  testInvalidString($from, $to, $encoding, 'UTF-32BE');\n}\nfor ($i = 0; $i < 0x80; $i++) {\n  if ($i == 0x1B)\n    continue;\n  testValid(chr($i),            \"\\x00\\x00\\x00\" . chr($i), 'ISO-2022-JP-KDDI');\n  testValid(\"\\x1B(B\" . chr($i), \"\\x00\\x00\\x00\" . chr($i), 'ISO-2022-JP-KDDI', false);\n  testValid(\"\\x1B(J\" . chr($i), \"\\x00\\x00\\x00\" . chr($i), 'ISO-2022-JP-KDDI', false);\n}\nfor ($i = 0x80; $i < 256; $i++) {\n  if ($i >= 0xA1 && $i <= 0xDF) // We convert single bytes from 0xA1-0xDF as JIS X 0201 kana\n    continue;\n  testInvalid(chr($i),            \"\\x00\\x00\\x00%\", 'ISO-2022-JP-KDDI');\n  testInvalid(\"\\x1B(B\" . chr($i), \"\\x00\\x00\\x00%\", 'ISO-2022-JP-KDDI');\n  testInvalid(\"\\x1B(J\" . chr($i), \"\\x00\\x00\\x00%\", 'ISO-2022-JP-KDDI');\n}\necho \"ASCII support OK\\n\";\n/* All valid JIS X 0201 characters\n * Those with a 1 in the high bit are JIS X 0201 kana */\nforeach ($jisx0201Chars as $jisx0201 => $utf32BE) {\n  if (ord($jisx0201) >= 128) {\n    $kana = chr(ord($jisx0201) - 128);\n    testValid(\"\\x1B(I\" . $kana, $utf32BE, 'ISO-2022-JP-KDDI', false);\n    testValid($jisx0201, $utf32BE, 'ISO-2022-JP-KDDI', false);\n  }\n}\nfor ($i = 0x80; $i < 256; $i++) {\n  if ($i >= 0xA1 && $i <= 0xDF)\n    continue;\n  testInvalid(\"\\x1B(I\" . chr($i), \"\\x00\\x00\\x00%\", 'ISO-2022-JP-KDDI');\n  testInvalid(\"\\x1B(J\" . chr($i), \"\\x00\\x00\\x00%\", 'ISO-2022-JP-KDDI');\n}\necho \"JIS X 0201 support OK\\n\";\n$validChars = $cp932Chars;\n/* We allow ASCII/JIS X 0201 characters to appear even in JIS X 0208 mode */\nfor ($i = 0; $i <= 0x7F; $i++)\n  $validChars[chr($i)] = chr($i);\nfor ($i = 0xA1; $i <= 0xDF; $i++)\n  $validChars[chr($i)] = $jisx0201Chars[chr($i)];\n$lenTable = array_fill_keys(range(0xE0, 0xFC), 2) + array_fill_keys(range(0x81, 0x9F), 2);\nfindInvalidChars($validChars, $invalidChars, $truncatedChars, $lenTable);\nforeach ($nonInvertible as $bytes => $char)\n  unset($cp932Chars[$bytes]);\n$good = array_keys($cp932Chars);\nshuffle($good);\nwhile (!empty($good)) {\n  $length = min(rand(5,10), count($good));\n  $from = $to = '';\n  while ($length--) {\n    $goodChar = array_pop($good);\n    $from .= $goodChar;\n    $to .= $cp932Chars[$goodChar];\n  }\n  testValid(\"\\x1B\\$B\" . $from, $to, 'ISO-2022-JP-KDDI');\n}\n$good = array_keys($nonInvertible);\nshuffle($good);\nwhile (!empty($good)) {\n  $length = min(rand(5,10), count($good));\n  $from = $to = '';\n  while ($length--) {\n    $goodChar = array_pop($good);\n    $from .= $goodChar;\n    $to .= $nonInvertible[$goodChar];\n  }\n  testValid(\"\\x1B\\$B\" . $from, $to, 'ISO-2022-JP-KDDI', false);\n}\nforeach (array_keys($invalidChars) as $invalid) {\n  $firstByte = ord($invalid[0]);\n  if (($firstByte > 0x80 && $firstByte < 0xA0) || $firstByte >= 0xE0) {\n    /* The first byte of this 2-byte character will be rejected and result in % being sent\n     * to the output. Then the second byte will do something else. It is easier to write the\n     * test if we only check with the 1st byte. */\n    testInvalidString(\"\\x1B\\$B\" . $invalid[0], \"\\x00\\x00\\x00%\", 'ISO-2022-JP-KDDI', 'UTF-32BE');\n  } else {\n    testInvalidString(\"\\x1B\\$B\" . $invalid, \"\\x00\\x00\\x00%\", 'ISO-2022-JP-KDDI', 'UTF-32BE');\n  }\n}\nforeach (array_keys($truncatedChars) as $truncated)\n  testInvalidString(\"\\x1B\\$B\" . $truncated, \"\\x00\\x00\\x00%\", 'ISO-2022-JP-KDDI', 'UTF-32BE');\necho \"JIS X 0208 (with MS extensions) and KDDI emoji support OK\\n\";\ntestValidString(\"\\x00\\xA5\", \"\\x1B\\$B!o\\x1B(B\", \"UTF-16BE\", \"ISO-2022-JP-KDDI\", false);\ntestValidString(\"\\x20\\x3E\", \"\\x1B\\$B!1\\x1B(B\", \"UTF-16BE\", \"ISO-2022-JP-KDDI\", false);\ntestValidString(\"\\xFF\\x5E\", \"\\x1B\\$B!A\\x1B(B\", \"UTF-16BE\", \"ISO-2022-JP-KDDI\", false);\necho \"Other mappings from Unicode -> ISO-2022-JP-KDDI OK\\n\";\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\xE0\", \"%\", \"ISO-2022-JP-KDDI\", \"UTF-8\");\n// Invalid escapes:\nconvertInvalidString(\"\\x1B\", \"%\", \"ISO-2022-JP-KDDI\", \"UTF-8\");\nconvertInvalidString(\"\\x1B.\", \"%\", \"ISO-2022-JP-KDDI\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$\", \"%\", \"ISO-2022-JP-KDDI\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$.\", \"%\", \"ISO-2022-JP-KDDI\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$(X\", \"%\", \"ISO-2022-JP-KDDI\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$B\\x9F\", \"%\", \"ISO-2022-JP-KDDI\", \"UTF-8\"); // 0x9F does not start any 2-byte character\nconvertInvalidString(\"\\xE0\\x00\", \"U+E000\", \"UTF-16BE\", \"ISO-2022-JP-KDDI\");\necho \"Done!\\n\";\n?>")).toMatchSnapshot();
  });
});
