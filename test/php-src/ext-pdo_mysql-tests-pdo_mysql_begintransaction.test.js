// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_mysql/tests/pdo_mysql_begintransaction.phpt
  it("PDO->beginTransaction()", function () {
    expect(parser.parseCode("<?php\n    require_once(__DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');\n    $db = MySQLPDOTest::factory();\n    MySQLPDOTest::createTestTable($db, MySQLPDOTest::detect_transactional_mysql_engine($db));\n    if (1 !== $db->getAttribute(PDO::ATTR_AUTOCOMMIT))\n        printf(\"[001] Autocommit should be on by default\\n\");\n    if (false == $db->beginTransaction())\n        printf(\"[002] Cannot start a transaction, [%s] [%s]\\n\",\n            $db->errorCode(), implode(' ', $db->errorInfo()));\n    if (1 !== $db->getAttribute(PDO::ATTR_AUTOCOMMIT))\n        printf(\"[003] Autocommit should be on by default, beginTransaction() shall not impact it\\n\");\n    if (0 == $db->exec('DELETE FROM test'))\n        printf(\"[004] No rows deleted, can't be true.\\n\");\n    /* This is the PDO way to close a connection */\n    $db = null;\n    $db = MySQLPDOTest::factory();\n    $db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);\n    /* Autocommit was off - by definition. Commit was not issued. DELETE should have been rolled back. */\n    if (!($stmt = $db->query('SELECT id, label FROM test ORDER BY id ASC')))\n        printf(\"[005] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    $row = $stmt->fetch(PDO::FETCH_ASSOC);\n    var_dump($row);\n    if (!$db->beginTransaction())\n        printf(\"[006] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    if (1 !== $db->exec(sprintf('DELETE FROM test WHERE id = %d', $row['id'])))\n        printf(\"[007] DELETE should have indicated 1 deleted row, [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    if (!$db->commit())\n        printf(\"[008] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    if (1 !== $db->getAttribute(PDO::ATTR_AUTOCOMMIT))\n        printf(\"[009] Autocommit should be on after commit()\\n\");\n    if (!($stmt = $db->query(sprintf('SELECT id, label FROM test WHERE id = %d', $row['id']))))\n        printf(\"[010] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    var_dump($stmt->fetch(PDO::FETCH_ASSOC));\n    if (!$db->beginTransaction())\n        printf(\"[011] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    $db->exec(sprintf(\"INSERT INTO test(id, label) VALUES (%d, 'z')\", $row['id']));\n    if (!($stmt = $db->query(sprintf('SELECT id, label FROM test WHERE id = %d', $row['id']))))\n        printf(\"[012] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    $new_row1 = $stmt->fetch(PDO::FETCH_ASSOC);\n    var_dump($new_row1);\n    if (!$db->commit())\n        printf(\"[013] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    if (!($stmt = $db->query(sprintf('SELECT id, label FROM test WHERE id = %d', $row['id']))))\n        printf(\"[014] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    $new_row2 = $stmt->fetch(PDO::FETCH_ASSOC);\n    if ($new_row1 != $new_row2) {\n        printf(\"[015] Results must not differ!\\n\");\n        var_dump($new_row1);\n        var_dump($new_row2);\n    }\n    if (!$db->beginTransaction())\n        printf(\"[016] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    if (1 !== $db->exec(sprintf('DELETE FROM test WHERE id = %d', $row['id'])))\n        printf(\"[017] DELETE should have indicated 1 deleted row, [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    if (!$db->rollback())\n        printf(\"[018] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    if (1 !== $db->getAttribute(PDO::ATTR_AUTOCOMMIT))\n        printf(\"[019] Autocommit should be on after rollback\\n\");\n    if (!($stmt = $db->query(sprintf('SELECT id, label FROM test WHERE id = %d', $row['id']))))\n        printf(\"[020] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    $new_row2 = $stmt->fetch(PDO::FETCH_ASSOC);\n    if ($new_row1 != $new_row2) {\n        printf(\"[021] Results must not differ!\\n\");\n        var_dump($new_row1);\n        var_dump($new_row2);\n    }\n    // now, lets check the server variables\n    if (!($stmt = $db->query('SELECT @@autocommit as auto_commit')))\n        printf(\"[022] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n    if ($tmp['auto_commit'] != 1)\n        printf(\"[023] MySQL Server should indicate autocommit mode, expecting 1, got '%s', [%d] %s\\n\",\n            $tmp['auto_commit'], $stmt->errorCode(), $stmt->errorInfo());\n    if (!$db->beginTransaction())\n        printf(\"[024] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    if (!($stmt = $db->query('SELECT @@autocommit as auto_commit')))\n        printf(\"[025] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n    if ($tmp['auto_commit'] != 0)\n        printf(\"[026] Autocommit mode of the MySQL Server should be off, got '%s', [%d] %s\\n\",\n            $tmp['auto_commit'], $stmt->errorCode(), trim(implode(' ', $stmt->errorInfo())));\n    $db->commit();\n    // Now we should be back to autocommit - we've issues a commit\n    if ($tmp['auto_commit'] != 1)\n        printf(\"[027] MySQL Server should indicate autocommit mode, expecting 1, got '%s', [%d] %s\\n\",\n            $tmp['auto_commit'], $stmt->errorCode(), $stmt->errorInfo());\n    // Turn off autocommit using a server variable\n    $db->exec('SET @@autocommit = 0');\n    if (1 === $db->getAttribute(PDO::ATTR_AUTOCOMMIT))\n        printf(\"[028] I'm confused, how can autocommit be on? Didn't I say I want to manually control transactions?\\n\");\n    if (!$db->beginTransaction())\n        printf(\"[029] Cannot start a transaction, [%d] %s\\n\",\n            $db->errorCode(), implode(' ', $db->errorInfo()));\n    try {\n        if (false !== $db->beginTransaction()) {\n            printf(\"[030] No false and no exception - that's wrong.\\n\");\n        }\n    } catch (PDOException $e) {\n        assert($e->getMessage() != '');\n    }\n    // TODO: What about an engine that does not support transactions?\n    $db = MySQLPDOTest::factory();\n    MySQLPDOTest::createTestTable($db, 'MyISAM');\n    if (false == $db->beginTransaction())\n        printf(\"[031] Cannot start a transaction, [%s] [%s]\\n\",\n            $db->errorCode(), implode(' ', $db->errorInfo()));\n    if (1 !== $db->getAttribute(PDO::ATTR_AUTOCOMMIT))\n        printf(\"[032] Autocommit should be on my default, beginTransaction() should not change that\\n\");\n    if (0 == $db->exec('DELETE FROM test'))\n        printf(\"[033] No rows deleted, can't be true.\\n\");\n    if (!$db->commit())\n        printf(\"[034] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    if (false == $db->beginTransaction())\n        printf(\"[035] Cannot start a transaction, [%s] [%s]\\n\",\n            $db->errorCode(), implode(' ', $db->errorInfo()));\n    if (0 == $db->exec(\"INSERT INTO test(id, label) VALUES (1, 'a')\"))\n        printf(\"[036] Cannot insert data, [%s] [%s]\\n\",\n            $db->errorCode(), implode(' ', $db->errorInfo()));\n    // Should cause a Server warning but no error\n    if (!$db->rollback())\n        printf(\"[037] [%s] %s\\n\", $db->errorCode(), implode(' ', $db->errorInfo()));\n    var_dump($db->errorCode());\n    if (1 != $db->exec('DELETE FROM test'))\n        printf(\"[038] No rows deleted, can't be true.\\n\");\n    print \"done!\";\n?>")).toMatchSnapshot();
  });
});
