// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/utf7imap_encoding.phpt
  it("Exhaustive test of mUTF-7 (IMAP) encoding verification and conversion", function () {
    expect(parser.parseCode("<?php\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\nfunction utf16BE($utf8) {\n\treturn mb_convert_encoding($utf8, 'UTF-16BE', 'UTF-8');\n}\nfunction mBase64($str) {\n\treturn str_replace('=', '', str_replace('/', ',', base64_encode($str)));\n}\nfunction testValid($from, $to, $bothWays = true) {\n\ttestValidString($from, $to, 'UTF7-IMAP', 'UTF-8', $bothWays);\n}\nfunction testInvalid($from, $to) {\n\ttestInvalidString($from, $to, 'UTF7-IMAP', 'UTF-8');\n}\n/* An empty string is valid */\ntestValid(\"\", \"\");\necho \"Identification passes on empty string... good start!\\n\";\n/* Identification and conversion of ASCII characters (minus &) */\nfor ($i = 0x20; $i <= 0x7E; $i++) {\n\tif ($i == 0x26) // '&'\n\t\tcontinue;\n\ttestValid(chr($i), chr($i));\n}\necho \"Testing all valid single-character ASCII strings... check!\\n\";\n/* Identification and conversion of non-ASCII characters */\nfor ($i = 0; $i < 0x20; $i++)\n\ttestInvalid(chr($i), \"%\");\nfor ($i = 0x7F; $i < 256; $i++)\n\ttestInvalid(chr($i), \"%\");\necho \"Non-ASCII characters convert to illegal char marker... yes!\\n\";\n/* Identification of '&' when Base-64 encoded */\ntestValid(\"&\" . mBase64(utf16BE(\"&\")) . \"-\", \"&\", false);\necho \"& can be Base64-encoded... yes!\\n\";\n/* Identification of unterminated & section */\nidentifyInvalidString(\"&\", 'UTF7-IMAP');\nidentifyInvalidString(\"abc&\", 'UTF7-IMAP');\nidentifyInvalidString(\"&\" . mBase64(utf16BE(\"ハムサンドイッチ\")), 'UTF7-IMAP');\necho \"Testing unterminated & sections... yep!\\n\";\n/* Identification of null shifts (& immediately after -)\n *\n * This is illegal according to the spec for mUTF-7 (IMAP), but currently we are letting\n * it pass... among other things, this makes it possible to concatenate UTF-7-IMAP\n * strings naively without the concatenated strings being treated as 'invalid'\n *\n * If ever we want to enforce this part of the spec, uncomment the following test */\n/*\nidentifyInvalidString(\"&\" . mBase64(utf16BE(\"肉包子\")) . \"-&\" . mBase64(utf16BE(\"冰淇淋\")) . \"-\", 'UTF7-IMAP');\necho \"Testing consecutive & sections which should have been merged... yep!\\n\";\n*/\n/* Conversion of Base64-encoded ASCII characters (excluding &)\n * These should be treated as erroneous and mb_substitute_character should apply */\nfor ($i = 0x20; $i <= 0x7E; $i++) {\n\tif ($i == 0x26) // '&'\n\t\tcontinue;\n\ttestInvalid(\"&\" . mBase64(utf16BE(chr($i))) . \"-\", \"%\");\n}\necho \"Testing ASCII characters which are Base64-encoded... great!\\n\";\n/* Conversion of & encoded as &- */\ntestValid(\"&-\", \"&\");\ntestValid(\"abc&-\", \"abc&\");\ntestValid(\"&-.&-\", \"&.&\");\necho \"Testing valid strings which use '&-' for '&'... good!\\n\";\n/* Identification of & sections containing non-Base64 */\n/* We'll use 6 character strings as a test, since 6 UTF-16 characters is just enough\n * to fit perfectly in Base64 encoding, with no padding */\n$testString = mBase64(utf16BE(\"我是打酱油的\"));\nif (strlen($testString) != 16)\n\tdie(\"Erk!!\");\nfor ($i = 0; $i < 256; $i++) {\n\tif ($i >= 0x30 && $i <= 0x39) // '0'..'9'\n\t\tcontinue;\n\tif ($i >= 0x41 && $i <= 0x5A) // 'A'..'Z'\n\t\tcontinue;\n\tif ($i >= 0x61 && $i <= 0x7A) // 'a'..'z'\n\t\tcontinue;\n\tif ($i == 0x2B || $i == 0x2C) // '+' or ','\n\t\tcontinue;\n\tif ($i == 0x2D) // '-'... this will be interpreted as ending the Base64 section\n\t\tcontinue;\n\tidentifyInvalidString(\"&\" . substr($testString, 0, 11) . chr($i) . \"-\", 'UTF7-IMAP');\n}\necho \"Identification fails when Base64 sections contain non-Base64 bytes... right!\\n\";\n/* Tell me, please, how many ways can UTF-16BE text get messed up?\n * Why, that's elementary... */\n/* 1. The second half of a surrogate pair could come first, */\n$testString = mb_convert_encoding(\"\\x00\\x01\\x04\\x00\", 'UTF-16BE', 'UTF-32BE');\nif (strlen($testString) != 4)\n\tdie(\"Ouch!\");\n$testString = substr($testString, 2, 2) . substr($testString, 0, 2);\nidentifyInvalidString(\"&\" . mBase64($testString) . \"-\", 'UTF7-IMAP');\n/* (Or could appear by itself) */\n$testString = substr($testString, 0, 2);\nidentifyInvalidString(\"&\" . mBase64($testString) . \"-\", 'UTF7-IMAP');\n/* ...and we should detect this wherever it occurs */\n$singleChar = mb_convert_encoding(\"１\", 'UTF-16BE', 'ASCII');\n$doubleChar = mb_convert_encoding(\"\\x00\\x01\\x04\\x01\", 'UTF-16BE', 'UTF-32BE');\nif (strlen($doubleChar) != 4)\n\tdie(\"That was supposed to be a surrogate pair\");\nidentifyInvalidString(\"&\" . mBase64($singleChar . $testString) . \"-\", 'UTF7-IMAP');\nidentifyInvalidString(\"&\" . mBase64($singleChar . $singleChar . $testString) . \"-\", 'UTF7-IMAP');\nidentifyInvalidString(\"&\" . mBase64($singleChar . $singleChar . $singleChar . $testString) . \"-\", 'UTF7-IMAP');\nidentifyInvalidString(\"&\" . mBase64($doubleChar . $testString) . \"-\", 'UTF7-IMAP');\nidentifyInvalidString(\"&\" . mBase64($singleChar . $doubleChar . $testString) . \"-\", 'UTF7-IMAP');\nidentifyInvalidString(\"&\" . mBase64($singleChar . $singleChar . $doubleChar . $testString) . \"-\", 'UTF7-IMAP');\n/* 2. The first half of a surrogate pair might be followed by an invalid 2nd part, */\n$testString = mb_convert_encoding(\"\\x00\\x01\\x04\\x00\", 'UTF-16BE', 'UTF-32BE');\n$testString = substr($testString, 0, 2) . mb_convert_encoding(\"a\", 'UTF-16BE', 'ASCII');\nidentifyInvalidString(\"&\" . mBase64($testString) . \"-\", 'UTF7-IMAP');\n/* ...and we should also detect that wherever it occurs... */\nidentifyInvalidString(\"&\" . mBase64($singleChar . $testString) . \"-\", 'UTF7-IMAP');\nidentifyInvalidString(\"&\" . mBase64($singleChar . $singleChar . $testString) . \"-\", 'UTF7-IMAP');\nidentifyInvalidString(\"&\" . mBase64($doubleChar . $testString) . \"-\", 'UTF7-IMAP');\n/* 3. The first half of a surrogate pair could come at the end of the string, */\n$testString = mb_convert_encoding(\"\\x00\\x01\\x04\\x00\", 'UTF-16BE', 'UTF-32BE');\nidentifyInvalidString(\"&\" . mBase64(substr($testString, 0, 2)) . \"-\", 'UTF7-IMAP');\nidentifyInvalidString(\"&\" . mBase64($singleChar . substr($testString, 0, 2)) . \"-\", 'UTF7-IMAP');\nidentifyInvalidString(\"&\" . mBase64($singleChar . $singleChar . substr($testString, 0, 2)) . \"-\", 'UTF7-IMAP');\n/* 4. Or, it could have an odd number of bytes in it! */\n$testString = utf16BE(\"ドーナツ\");\n$testString = substr($testString, 0, strlen($testString) - 1);\nidentifyInvalidString(\"&\" . mBase64($testString) . \"-\", 'UTF7-IMAP');\n/* And there is one bonus way to discombobulate your UTF-16BE when it is Base64-encoded...\n * The Base64 might not decode to an integral number of bytes\n * Or, equivalently... it might not be padded with zeroes (as the RFC requires) */\n$testString = utf16BE(\"☺⛑\");\nif (strlen($testString) != 4)\n\tdie(\"No good\");\n$encoded = mBase64($testString);\nif (strlen($encoded) != 6)\n\tdie(\"Don't like that\");\n/* Mess up the padding by replacing the last Base64 character with ',',\n * which represents 63 (a number with a 1 in the last bit) */\nidentifyInvalidString(\"&\" . substr($encoded, 0, strlen($encoded) - 1) . \",-\", 'UTF7-IMAP');\necho \"Identification fails when UTF-16 text is invalid... no sweat!\\n\";\n/* OK, let's try valid Base64-encoded text now */\n/* 2-byte char */\ntestValid(\"&\" . mBase64(utf16BE(\"☺\")) . \"-\", \"☺\");\n/* 2 + 2 */\ntestValid(\"&\" . mBase64(utf16BE(\"饺子\")) . \"-\", \"饺子\");\n/* 2 + 2 + 2 */\ntestValid(\"&\" . mBase64(utf16BE(\"１２３\")) . \"-\", \"１２３\");\n/* 2 + 2 + 2 + 2 */\ntestValid(\"&\" . mBase64(utf16BE(\"ﾰﾱﾲﾳ\")) . \"-\", \"ﾰﾱﾲﾳ\");\n/* 4 */\n$longChar1 = mb_convert_encoding(\"\\x00\\x01\\x04\\x01\", 'UTF-16BE', 'UTF-32BE');\n$longChar2 = mb_convert_encoding(\"\\x00\\x01\\x04\\x01\", 'UTF-8', 'UTF-32BE');\ntestValid(\"&\" . mBase64($longChar1) . \"-\", $longChar2);\n/* 2 + 4 */\ntestValid(\"&\" . mBase64(utf16BE(\"饼\") . $longChar1) . \"-\", \"饼\" . $longChar2);\n/* 4 + 2 */\ntestValid(\"&\" . mBase64($longChar1 . utf16BE(\"饼\")) . \"-\", $longChar2 . \"饼\");\n/* 2 + 4 + 2 */\ntestValid(\"&\" . mBase64(utf16BE(\"☺\") . $longChar1 . utf16BE(\"饼\")) . \"-\", \"☺\" . $longChar2 . \"饼\");\n/* 2 + 2 + 4 */\ntestValid(\"&\" . mBase64(utf16BE(\"西瓜\") . $longChar1) . \"-\", \"西瓜\" . $longChar2);\n/* 2 + 2 + 4 + 2 */\ntestValid(\"&\" . mBase64(utf16BE(\"西瓜\") . $longChar1 . utf16BE(\"☺\")) . \"-\", \"西瓜\" . $longChar2 . \"☺\");\n/* 2 + 2 + 4 + 4 */\ntestValid(\"&\" . mBase64(utf16BE(\"西瓜\") . $longChar1 . $longChar1) . \"-\", \"西瓜\" . $longChar2 . $longChar2);\n/* 2 + 2 + 2 + 4 */\ntestValid(\"&\" . mBase64(utf16BE(\"西红柿\") . $longChar1) . \"-\", \"西红柿\" . $longChar2);\n/* Multiple sections of valid ASCII _and_ Base64-encoded text */\ntestValid(\"123&\" . mBase64(utf16BE(\"１２３\")) . \"-abc&\" . mBase64(utf16BE(\"☺\")) . \"-.\", \"123１２３abc☺.\");\n/* If a & character appears right after a non-ASCII character, we must first close the Base64\n * section and then emit &- */\ntestValidString(\"☺&\", \"&Jjo-&-\", \"UTF-8\", \"UTF7-IMAP\", false);\ntestValidString(\"西瓜&\", \"&iX903A-&-\", \"UTF-8\", \"UTF7-IMAP\", false);\ntestValidString(\"西红柿&\", \"&iX9+omf,-&-\", \"UTF-8\", \"UTF7-IMAP\", false);\necho \"Identification and conversion of valid text is working... perfect!\\n\";\n// Try illegal Unicode codepoint (> 0x10FFFF)\nconvertInvalidString(\"\\x00\\x20\\x00\\x00\", \"%\", \"UCS-4BE\", \"UTF7-IMAP\");\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\x10\", \"%\", \"UTF7-IMAP\", \"UTF-8\");\nconvertInvalidString(\"\\x80\", \"%\", \"UTF7-IMAP\", \"UTF-8\");\nconvertInvalidString(\"abc&\", \"abc%\", \"UTF7-IMAP\", \"UTF-8\"); // The & starts a Base-64 coded section, which is OK... but there's no data in it\nconvertInvalidString(\"&**-\", \"%*-\", \"UTF7-IMAP\", \"UTF-8\"); // When we hit the first bad byte in a Base-64 coded section, it drops us back into the default mode, so the following characters are literal\necho \"Done!\\n\";\n?>")).toMatchSnapshot();
  });
});
