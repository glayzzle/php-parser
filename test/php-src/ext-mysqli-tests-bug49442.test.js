// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mysqli/tests/bug49442.phpt
  it("Bug #49422 (mysqlnd: mysqli_real_connect() and LOAD DATA INFILE crash)", function () {
    expect(parser.parseCode("<?php\n    include (\"connect.inc\");\n    $link = mysqli_init();\n    if (!my_mysqli_real_connect($link, $host, $user, $passwd, $db, $port, $socket)) {\n        printf(\"[001] Connect failed, [%d] %s\\n\", mysqli_connect_errno(), mysqli_connect_error());\n    }\n    if (!mysqli_query($link, 'DROP TABLE IF EXISTS test')) {\n        printf(\"[002] Failed to drop old test table: [%d] %s\\n\", mysqli_errno($link), mysqli_error($link));\n    }\n    if (!mysqli_query($link, 'CREATE TABLE test(id INT, label CHAR(1), PRIMARY KEY(id)) ENGINE=' . $engine)) {\n        printf(\"[003] Failed to create test table: [%d] %s\\n\", mysqli_errno($link), mysqli_error($link));\n    }\n    include(\"local_infile_tools.inc\");\n    $file = create_standard_csv(4);\n    if (!@mysqli_query($link, sprintf(\"LOAD DATA LOCAL INFILE '%s'\n            INTO TABLE test\n            FIELDS TERMINATED BY ';' OPTIONALLY ENCLOSED BY '\\''\n            LINES TERMINATED BY '\\n'\",\n            mysqli_real_escape_string($link, $file)))) {\n            printf(\"[005] [%d] %s\\n\",  mysqli_errno($link), mysqli_error($link));\n    }\n    if (!$res = mysqli_query($link, \"SELECT * FROM test ORDER BY id\"))\n        printf(\"[006] [%d] %s\\n\",  mysqli_errno($link), mysqli_error($link));\n    $rows = array();\n    while ($row = mysqli_fetch_assoc($res)) {\n        var_dump($row);\n        $rows[] = $row;\n    }\n    mysqli_free_result($res);\n    mysqli_query($link, \"DELETE FROM test\");\n    mysqli_close($link);\n    if ($IS_MYSQLND) {\n        /*\n            mysqlnd makes a connection created through mysql_init()/mysqli_real_connect() always a 'persistent' one.\n            At this point 'persistent' is not to be confused with what a user calls a 'persistent' - in this case\n            'persistent' means that mysqlnd uses malloc() instead of emalloc(). nothing else. ext/mysqli will\n            not consider it as a 'persistent' connection in a user sense, ext/mysqli will not apply max_persistent etc.\n            Its only about malloc() vs. emalloc().\n            However, the bug is about malloc() and efree(). You can make make mysqlnd use malloc() by either using\n            pconnect or mysql_init() - so we should test pconnect as well..\n        */\n        $host = 'p:' . $host;\n        if (!$link = my_mysqli_connect($host, $user, $passwd, $db, $port, $socket)) {\n            printf(\"[007] Connect failed, [%d] %s\\n\", mysqli_connect_errno(), mysqli_connect_error());\n        }\n        /* bug happened during query processing */\n        if (!@mysqli_query($link, sprintf(\"LOAD DATA LOCAL INFILE '%s'\n            INTO TABLE test\n            FIELDS TERMINATED BY ';' OPTIONALLY ENCLOSED BY '\\''\n            LINES TERMINATED BY '\\n'\",\n            mysqli_real_escape_string($link, $file)))) {\n            printf(\"[008] [%d] %s\\n\",  mysqli_errno($link), mysqli_error($link));\n        }\n        /* we survived? that's good enough... */\n        if (!$res = mysqli_query($link, \"SELECT * FROM test ORDER BY id\"))\n            printf(\"[009] [%d] %s\\n\",  mysqli_errno($link), mysqli_error($link));\n        $i = 0;\n        while ($row = mysqli_fetch_assoc($res)) {\n            if (($row['id'] != $rows[$i]['id']) || ($row['label'] != $rows[$i]['label'])) {\n                printf(\"[010] Wrong values, check manually!\\n\");\n            }\n            $i++;\n        }\n        mysqli_close($link);\n    }\n    print \"done!\";\n?>")).toMatchSnapshot();
  });
});
