// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/hz_encoding.phpt
  it("Exhaustive test of verification and conversion of HZ text", function () {
    expect(parser.parseCode("<?php\ninclude('encoding_tests.inc');\nsrand(1000); // Make results consistent\nmb_substitute_character(0x25); // '%'\nfor ($i = 0; $i < 0x80; $i++) {\n    if ($i != 0x7E) // ~ is special and will be tested separately\n        testValidString(chr($i), chr($i), 'ASCII', 'HZ');\n}\necho \"Tested ASCII -> HZ\\n\";\nfor ($i = 0; $i < 0x80; $i++) {\n    if ($i != 0x7E)\n        testValidString(chr($i), chr($i), 'HZ', 'ASCII');\n}\necho \"Tested HZ -> ASCII\\n\";\nfor ($i = 0x80; $i < 0xFF; $i++) {\n    testInvalidString(chr($i), '%', 'HZ', 'ASCII');\n}\necho \"Tested non-ASCII bytes in ASCII mode\\n\";\ntestValidString('~~', '~', 'HZ', 'ASCII');\ntestValidString(\"~\\n\", '', 'HZ', 'ASCII', false);\ntestValidString('~{~}', '', 'HZ', 'ASCII', false);\ntestValidString(\"~{~\\n~}\", '', 'HZ', 'ASCII', false);\necho \"Tested valid ~ escapes\\n\";\nfor ($i = 0; $i < 0xFF; $i++) {\n    if ($i != 0x0A) {\n        // Try invalid ~ escapes both in ASCII and GB modes\n        if ($i != 0x7E && $i != 0x7B) // not {\n            testInvalidString(\"~\" . chr($i), '%', 'HZ', 'ASCII');\n        if ($i != 0x7D) // not }\n            testInvalidString(\"~{~\" . chr($i) . \"~}\", '%', 'HZ', 'ASCII');\n    }\n}\necho \"Tested all invalid ~ escapes\\n\";\nreadConversionTable(__DIR__ . '/data/GB2312.txt', $toUnicode, $fromUnicode);\nfindInvalidChars($toUnicode, $invalid, $truncated);\n// Two characters in ISO-2022-CN convert to Unicode 0x2225\n$irreversible = [\"\\x21\\x2C\" => true];\n// Test all good GB2312 characters within ~{ ~} escapes\n$goodChars = array_keys($toUnicode);\nshuffle($goodChars);\nwhile (!empty($goodChars)) {\n    $reversible = true;\n    $length = 1; //min(rand(5,10), count($goodChars));\n    $fromString = $toString = '';\n    while ($length--) {\n        $goodChar = array_pop($goodChars);\n        $fromString .= $goodChar;\n        $toString .= $toUnicode[$goodChar];\n        if (isset($irreversible[$goodChar]))\n          $reversible = false;\n    }\n    testValidString('~{' . $fromString . '~}', $toString, 'HZ', 'UTF-16BE', $reversible);\n}\n// Test all invalid GB2312 characters within ~{ ~} escapes\n// However, don't test escape sequences; we will do those separately below\nunset($invalid[\"~\"]);\n$badChars = array_keys($invalid);\n$goodChars = array();\nwhile (!empty($badChars)) {\n    if (empty($goodChars)) {\n        $goodChars = array_keys($toUnicode);\n        shuffle($goodChars);\n    }\n    $goodChar   = array_pop($goodChars);\n    $fromString = array_pop($badChars) . $goodChar;\n    $toString   = \"\\x00%\" . $toUnicode[$goodChar];\n    testInvalidString('~{' . $fromString . '~}', $toString, 'HZ', 'UTF-16BE');\n}\n$truncatedChars = array_keys($truncated);\nforeach ($truncatedChars as $truncatedChar) {\n    testInvalidString('~{' . $truncatedChar, \"\\x00%\", 'HZ', 'UTF-16BE');\n}\necho \"Tested HZ -> UTF-16BE (for all GB2312 characters)\\n\";\nfindInvalidChars($fromUnicode, $invalid, $unused, array_fill_keys(range(0,0xFF), 2));\n// Although they do not appear in the Unicode -> GB2312 map, ASCII characters *are*\n// valid to convert to HZ\nfor ($i = 0; $i <= 0x7F; $i++)\n    unset($invalid[\"\\x00\" . chr($i)]);\n$badChars = array_keys($invalid);\n$goodChars = array();\nwhile (!empty($badChars)) {\n    if (empty($goodChars)) {\n        $goodChars = array_keys($fromUnicode);\n        shuffle($goodChars);\n    }\n    $goodChar   = array_pop($goodChars);\n    $fromString = array_pop($badChars) . $goodChar;\n    $toString   = \"%~{\" . $fromUnicode[$goodChar] . \"~}\";\n    convertInvalidString($fromString, $toString, 'UTF-16BE', 'HZ');\n}\necho \"Tested UTF-16BE -> HZ (for all GB2312 characters)\\n\";\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"~A\", \"%\", \"HZ\", \"UTF-8\");\nconvertInvalidString(\"\\x80\", \"%\", \"HZ\", \"UTF-8\");\nconvertInvalidString(\"~{\\x22\\x21\", \"%\", \"HZ\", \"UTF-8\");\necho \"Done!\\n\";\n?>")).toMatchSnapshot();
  });
});
