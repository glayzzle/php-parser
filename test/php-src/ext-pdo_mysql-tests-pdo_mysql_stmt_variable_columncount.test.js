// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_mysql/tests/pdo_mysql_stmt_variable_columncount.phpt
  it("MySQL Prepared Statements and different column counts", function () {
    expect(parser.parseCode("<?php\n    require_once(__DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');\n    $db = MySQLPDOTest::factory();\n    function check_result($offset, $stmt, $columns) {\n        $row = $stmt->fetch(PDO::FETCH_ASSOC);\n        $stmt->nextRowSet();\n        if (!isset($row['one']) || ($row['one'] != 1)) {\n                printf(\"[%03d + 1] Expecting array('one' => 1), got %s\\n\", $offset, var_export($row, true));\n                return false;\n        }\n        if (($columns == 2) &&\n            (!isset($row['two']) || ($row['two'] != 2))) {\n                printf(\"[%03d + 2] Expecting array('one' => 1, 'two' => 2), got %s\\n\", $offset, var_export($row, true));\n                return false;\n        } else if (($columns == 1) && isset($row['two'])) {\n                printf(\"[%03d + 3] Expecting one array element got two\\n\", $offset);\n                return false;\n        }\n        return true;\n    }\n    try {\n        // What will happen if a PS returns a different number of result set column upon each execution?\n        // Lets try with a SP accepting parameters...\n        $db->exec('DROP PROCEDURE IF EXISTS p');\n        $db->exec('CREATE PROCEDURE p(IN cols INT) BEGIN IF cols < 2 THEN SELECT cols AS \"one\"; ELSE SELECT 1 AS \"one\", cols AS \"two\"; END IF; END;');\n        // Emulates PS first\n        $db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);\n        $stmt = $db->prepare('CALL p(?)');\n        $columns = null;\n        $stmt->bindParam(1, $columns);\n        for ($i = 0; $i < 5; $i++) {\n            $columns = ($i % 2) + 1;\n            $stmt->execute();\n            check_result($i, $stmt, $columns);\n        }\n        if (MySQLPDOTest::isPDOMySQLnd()) {\n            // Native PS\n            // Libmysql cannot handle such a stored procedure. You will see leaks with libmysql\n            $db = MySQLPDOTest::factory();\n            $db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);\n            $db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 1);\n            $stmt = $db->prepare('CALL p(?)');\n            $stmt->bindParam(1, $columns);\n            for ($i = 5; $i < 10; $i++) {\n                $columns = ($i % 2) + 1;\n                $stmt->execute();\n                check_result($i, $stmt, $columns);\n            }\n        }\n        // And now without parameters... - this gives a different control flow inside PDO\n        $db->exec('DROP PROCEDURE IF EXISTS p');\n        $db->exec('CREATE PROCEDURE p() BEGIN DECLARE cols INT; SELECT @numcols INTO cols; IF cols < 2 THEN SET @numcols = 2; SELECT cols AS \"one\"; ELSE SET @numcols = 1; SELECT 1 AS \"one\", cols AS \"two\"; END IF; END;');\n                // Emulates PS first\n        $db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 1);\n        $db->exec('SET @numcols = 1');\n        $stmt = $db->prepare('CALL p()');\n        $stmt->execute();\n        check_result(11, $stmt, 1);\n        $stmt->execute();\n        check_result(12, $stmt, 2);\n        $db->exec('SET @numcols = 1');\n        $stmt->execute();\n        check_result(13, $stmt, 1);\n        if (MySQLPDOTest::isPDOMySQLnd()) {\n            // Native PS\n            // Libmysql cannot handle such a stored procedure. You will see leaks with libmysql\n            $db = MySQLPDOTest::factory();\n            $db->setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);\n            $db->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 1);\n            $db->exec('SET @numcols = 1');\n            $stmt = $db->prepare('CALL p()');\n            $stmt->execute();\n            check_result(14, $stmt, 1);\n            $stmt->execute();\n            check_result(15, $stmt, 2);\n            $db->exec('SET @numcols = 1');\n            $stmt->execute();\n            check_result(16, $stmt, 1);\n        }\n    } catch (PDOException $e) {\n        printf(\"[99] %s [%s] %s\\n\",\n            $e->getMessage(), $db->errorCode(), implode(' ', $db->errorInfo()));\n    }\n    print \"done!\";\n?>")).toMatchSnapshot();
  });
});
