// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/sjis_mobile_encodings.phpt
  it("Exhaustive test of Shift-JIS DoCoMo, KDDI, SoftBank encoding verification and conversion", function () {
    expect(parser.parseCode("<?php\nsrand(818); /* Make results consistent */\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\n/* Read in the table of all characters in Windows-932\n * (The SJIS-Mobile encodings all use MS extensions) */\nreadConversionTable(__DIR__ . '/data/CP932.txt', $sjisChars, $fromUnicode, true);\n/* U+301C (WAVE DASH) converts to SJIS 0x8160 (WAVE DASH) */\n$fromUnicode[\"\\x00\\x00\\x30\\x1C\"] = \"\\x81\\x60\";\n/* U+2212 (MINUS SIGN) converts to SJIS 0x817C (FULLWIDTH HYPHEN-MINUS) */\n$fromUnicode[\"\\x00\\x00\\x22\\x12\"] = \"\\x81\\x7C\";\n/* U+203E (OVERLINE) converts to SJIS 0x8150 (FULLWIDTH MACRON) */\n$fromUnicode[\"\\x00\\x00\\x20\\x3E\"] = \"\\x81\\x50\";\n/* U+2016 (DOUBLE VERTICAL LINE) converts to SJIS 0x8161 (PARALLEL TO) */\n$fromUnicode[\"\\x00\\x00\\x20\\x16\"] = \"\\x81\\x61\";\n/* U+00AF (MACRON) converts to SJIS 0x8150 (FULLWIDTH MACRON) */\n$fromUnicode[\"\\x00\\x00\\x00\\xAF\"] = \"\\x81\\x50\";\n/* U+00AC (NOT SIGN) converts to SJIS 0x81CA (FULLWIDTH NOT SIGN) */\n$fromUnicode[\"\\x00\\x00\\x00\\xAC\"] = \"\\x81\\xCA\";\n/* U+00A5 (YEN SIGN) converts to SJIS 0x818F (FULLWIDTH YEN SIGN) */\n$fromUnicode[\"\\x00\\x00\\x00\\xA5\"] = \"\\x81\\x8F\";\n/* U+00A3 (POUND SIGN) converts to SJIS 0x8192 (FULLWIDTH POUND SIGN) */\n$fromUnicode[\"\\x00\\x00\\x00\\xA3\"] = \"\\x81\\x92\";\n/* U+00A2 (CENT SIGN) converts to SJIS 0x8191 (FULLWIDTH CENT SIGN) */\n$fromUnicode[\"\\x00\\x00\\x00\\xA2\"] = \"\\x81\\x91\";\n/* Aside from the characters in that table, we also support a 'user' area\n * from 0xF040-0xF9FC, which map to Unicode 'private' codepoints 0xE000-E757 */\n$codepoint = 0xE000;\nfor ($i = 0xF0; $i <= 0xF9; $i++) {\n  for ($j = 0x40; $j <= 0xFC; $j++) {\n    if ($j == 0x7F)\n      continue;\n    $utf32 = pack('N', $codepoint);\n    $cp932 = chr($i) . chr($j);\n    $sjisChars[$cp932] = $utf32;\n    $fromUnicode[$utf32] = $cp932;\n    $codepoint++;\n  }\n}\n$invalidCodepoints = array();\nfor ($i = 0; $i <= 0xFFFF; $i++) {\n  $cp = pack('N', $i);\n  if (!isset($fromUnicode[$cp]))\n    $invalidCodepoints[$cp] = true;\n}\n/* Windows-932 has many cases where two different kuten codes map to the same\n * Unicode codepoints\n *\n * Everything from 0xED00-0xEEFF falls in this unfortunate category\n * (Other sequences in 0xFA00-0xFC4B map to the same codepoints.)\n * Our implementation of CP932 prefers the F's, but for SJIS-Mobile,\n * we prefer the E's */\n$nonInvertible = array();\nfor ($i = 0xFA00; $i <= 0xFC4B; $i++) {\n  $bytes = pack('n', $i);\n  if (isset($sjisChars[$bytes])) {\n    $nonInvertible[$bytes] = $sjisChars[$bytes];\n    unset($fromUnicode[$sjisChars[$bytes]]);\n  }\n}\n/* Other \"collisions\" */\nforeach ([0x8790, 0x8791, 0x8792, 0x8795, 0x8796, 0x8797, 0x879A, 0x879B, 0x879C, 0xEEF9] as $i) {\n  $bytes = pack('n', $i);\n  $nonInvertible[$bytes] = $sjisChars[$bytes];\n  unset($fromUnicode[$sjisChars[$bytes]]);\n}\n$nonInvertibleSoftbank = $nonInvertible;\n$nonInvertibleDocomo   = $nonInvertible;\n/* Now read table of vendor-specific emoji encodings */\n$docomo = $sjisChars;\n$kddi = $sjisChars;\n$softbank = $sjisChars;\n$sbEmoji = array();\n$fp = fopen(realpath(__DIR__ . '/data/EmojiSources.txt'), 'r+');\nwhile ($line = fgets($fp, 256)) {\n  if ($line[0] == '#')\n    continue;\n  $fields = explode(';', rtrim($line));\n  if (count($fields) >= 4) {\n    if (sscanf($fields[0], \"%x %x\", $cp1, $cp2) == 2) {\n      $utf32 = pack('N', $cp1) . pack('N', $cp2);\n    } else {\n      $utf32 = pack('N', hexdec($fields[0]));\n      unset($invalidCodepoints[$utf32]);\n    }\n    if ($fields[1])\n      $docomo[pack('n', hexdec($fields[1]))] = $utf32;\n    if ($fields[2])\n      $kddi[pack('n', hexdec($fields[2]))] = $utf32;\n    if ($fields[3]) {\n      $bytes = pack('n', hexdec($fields[3]));\n      $sbEmoji[$bytes] = $utf32;\n      unset($nonInvertibleSoftbank[$bytes]);\n    }\n  }\n}\n/* Other, vendor-specific emoji which do not appear in EmojiSources.txt\n * Most of these don't exist in Unicode and have been mapped to 'private\n * area' codepoints */\n$docomo[\"\\xF9\\x4A\"] = \"\\x00\\x0F\\xEE\\x16\"; // PIAS PI\n$docomo[\"\\xF9\\x4B\"] = \"\\x00\\x0F\\xEE\\x17\"; // PIAS A\n$docomo[\"\\xF9\\x4C\"] = \"\\x00\\x0F\\xEE\\x18\"; // INVERSE TICKET\n$docomo[\"\\xF9\\x4D\"] = \"\\x00\\x0F\\xEE\\x19\"; // KATAKANA ABBREVIATION FOR TICKET (\"chi ke\")\n$docomo[\"\\xF9\\x4E\"] = \"\\x00\\x0F\\xEE\\x1A\"; // RESERVE BY PHONE\n$docomo[\"\\xF9\\x4F\"] = \"\\x00\\x0F\\xEE\\x1B\"; // P CODE\n$docomo[\"\\xF9\\x53\"] = \"\\x00\\x0F\\xEE\\x1C\"; // MOVIES 2\n$docomo[\"\\xF9\\x54\"] = \"\\x00\\x0F\\xEE\\x1D\"; // PIAS PI INVERSE\n$docomo[\"\\xF9\\x58\"] = \"\\x00\\x0F\\xEE\\x1E\"; // PIAS PI CIRCLE\n$docomo[\"\\xF9\\x59\"] = \"\\x00\\x0F\\xEE\\x1F\"; // PIAS PI SQUARE\n$docomo[\"\\xF9\\x5A\"] = \"\\x00\\x0F\\xEE\\x20\"; // CHECK\n$docomo[\"\\xF9\\x5F\"] = \"\\x00\\x0F\\xEE\\x21\"; // F\n$docomo[\"\\xF9\\x60\"] = \"\\x00\\x0F\\xEE\\x22\"; // D\n$docomo[\"\\xF9\\x61\"] = \"\\x00\\x0F\\xEE\\x23\"; // S\n$docomo[\"\\xF9\\x62\"] = \"\\x00\\x0F\\xEE\\x24\"; // C\n$docomo[\"\\xF9\\x63\"] = \"\\x00\\x0F\\xEE\\x25\"; // R\n$docomo[\"\\xF9\\x64\"] = \"\\x00\\x00\\x25\\xEA\"; // SQUARE WITH LOWER RIGHT DIAGONAL HALF BLACK\n$nonInvertibleDocomo[\"\\xF9\\x64\"] = \"\\x00\\x00\\x25\\xEA\";\n$docomo[\"\\xF9\\x65\"] = \"\\x00\\x00\\x25\\xA0\"; // BLACK SQUARE\n$nonInvertibleDocomo[\"\\xF9\\x65\"] = \"\\x00\\x00\\x25\\xA0\";\n$docomo[\"\\xF9\\x66\"] = \"\\x00\\x00\\x25\\xBF\"; // DOWNWARD TRIANGLE\n$nonInvertibleDocomo[\"\\xF9\\x66\"] = \"\\x00\\x00\\x25\\xBF\";\n/* TODO: test that FEE28 converts to F966, for backwards compatibility */\n$docomo[\"\\xF9\\x67\"] = \"\\x00\\x0F\\xEE\\x29\"; // QUADRUPLE DAGGER\n$docomo[\"\\xF9\\x68\"] = \"\\x00\\x0F\\xEE\\x2A\"; // TRIPLE DAGGER\n$docomo[\"\\xF9\\x69\"] = \"\\x00\\x0F\\xEE\\x2B\"; // DOUBLE DAGGER\n$docomo[\"\\xF9\\x6A\"] = \"\\x00\\x00\\x20\\x20\"; // DAGGER\n$nonInvertibleDocomo[\"\\xF9\\x6A\"] = \"\\x00\\x00\\x20\\x20\";\n/* TODO: test that FEE2C converts to F96A, for backwards compatibility */\n$docomo[\"\\xF9\\x6B\"] = \"\\x00\\x0F\\xEE\\x2D\"; // I (meaning \"inexpensive\")\n$docomo[\"\\xF9\\x6C\"] = \"\\x00\\x0F\\xEE\\x2E\"; // M (meaning \"moderate\")\n$docomo[\"\\xF9\\x6D\"] = \"\\x00\\x0F\\xEE\\x2F\"; // E (meaning \"expensive\")\n$docomo[\"\\xF9\\x6E\"] = \"\\x00\\x0F\\xEE\\x30\"; // VE (meaning \"very expensive\")\n$docomo[\"\\xF9\\x6F\"] = \"\\x00\\x0F\\xEE\\x31\"; // SPHERE\n$docomo[\"\\xF9\\x70\"] = \"\\x00\\x0F\\xEE\\x32\"; // CREDIT CARDS NOT ACCEPTED\n$docomo[\"\\xF9\\x71\"] = \"\\x00\\x0F\\xEE\\x33\"; // CHECKBOX\n$docomo[\"\\xF9\\x75\"] = \"\\x00\\x0F\\xEE\\x10\"; // I-MODE\n$docomo[\"\\xF9\\x76\"] = \"\\x00\\x0F\\xEE\\x11\"; // I-MODE WITH FRAME\n$docomo[\"\\xF9\\x78\"] = \"\\x00\\x0F\\xEE\\x12\"; // PROVIDED BY DOCOMO\n$docomo[\"\\xF9\\x79\"] = \"\\x00\\x0F\\xEE\\x13\"; // DOCOMO POINT\n$docomo[\"\\xF9\\x84\"] = \"\\x00\\x00\\x27\\xBF\"; // FREE DIAL; mapped to DOUBLE CURLY LOOP\nunset($invalidCodepoints[\"\\x00\\x00\\x27\\xBF\"]);\n$docomo[\"\\xF9\\x86\"] = \"\\x00\\x0F\\xE8\\x2D\"; // MOBILE Q\n$docomo[\"\\xF9\\xB1\"] = \"\\x00\\x0F\\xEE\\x14\"; // I-APPLI\n$docomo[\"\\xF9\\xB2\"] = \"\\x00\\x0F\\xEE\\x15\"; // I-APPLI WITH BORDER\n$kddi[\"\\xF7\\x94\"] = \"\\x00\\x0F\\xEE\\x40\"; // EZ WEB\n$kddi[\"\\xF7\\xCF\"] = \"\\x00\\x0F\\xEE\\x41\"; // EZ PLUS\n$kddi[\"\\xF3\\x70\"] = \"\\x00\\x0F\\xEE\\x42\"; // EZ NAVIGATION\n$kddi[\"\\xF4\\x78\"] = \"\\x00\\x0F\\xEE\\x43\"; // EZ MOVIE\n$kddi[\"\\xF4\\x86\"] = \"\\x00\\x0F\\xEE\\x44\"; // CMAIL\n$kddi[\"\\xF4\\x8E\"] = \"\\x00\\x0F\\xEE\\x45\"; // JAVA (TM)\n$kddi[\"\\xF4\\x8F\"] = \"\\x00\\x0F\\xEE\\x46\"; // BREW\n$kddi[\"\\xF4\\x90\"] = \"\\x00\\x0F\\xEE\\x47\"; // EZ RING MUSIC\n$kddi[\"\\xF4\\x91\"] = \"\\x00\\x0F\\xEE\\x48\"; // EZ NAVI\n$kddi[\"\\xF4\\x92\"] = \"\\x00\\x0F\\xEE\\x49\"; // WIN\n$kddi[\"\\xF4\\x93\"] = \"\\x00\\x0F\\xEE\\x4A\"; // PREMIUM SIGN\n$kddi[\"\\xF7\\x48\"] = \"\\x00\\x0F\\xE8\\x2D\"; // MOBILE Q\n$kddi[\"\\xF7\\xA3\"] = \"\\x00\\x0F\\xE8\\x3C\"; // PDC (\"personal digital cellular\")\n$kddi[\"\\xF7\\xD2\"] = \"\\x00\\x0F\\xEB\\x89\"; // OPENWAVE\n$sbEmoji[\"\\xF7\\xB1\"] = \"\\x00\\x00\\x27\\xBF\"; // FREE DIAL; mapped to DOUBLE CURLY\n$sbEmoji[\"\\xF7\\xF4\"] = \"\\x00\\x0F\\xEE\\x77\"; // J-PHONE SHOP\n$sbEmoji[\"\\xF7\\xF5\"] = \"\\x00\\x0F\\xEE\\x78\"; // SKY WEB\n$sbEmoji[\"\\xF7\\xF6\"] = \"\\x00\\x0F\\xEE\\x79\"; // SKY WALKER\n$sbEmoji[\"\\xF7\\xF7\"] = \"\\x00\\x0F\\xEE\\x7A\"; // SKY MELODY\n$sbEmoji[\"\\xF7\\xF8\"] = \"\\x00\\x0F\\xEE\\x7B\"; // J-PHONE 1\n$sbEmoji[\"\\xF7\\xF9\"] = \"\\x00\\x0F\\xEE\\x7C\"; // J-PHONE 2\n$sbEmoji[\"\\xF7\\xFA\"] = \"\\x00\\x0F\\xEE\\x7D\"; // J-PHONE 3\n/* SoftBank-specific 'JSky1', 'JSky2', 'VODAFONE1', 'VODAFONE2', etc. emoji,\n * which are not supported by Unicode */\nfor ($i = 0xFBD8; $i <= 0xFBDE; $i++) {\n  $bytes = pack('n', $i);\n  $sbEmoji[$bytes] = pack('N', 0xFEE70 + $i - 0xFBD8);\n  unset($nonInvertibleSoftbank[$bytes]);\n}\n/* SoftBank-specific emoji for Shibuya department store */\n$sbEmoji[\"\\xFB\\xAA\"] = \"\\x00\\x0F\\xE4\\xC5\";\nunset($nonInvertibleSoftbank[\"\\xFB\\xAA\"]);\n$softbank = array_merge($softbank, $sbEmoji);\n/* For Softbank, we support an alternative representation for emoji which\n * uses sequences starting with ESC. Apparently this was used in older\n * versions of Softbank's phones.\n * ESC could be followed by 6 different ASCII characters, each of which\n * represented a different ku code */\n$escCodeToKu = array('G' => 0x91, 'E' => 0x8D, 'F' => 0x8E, 'O' => 0x92, 'P' => 0x95, 'Q' => 0x96);\n$escCodeMaxTen = array('G' => 0x7A, 'E' => 0x7A, 'F' => 0x7A, 'O' => 0x6D, 'P' => 0x6C, 'Q' => 0x5E);\nfunction shiftJISEncode($ku, $ten) {\n  $ku -= 0x21;\n  $ten -= 0x21;\n  $hiBits = $ku >> 1;\n  $loBit  = $ku % 2;\n  if ($hiBits < 31) {\n    $sjis = chr($hiBits + 0x81);\n  } else {\n    $sjis = chr($hiBits - 31 + 0xE0);\n  }\n  if ($loBit == 0) {\n    if ($ten < 63)\n      return $sjis . chr($ten + 0x40);\n    else\n      return $sjis . chr($ten - 63 + 0x80);\n  } else {\n    return $sjis . chr($ten + 0x9F);\n  }\n}\nforeach ($escCodeToKu as $char => $ku) {\n  for ($ten = 0x21; $ten <= $escCodeMaxTen[$char]; $ten++) {\n    $sjis = shiftJISEncode($ku, $ten);\n    if (isset($sbEmoji[$sjis])) {\n      $bytes = \"\\x1B\\$\" . $char . chr($ten);\n      $unicode = $softbank[$sjis];\n      $nonInvertibleSoftbank[$bytes] = $softbank[$bytes] = $unicode;\n    }\n  }\n}\n/* A bare ESC is not valid for Softbank, since it is used for escape sequences\n * which represent emoji */\nunset($softbank[\"\\x1B\"]);\nfunction testSJISVariant($validChars, $nonInvertible, $encoding) {\n  global $fromUnicode, $invalidCodepoints, $escCodeToKu;\n  $lenTable = array_fill_keys(range(0xE0, 0xFC), 2) + array_fill_keys(range(0x81, 0x9F), 2);\n  findInvalidChars($validChars, $invalidChars, $truncated, $lenTable);\n  foreach ($escCodeToKu as $char => $unused) {\n    unset($invalidChars[\"\\x1B\\$\" . $char . \"\\x0F\"]);\n    unset($truncated[\"\\x1B\\$\" . $char]);\n  }\n  $escapes = [];\n  foreach ($nonInvertible as $bytes => $unicode) {\n    unset($validChars[$bytes]);\n    if (substr($bytes, 0, 1) === \"\\x1B\")\n      array_push($escapes, $bytes);\n  }\n  /* 0xF is used to terminate a run of emoji encoded using ESC sequence\n   * We couldn't do this earlier or `findInvalidChars` wouldn't have worked\n   * as desired */\n  foreach ($escapes as $bytes) {\n    $nonInvertible[$bytes . \"\\x0F\"] = $nonInvertible[$bytes];\n    unset($nonInvertible[$bytes]);\n  }\n  testAllValidChars($validChars, $encoding, 'UTF-32BE');\n  testAllValidChars($nonInvertible, $encoding, 'UTF-32BE', false);\n  echo \"$encoding verification and conversion works on all valid characters\\n\";\n  testAllInvalidChars($invalidChars, $validChars, $encoding, 'UTF-32BE', \"\\x00\\x00\\x00%\");\n  testTruncatedChars($truncated, $encoding, 'UTF-32BE', \"\\x00\\x00\\x00%\");\n  echo \"$encoding verification and conversion works on all invalid characters\\n\";\n  convertAllInvalidChars($invalidCodepoints, $fromUnicode, 'UTF-32BE', $encoding, '%');\n  echo \"Unicode -> $encoding conversion works on all invalid codepoints\\n\";\n  // Test \"long\" illegal character markers\n  mb_substitute_character(\"long\");\n  convertInvalidString(\"\\x80\", \"%\", $encoding, \"UTF-8\");\n  convertInvalidString(\"\\x81\\x20\", \"%\", $encoding, \"UTF-8\");\n  convertInvalidString(\"\\xEA\\xA9\", \"%\", $encoding, \"UTF-8\");\n  mb_substitute_character(0x25); // '%'\n  // Test Regional Indicator codepoint at end of string\n  // The mobile SJIS variants all have special characters to represent certain national\n  // flags, but in Unicode these are represented by a sequence of _two_ codepoints\n  // So if only one of those two codepoints appears at the end of a string, it can't\n  // be converted to SJIS and should be treated as an error\n  convertInvalidString(\"\\x00\\x01\\xF1\\xE6\", \"%\", \"UTF-32BE\", $encoding); // Regional Indicator A\n}\ntestSJISVariant($docomo,   $nonInvertibleDocomo,   'SJIS-Mobile#DOCOMO');\ntestSJISVariant($kddi,     $nonInvertible,         'SJIS-Mobile#KDDI');\ntestSJISVariant($softbank, $nonInvertibleSoftbank, 'SJIS-Mobile#SOFTBANK');\n?>")).toMatchSnapshot();
  });
});
