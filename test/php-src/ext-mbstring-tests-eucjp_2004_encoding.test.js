// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/eucjp_2004_encoding.phpt
  it("Exhaustive test of EUC-JP-2004 encoding verification and conversion", function () {
    expect(parser.parseCode("<?php\nsrand(200); /* Make results consistent */\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\n$validChars = array(); /* EUC-JP-2004 string -> UTF-32BE */\n$fromUnicode = array(); /* UTF-16BE -> EUC-JP-2004 */\n$fp = fopen(__DIR__ . '/data/EUC-JP-2004.txt', 'r+');\nwhile ($line = fgets($fp, 256)) {\n  if ($line[0] == '#')\n    continue;\n  $codepoint2 = null;\n  if (sscanf($line, \"0x%x\\tU+%x+%x\", $bytes, $codepoint1, $codepoint2) >= 2) {\n    if ($bytes < 256)\n      $eucjp = chr($bytes);\n    else if ($bytes <= 0xFFFF)\n      $eucjp = pack('n', $bytes);\n    else\n      $eucjp = chr($bytes >> 16) . pack('n', $bytes & 0xFFFF);\n    if ($codepoint2) {\n      $validChars[$eucjp] = pack('NN', $codepoint1, $codepoint2);\n    } else {\n      $validChars[$eucjp] = pack('N', $codepoint1);\n      if ($codepoint1 <= 0xFFFF)\n        $fromUnicode[pack('n', $codepoint1)] = $eucjp;\n    }\n  }\n}\n/* Convert 0xA1B1 to U+FFE3 (FULLWIDTH MACRON), not U+203E (OVERLINE) */\n$validChars[\"\\xA1\\xB1\"] = \"\\x00\\x00\\xFF\\xE3\";\n$fromUnicode[\"\\xFF\\xE3\"] = \"\\xA1\\xB1\";\n/* Convert 0xA1EF to U+FFE5 (FULLWIDTH YEN SIGN), not U+00A5 (YEN SIGN) */\n$validChars[\"\\xA1\\xEF\"] = \"\\x00\\x00\\xFF\\xE5\";\n$fromUnicode[\"\\xFF\\xE5\"] = \"\\xA1\\xEF\";\n/* Convert U+00A5 (YEN SIGN) to 0x5C; that is one of the single bytes\n * which many legacy Japanese text encodings used to represent something\n * different from its normal meaning ASCII. In ASCII it's a backslash,\n * but legacy Japanese software often used it for a yen sign. */\n$fromUnicode[\"\\x00\\xA5\"] = \"\\x5C\";\n/* The other one is 0x7E, which is a tilde in ASCII, but was used in\n * legacy Japanese software for an overline */\n$fromUnicode[\"\\x20\\x3E\"] = \"\\x7E\";\ntestAllValidChars($validChars, 'EUC-JP-2004', 'UTF-32BE');\necho \"EUC-JP-2004 verification and conversion works for all valid characters\\n\";\nfindInvalidChars($validChars, $invalidChars, $truncated);\ntestAllInvalidChars($invalidChars, $validChars, 'EUC-JP-2004', 'UTF-32BE', \"\\x00\\x00\\x00%\");\ntestTruncatedChars($truncated, 'EUC-JP-2004', 'UTF-32BE', \"\\x00\\x00\\x00%\");\necho \"EUC-JP-2004 verification and conversion rejects all invalid characters\\n\";\ntestAllValidChars($fromUnicode, 'UTF-16BE', 'EUC-JP-2004', false);\necho \"Unicode -> EUC-JP-2004 conversion works on all valid characters\\n\";\nfindInvalidChars($fromUnicode, $invalidChars, $unused, array_fill_keys(range(0, 0xFF), 2));\nconvertAllInvalidChars($invalidChars, $fromUnicode, 'UTF-16BE', 'EUC-JP-2004', '%');\necho \"Unicode -> EUC-JP-2004 conversion works on all invalid characters\\n\";\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\x80\", \"%\", \"EUC-JP-2004\", \"UTF-8\");\nconvertInvalidString(\"\\xFE\\xFF\", \"%\", \"EUC-JP-2004\", \"UTF-8\");\necho \"Done!\\n\";\n?>")).toMatchSnapshot();
  });
});
