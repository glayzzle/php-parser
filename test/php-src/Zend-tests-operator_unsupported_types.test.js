// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // Zend/tests/operator_unsupported_types.phpt
  it("Using unsupported types with operators", function () {
    expect(parser.parseCode("<?php\n$binops = [\n    '+',\n    '-',\n    '*',\n    '/',\n    '%',\n    '**',\n    '<<',\n    '>>',\n    '&',\n    '|',\n    '^',\n    // Works on booleans, never errors.\n    'xor',\n    // Only generates errors that string conversion emits.\n    '.',\n];\n$illegalValues = [\n    '[]',\n    'new stdClass',\n    'STDOUT',\n    '\"foo\"',\n];\n$legalValues = [\n    'null',\n    'true',\n    'false',\n    '2',\n    '3.5', // Semi-legal for certain ops\n    '\"123\"',\n    '\"123foo\"', // Semi-legal\n];\nset_error_handler(function($errno, $errstr) {\n    assert($errno == E_WARNING || $errno == E_DEPRECATED);\n    echo \"Warning: $errstr\\n\";\n});\nfunction evalBinOp(string $op, string $value1, string $value2) {\n    try {\n        eval(\"return $value1 $op $value2;\");\n        echo \"No error for $value1 $op $value2\\n\";\n    } catch (Throwable $e) {\n        echo $e->getMessage() . \"\\n\";\n    }\n}\nfunction evalAssignOp(string $op, string $value1, string $value2) {\n    $x = $origX = eval(\"return $value1;\");\n    try {\n        eval(\"\\$x $op= $value2;\");\n        echo \"No error for $value1 $op= $value2\\n\";\n    } catch (Throwable $e) {\n        echo $e->getMessage() . \"\\n\";\n        if ($x !== $origX) {\n            die(\"Value corrupted!\");\n        }\n    }\n}\necho \"BINARY OP:\\n\";\nforeach ($binops as $op) {\n    foreach ($illegalValues as $illegalValue1) {\n        foreach ($illegalValues as $illegalValue2) {\n            evalBinOp($op, $illegalValue1, $illegalValue2);\n        }\n    }\n    foreach ($illegalValues as $illegalValue) {\n        foreach ($legalValues as $legalValue) {\n            evalBinOp($op, $illegalValue, $legalValue);\n            evalBinOp($op, $legalValue, $illegalValue);\n        }\n    }\n}\necho \"\\n\\nASSIGN OP:\\n\";\nforeach ($binops as $op) {\n    if ($op === 'xor') continue;\n    foreach ($illegalValues as $illegalValue1) {\n        foreach ($illegalValues as $illegalValue2) {\n            evalAssignOp($op, $illegalValue1, $illegalValue2);\n        }\n    }\n    foreach ($illegalValues as $illegalValue) {\n        foreach ($legalValues as $legalValue) {\n            evalAssignOp($op, $illegalValue, $legalValue);\n            evalAssignOp($op, $legalValue, $illegalValue);\n        }\n    }\n}\necho \"\\n\\nUNARY OP:\\n\";\nforeach ($illegalValues as $illegalValue) {\n    try {\n        eval(\"return ~$illegalValue;\");\n        echo \"No error for ~$illegalValue\\n\";\n    } catch (TypeError $e) {\n        echo $e->getMessage() . \"\\n\";\n    }\n}\necho \"\\n\\nINCDEC:\\n\";\nforeach ($illegalValues as $illegalValue) {\n    $copy = eval(\"return $illegalValue;\");\n    try {\n        $copy++;\n        echo \"No error for $copy++\\n\";\n    } catch (TypeError $e) {\n        echo $e->getMessage() . \"\\n\";\n    }\n    $copy = eval(\"return $illegalValue;\");\n    try {\n        $copy--;\n        echo \"No error for $copy--\\n\";\n    } catch (TypeError $e) {\n        echo $e->getMessage() . \"\\n\";\n    }\n}\n?>")).toMatchSnapshot();
  });
});
