// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/standard/tests/serialize/max_depth.phpt
  it("Bug #78549: Stack overflow due to nested serialized input", function () {
    expect(parser.parseCode("<?php\nfunction create_nested_data($depth, $prefix, $suffix, $inner = 'i:0;') {\n    return str_repeat($prefix, $depth) . $inner . str_repeat($suffix, $depth);\n}\necho \"Invalid max_depth:\\n\";\ntry {\n    unserialize('i:0;', ['max_depth' => 'foo']);\n} catch (TypeError $exception) {\n    echo $exception->getMessage() . \"\\n\";\n}\ntry {\n    unserialize('i:0;', ['max_depth' => -1]);\n} catch (ValueError $exception) {\n    echo $exception->getMessage() . \"\\n\";\n}\necho \"Array:\\n\";\nvar_dump(unserialize(\n    create_nested_data(128, 'a:1:{i:0;', '}'),\n    ['max_depth' => 128]\n) !== false);\nvar_dump(unserialize(\n    create_nested_data(129, 'a:1:{i:0;', '}'),\n    ['max_depth' => 128]\n));\necho \"Object:\\n\";\nvar_dump(unserialize(\n    create_nested_data(128, 'O:8:\"stdClass\":1:{i:0;', '}'),\n    ['max_depth' => 128]\n) !== false);\nvar_dump(unserialize(\n    create_nested_data(129, 'O:8:\"stdClass\":1:{i:0;', '}'),\n    ['max_depth' => 128]\n));\n// Depth can also be adjusted using ini setting\necho \"Ini setting:\\n\";\nini_set(\"unserialize_max_depth\", 128);\nvar_dump(unserialize(create_nested_data(128, 'a:1:{i:0;', '}')) !== false);\nvar_dump(unserialize(create_nested_data(129, 'a:1:{i:0;', '}')));\n// But an explicitly specified depth still takes precedence\necho \"Ini setting overridden:\\n\";\nvar_dump(unserialize(\n    create_nested_data(256, 'a:1:{i:0;', '}'),\n    ['max_depth' => 256]\n) !== false);\nvar_dump(unserialize(\n    create_nested_data(257, 'a:1:{i:0;', '}'),\n    ['max_depth' => 256]\n));\n// Reset ini setting to a large value,\n// so it's clear that it won't be used in the following.\nini_set(\"unserialize_max_depth\", 4096);\nclass Test implements Serializable {\n    public function serialize() {\n        return '';\n    }\n    public function unserialize($str) {\n        // Should fail, due to combined nesting level\n        var_dump(unserialize(create_nested_data(129, 'a:1:{i:0;', '}')));\n        // Should succeed, below combined nesting level\n        var_dump(unserialize(create_nested_data(128, 'a:1:{i:0;', '}')) !== false);\n    }\n}\necho \"Nested unserialize combined depth limit:\\n\";\nvar_dump(is_array(unserialize(\n    create_nested_data(128, 'a:1:{i:0;', '}', 'C:4:\"Test\":0:{}'),\n    ['max_depth' => 256]\n)));\nclass Test2 implements Serializable {\n    public function serialize() {\n        return '';\n    }\n    public function unserialize($str) {\n        // If depth limit is overridden, the depth should be counted\n        // from zero again.\n        var_dump(unserialize(\n            create_nested_data(257, 'a:1:{i:0;', '}'),\n            ['max_depth' => 256]\n        ));\n        var_dump(unserialize(\n            create_nested_data(256, 'a:1:{i:0;', '}'),\n            ['max_depth' => 256]\n        ) !== false);\n    }\n}\necho \"Nested unserialize overridden depth limit:\\n\";\nvar_dump(is_array(unserialize(\n    create_nested_data(64, 'a:1:{i:0;', '}', 'C:5:\"Test2\":0:{}'),\n    ['max_depth' => 128]\n)));\n?>")).toMatchSnapshot();
  });
});
