// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/reflection/tests/ReflectionType_001.phpt
  it("ReflectionParameter::get/hasType and ReflectionType tests", function () {
    expect(parser.parseCode("<?php\nfunction foo(stdClass $a, array $b, callable $c, string $f, bool $g, int $h, float $i, NotExisting $j, stdClass $d = null, $e = null) { }\nfunction bar(): stdClass { return new stdClass; }\nclass c extends stdClass {\n  function bar(self $x): int { return 1; }\n  function pbar(parent $x): int { return 1; }\n  function factory(): self { return new c; }\n  function pfactory(): parent { return new stdClass; }\n}\n$closure = function (Test $a): Test { return $a; };\necho \"*** functions\\n\";\nforeach ([\n  new ReflectionFunction('foo'),\n  new ReflectionFunction($closure),\n] as $idx => $rf) {\n  foreach ($rf->getParameters() as $idx2 => $rp) {\n    echo \"** Function $idx - Parameter $idx2\\n\";\n    var_dump($rp->hasType());\n    $ra = $rp->getType();\n    if ($ra) {\n      var_dump($ra->allowsNull());\n      var_dump($ra->isBuiltin());\n      var_dump($ra->getName());\n    }\n  }\n}\necho \"\\n*** methods\\n\";\nforeach ([\n  new ReflectionMethod('SplObserver', 'update'),\n  new ReflectionMethod('c', 'bar'),\n  new ReflectionMethod('c', 'pbar'),\n  new ReflectionMethod($closure, '__invoke'),\n] as $idx => $rm) {\n  foreach ($rm->getParameters() as $idx2 => $rp) {\n    echo \"** Method $idx - parameter $idx2\\n\";\n    var_dump($rp->hasType());\n    $ra = $rp->getType();\n    if ($ra) {\n      var_dump($ra->allowsNull());\n      var_dump($ra->isBuiltin());\n      var_dump($ra->getName());\n    }\n  }\n}\necho \"\\n*** return types\\n\";\nforeach ([\n  new ReflectionMethod('SplObserver', 'update'),\n  new ReflectionFunction('bar'),\n  new ReflectionMethod('c', 'bar'),\n  new ReflectionMethod('c', 'factory'),\n  new ReflectionMethod('c', 'pfactory'),\n  new ReflectionFunction($closure),\n  new ReflectionMethod($closure, '__invoke'),\n] as $idx => $rf) {\n  echo \"** Function/method return type $idx\\n\";\n  var_dump($rf->hasReturnType());\n  $ra = $rf->getReturnType();\n  if ($ra) {\n    var_dump($ra->allowsNull());\n    var_dump($ra->isBuiltin());\n    var_dump($ra->getName());\n  }\n}\necho \"\\n*** property types\\n\";\nclass PropTypeTest {\n    public int $int;\n    public string $string;\n    public array $arr;\n    public iterable $iterable;\n    public stdClass $std;\n    public OtherThing $other;\n    public $mixed;\n}\n$reflector = new ReflectionClass(PropTypeTest::class);\nforeach ($reflector->getProperties() as $name => $property) {\n    if ($property->hasType()) {\n        printf(\"public %s $%s;\\n\",\n            $property->getType()->getName(), $property->getName());\n    } else printf(\"public $%s;\\n\", $property->getName());\n}\necho \"*** resolved property types\\n\";\n$obj = new PropTypeTest;\n$obj->std = new stdClass;\n$r = (new ReflectionProperty($obj, 'std'))->getType();\nvar_dump($r->getName());\n?>")).toMatchSnapshot();
  });
});
