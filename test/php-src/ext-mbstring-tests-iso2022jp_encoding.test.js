// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/iso2022jp_encoding.phpt
  it("Test of ASCII and JIS X 0201/0208/0212 support in ISO-2022-JP and JIS7/8 encodings", function () {
    expect(parser.parseCode("<?php\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\n/* Read in table of all characters in JISX-0212 charset */\nreadConversionTable(__DIR__ . '/data/JISX0212.txt', $jisx0212Chars, $unused);\n/* Read in table of all characters in JISX-0208 charset */\n$jisx0208Chars = array(); /* JISX0208 -> UTF-16BE */\n$fp = fopen(__DIR__ . '/data/JISX0208.txt', 'r+');\nwhile ($line = fgets($fp, 256)) {\n\tif ($line[0] == '#')\n\t\tcontinue;\n\tif (sscanf($line, \"0x%x\\t0x%x\\t0x%x\", $shiftJIS, $jis0208Code, $unicodeCP) == 3) {\n\t\t$jisx0208Chars[pack('n', $jis0208Code)] = pack('n', $unicodeCP);\n\t}\n}\n/* Read in table of all characters in JISX-0201 charset */\nreadConversionTable(__DIR__ . '/data/JISX0201.txt', $jisx0201Chars, $unused);\n/* The JIS X 0208 character set does not have a single, straightforward\n * mapping to the Unicode character set\n * mbstring converts one character differently from the mappings in\n * ../docs/JISX0208.txt, which comes from the Unicode Consortium */\n/* 0x2140 is a backslash; this can be mapped to 0x005C for an ordinary\n * backslash, or 0xFF3C for a _fullwidth_ one */\n$jisx0208Chars[\"\\x21\\x40\"] = \"\\xFF\\x3C\";\nfunction testValid($from, $to, $encoding, $bothWays = true) {\n\tidentifyValidString($from, $encoding);\n\tconvertValidString($from, $to, $encoding, 'UTF-16BE', false);\n\tif ($bothWays) {\n\t\t/* An 0xF at the beginning of a JIS7 string is redundant; it switches\n\t\t * to ASCII mode, but ASCII mode is default */\n\t\tif ($from[0] == \"\\x0F\")\n\t\t\t$from = substr($from, 1, strlen($from) - 1);\n\t\t/* ESC ( B at the beginning is redundant, since ASCII mode is the default */\n\t\tif (substr($from, 0, 3) == \"\\x1B(B\")\n\t\t\t$from = substr($from, 3, strlen($from) - 3);\n\t\t/* If the string switches to a different charset, it should switch back to\n\t\t * ASCII at the end */\n\t\tif (strpos($from, \"\\x1B\\$B\") !== false || strpos($from, \"\\x1B(J\") !== false)\n\t\t\t$from .= \"\\x1B(B\";\n\t\tconvertValidString($to, $from, 'UTF-16BE', $encoding, false);\n\t}\n}\nfunction testInvalid($from, $to, $encoding) {\n\ttestInvalidString($from, $to, $encoding, 'UTF-16BE');\n}\nfor ($i = 0; $i < 0x80; $i++) {\n\tif ($i == 0xE || $i == 0xF || $i == 0x1B)\n\t\tcontinue;\n\ttestValid(chr($i),            \"\\x00\" . chr($i), 'JIS');\n\ttestValid(\"\\x0F\" . chr($i),   \"\\x00\" . chr($i), 'JIS'); /* 0xF is 'Shift Out' code */\n\ttestValid(\"\\x1B(B\" . chr($i), \"\\x00\" . chr($i), 'JIS');\n\ttestValid(chr($i),            \"\\x00\" . chr($i), 'ISO-2022-JP');\n\ttestValid(\"\\x1B(B\" . chr($i), \"\\x00\" . chr($i), 'ISO-2022-JP');\n}\nfor ($i = 0x80; $i < 256; $i++) {\n\tif ($i >= 0xA1 && $i <= 0xDF) // We convert single bytes from 0xA1-0xDF as JIS X 0201 kana\n\t\tcontinue;\n\ttestInvalid(chr($i),            \"\\x00%\", 'JIS');\n\ttestInvalid(\"\\x0F\" . chr($i),   \"\\x00%\", 'JIS');\n\ttestInvalid(\"\\x1B(B\" . chr($i), \"\\x00%\", 'JIS');\n\ttestInvalid(chr($i),            \"\\x00%\", 'ISO-2022-JP');\n\ttestInvalid(\"\\x1B(B\" . chr($i), \"\\x00%\", 'ISO-2022-JP');\n}\necho \"ASCII support OK\\n\";\n/* All valid JIS X 0201 characters\n * Those with a 1 in the high bit are JIS X 0201 kana; JIS7 encodes those\n * with a 0 in the high bit and treats them as a separate charset\n * (We don't test ISO-2022-JP here, as it does not support the JIS X 0201 charset) */\nforeach ($jisx0201Chars as $jisx0201 => $utf16BE) {\n\tif (ord($jisx0201) >= 128) {\n\t\t$kana = chr(ord($jisx0201) - 128);\n\t\ttestValid(\"\\x1B(I\" . $kana, $utf16BE, 'JIS', false);\n\t\ttestValid(\"\\x0E\" . $kana, $utf16BE, 'JIS', false); /* 0xE is 'Shift In' code */\n\t\ttestValid($jisx0201, $utf16BE, 'JIS', false);\n\t} else {\n\t\ttestValid(\"\\x1B(J\" . $jisx0201, $utf16BE, 'JIS', $utf16BE > \"\\x00\\x80\");\n\t}\n}\nfor ($i = 0x80; $i < 256; $i++) {\n\tif ($i >= 0xA1 && $i <= 0xDF)\n\t\tcontinue;\n\ttestInvalid(\"\\x1B(I\" . chr($i), \"\\x00%\", 'JIS');\n\ttestInvalid(\"\\x1B(J\" . chr($i), \"\\x00%\", 'JIS');\n}\necho \"JIS X 0201 support OK\\n\";\n/* All valid JISX0208 characters */\nforeach ($jisx0208Chars as $jisx0208 => $utf16BE) {\n\ttestValid(\"\\x1B\\$B\" . $jisx0208, $utf16BE, 'JIS');\n\ttestValid(\"\\x1B\\$B\" . $jisx0208, $utf16BE, 'ISO-2022-JP');\n}\n/* All invalid 2-byte JISX0208 characters */\nfor ($i = 0x21; $i <= 0x7E; $i++) {\n\tfor ($j = 0; $j < 256; $j++) {\n\t\t$testString = chr($i) . chr($j);\n\t\tif (!isset($jisx0208Chars[$testString])) {\n\t\t\ttestInvalid(\"\\x1B\\$B\" . $testString, \"\\x00%\", 'JIS');\n\t\t\ttestInvalid(\"\\x1B\\$B\" . $testString, \"\\x00%\", 'ISO-2022-JP');\n\t\t}\n\t}\n}\n/* Try truncated JISX0208 characters */\nfor ($i = 0x21; $i <= 0x7E; $i++) {\n\ttestInvalid(\"\\x1B\\$B\" . chr($i), \"\\x00%\", 'JIS');\n\ttestInvalid(\"\\x1B\\$B\" . chr($i), \"\\x00%\", 'ISO-2022-JP');\n}\necho \"JIS X 0208 support OK\\n\";\n/* JIS7 supports escape to switch to JIS X 0212 charset, but ISO-2022-JP does not */\n/* All valid JISX0212 characters */\nforeach ($jisx0212Chars as $jisx0212 => $utf16BE) {\n\ttestValid(\"\\x1B\\$(D\" . $jisx0212, $utf16BE, 'JIS', false);\n}\n/* All invalid 2-byte JISX0212 characters */\nfor ($i = 0x21; $i <= 0x7E; $i++) {\n\tfor ($j = 0; $j < 256; $j++) {\n\t\t$testString = chr($i) . chr($j);\n\t\tif (!isset($jisx0212Chars[$testString])) {\n\t\t\ttestInvalid(\"\\x1B\\$(D\" . $testString, \"\\x00%\", 'JIS');\n\t\t}\n\t}\n}\n/* Try truncated JISX0212 characters */\nfor ($i = 0x21; $i <= 0x7E; $i++) {\n\ttestInvalid(\"\\x1B\\$(D\" . chr($i), \"\\x00%\", 'JIS');\n}\necho \"JIS X 0212 support OK\\n\";\n/* All possible escape sequences */\n$validEscapes = [\"\\x1B\\$@\" => true, \"\\x1B\\$B\" => true, \"\\x1B\\$(@\" => true, \"\\x1B\\$(B\" => true, \"\\x1B\\$(D\" => true, \"\\x1B(B\" => true, \"\\x1B(H\" => true, \"\\x1B(J\" => true, \"\\x1B(I\" => true];\nfor ($i = 0; $i <= 0xFF; $i++) {\n\tfor ($j = 0; $j <= 0xFF; $j++) {\n\t\t$escapeSequence = \"\\x1B\" . chr($i) . chr($j);\n\t\tif ($escapeSequence === \"\\x1B\\$(\")\n\t\t\tcontinue;\n\t\tif (isset($validEscapes[$escapeSequence])) {\n\t\t\ttestValid($escapeSequence, \"\", 'JIS', false);\n\t\t\ttestValid($escapeSequence, \"\", 'ISO-2022-JP', false);\n\t\t} else {\n\t\t\tidentifyInvalidString($escapeSequence, 'JIS');\n\t\t\tidentifyInvalidString($escapeSequence, 'ISO-2022-JP');\n\t\t}\n\t}\n}\nfor ($i = 0; $i <= 0xFF; $i++) {\n\t$escapeSequence = \"\\x1B\\$(\" . chr($i);\n\tif (isset($validEscapes[$escapeSequence])) {\n\t\ttestValid($escapeSequence, \"\", 'JIS', false);\n\t\ttestValid($escapeSequence, \"\", 'ISO-2022-JP', false);\n\t} else {\n\t\tidentifyInvalidString($escapeSequence, 'JIS');\n\t\tidentifyInvalidString($escapeSequence, 'ISO-2022-JP');\n\t}\n}\necho \"All escape sequences work as expected\\n\";\nforeach (['JIS', 'ISO-2022-JP'] as $encoding) {\n\ttestValidString(\"\\x22\\x25\", \"\\x1B\\$B!B\\x1B(B\", 'UTF-16BE', $encoding, false);\n\ttestValidString(\"\\xFF\\x0D\", \"\\x1B\\$B!]\\x1B(B\", 'UTF-16BE', $encoding, false);\n\ttestValidString(\"\\xFF\\xE0\", \"\\x1B\\$B!q\\x1B(B\", 'UTF-16BE', $encoding, false);\n\ttestValidString(\"\\xFF\\xE1\", \"\\x1B\\$B!r\\x1B(B\", 'UTF-16BE', $encoding, false);\n\ttestValidString(\"\\xFF\\xE2\", \"\\x1B\\$B\\\"L\\x1B(B\", 'UTF-16BE', $encoding, false);\n\ttestValidString(\"\\x00\\xA5\", \"\\x1B(J\\x5C\\x1B(B\", 'UTF-16BE', $encoding, false);\n}\necho \"Other mappings from Unicode -> ISO-2022-JP are OK\\n\";\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\xE0\", \"%\", \"JIS\", \"UTF-8\");\nconvertInvalidString(\"\\xE0\", \"%\", \"ISO-2022-JP\", \"UTF-8\");\nconvertInvalidString(\"\\x1B\\$(X\", \"%\\$(X\", \"JIS\", \"UTF-8\"); // Invalid escape\nconvertInvalidString(\"\\x1B\\$(X\", \"%\\$(X\", \"ISO-2022-JP\", \"UTF-8\"); // Invalid escape\nconvertInvalidString(\"\\x1B\\$B!\", \"%\", \"JIS\", \"UTF-8\"); // Truncated character\nconvertInvalidString(\"\\x1B\\$B!\", \"%\", \"ISO-2022-JP\", \"UTF-8\"); // Truncated character\necho \"Done!\\n\";\n?>")).toMatchSnapshot();
  });
});
