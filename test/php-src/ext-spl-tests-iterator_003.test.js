// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/spl/tests/iterator_003.phpt
  it("SPL: CachingIterator and __toString()", function () {
    expect(parser.parseCode("<?php\nclass Student\n{\n    private $id;\n    private $name;\n    public function __construct($id, $name)\n    {\n        $this->id = $id;\n        $this->name = $name;\n    }\n    public function __toString()\n    {\n        return $this->id . ', ' . $this->name;\n    }\n    public function getId()\n    {\n        return $this->id;\n    }\n}\nclass StudentIdFilter extends FilterIterator\n{\n    private $id;\n    public function __construct(ArrayObject $students, Student $other)\n    {\n        FilterIterator::__construct($students->getIterator());\n        $this->id = $other->getId();\n    }\n    public function accept(): bool\n    {\n        echo \"ACCEPT \".$this->current()->getId().\" == \".$this->id.\"\\n\";\n        return $this->current()->getId() == $this->id;\n    }\n}\nclass StudentList implements IteratorAggregate\n{\n    private $students;\n    public function __construct()\n    {\n        $this->students = new ArrayObject(array());\n    }\n    public function add(Student $student)\n    {\n        if (!$this->contains($student)) {\n            $this->students[] = $student;\n        }\n    }\n    public function contains(Student $student)\n    {\n        foreach ($this->students as $s)\n        {\n            if ($s->getId() == $student->getId()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    public function getIterator(): Traversable {\n        return new CachingIterator($this->students->getIterator(), true);\n    }\n}\n$students = new StudentList();\n$students->add(new Student('01234123', 'Joe'));\n$students->add(new Student('00000014', 'Bob'));\n$students->add(new Student('00000014', 'Foo'));\n// The goal is to verify we can access the cached string value even if it was\n// generated by a call to __toString(). To check this we need to access the\n// iterator's __toString() method.\n$it = $students->getIterator();\nforeach ($it as $student) {\n    echo $it->__toString(), \"\\n\";\n}\n?>")).toMatchSnapshot();
  });
});
