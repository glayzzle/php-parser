// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_mysql/tests/pdo_mysql___construct_options.phpt
  it("MySQL PDO->__construct(), options", function () {
    expect(parser.parseCode("<?php\n    require_once(__DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');\n    function set_option_and_check($offset, $option, $value, $option_desc) {\n        $dsn = MySQLPDOTest::getDSN();\n        $user = PDO_MYSQL_TEST_USER;\n        $pass = PDO_MYSQL_TEST_PASS;\n        try {\n            $db = new PDO($dsn, $user, $pass, array($option => $value));\n            $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);\n            if (!is_object($db) || ($value !== ($tmp = @$db->getAttribute($option))))\n                printf(\"[%03d] Expecting '%s'/%s got '%s'/%s' for options '%s'\\n\",\n                    $offset,\n                    $value, gettype($value),\n                    $tmp, gettype($tmp),\n                    $option_desc);\n        } catch (PDOException $e) {\n            printf(\"[%03d] %s\\n\", $offset, $e->getMessage());\n        }\n    }\n    try {\n        $dsn = MySQLPDOTest::getDSN();\n        $user = PDO_MYSQL_TEST_USER;\n        $pass = PDO_MYSQL_TEST_PASS;\n        $valid_options = array(\n            /* pdo_dbh.c */\n            PDO::ATTR_PERSISTENT\t\t\t\t\t\t\t\t\t=> 'PDO::ATTR_PERSISTENT',\n            PDO::ATTR_AUTOCOMMIT\t\t\t\t\t\t\t\t\t=> 'PDO::ATTR_AUTOCOMMIT',\n            /* mysql_driver.c */\n            /* TODO Possible bug PDO::ATTR_TIMEOUT != MYSQLI_OPT_CONNECT_TIMEOUT*/\n            PDO::ATTR_TIMEOUT \t\t\t\t\t\t\t\t\t\t=> 'PDO::ATTR_TIMEOUT',\n            PDO::ATTR_EMULATE_PREPARES\t\t\t\t\t\t=> 'PDO::ATTR_EMULATE_PREPARES',\n            PDO::MYSQL_ATTR_USE_BUFFERED_QUERY\t\t=> 'PDO::MYSQL_ATTR_USE_BUFFERED_QUERY',\n            PDO::MYSQL_ATTR_LOCAL_INFILE\t\t\t\t\t=> 'PDO::MYSQL_ATTR_LOCAL_INFILE',\n            PDO::MYSQL_ATTR_DIRECT_QUERY\t\t\t\t\t=> 'PDO::MYSQL_ATTR_DIRECT_QUERY',\n            PDO::MYSQL_ATTR_INIT_COMMAND\t\t\t\t\t=> 'PDO::MYSQL_ATTR_INIT_COMMAND',\n            PDO::ATTR_EMULATE_PREPARES\t\t\t\t\t\t=> 'PDO::ATTR_EMULATE_PREPARES',\n        );\n        $defaults = array(\n            PDO::ATTR_PERSISTENT\t\t\t\t\t\t\t\t\t=> false,\n            PDO::ATTR_AUTOCOMMIT\t\t\t\t\t\t\t\t\t=> 1,\n            /* TODO - why is this a valid option if getAttribute() does not support it?! */\n            PDO::ATTR_TIMEOUT \t\t\t\t\t\t\t\t\t\t=> false,\n            PDO::ATTR_EMULATE_PREPARES\t\t\t\t\t\t=> 1,\n            PDO::MYSQL_ATTR_USE_BUFFERED_QUERY\t\t=> 1,\n            /* TODO getAttribute() does not handle it */\n            PDO::MYSQL_ATTR_LOCAL_INFILE\t\t\t\t\t=> false,\n            /* TODO getAttribute() does not handle it */\n            PDO::MYSQL_ATTR_DIRECT_QUERY\t\t\t\t\t=> 1,\n            PDO::MYSQL_ATTR_INIT_COMMAND\t\t\t\t\t=> '',\n        );\n        try {\n            if (NULL !== ($db = @new PDO($dsn, $user, $pass, 'wrong type')))\n                printf(\"[001] Expecting NULL got %s/%s\\n\", gettype($db), $db);\n        } catch (TypeError $e) {\n        }\n        if (!is_object($db = new PDO($dsn, $user, $pass, array())))\n            printf(\"[002] Expecting object got %s/%sÂ¸\\n\", gettype($db), $db);\n        $invalid = 999;\n        if (is_object($db = new PDO($dsn, $user, $pass, array($invalid => true))))\n            printf(\"[003] [TODO][CHANGEREQUEST] Please, lets not ignore invalid options and bail out!\\n\");\n        $db = new PDO($dsn, $user, $pass);\n        $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);\n        foreach ($valid_options as $option => $name) {\n            /* TODO getAttribute() is pretty poor in supporting the options, suppress errors */\n            $tmp = @$db->getAttribute($option);\n            if ($tmp !== $defaults[$option])\n                printf(\"[003a] Expecting default value for '%s' of '%s'/%s, getAttribute() reports setting '%s'/%s\\n\",\n                    $name, $defaults[$option], gettype($defaults[$option]),\n                    $tmp, gettype($tmp));\n        }\n        $db = new PDO($dsn, $user, $pass, array(PDO::ATTR_AUTOCOMMIT => true));\n        if (!is_object($db) || !$db->getAttribute(PDO::ATTR_AUTOCOMMIT))\n            printf(\"[004] Autocommit should be on\\n\");\n        $db = new PDO($dsn, $user, $pass, array(PDO::ATTR_AUTOCOMMIT => false));\n        if (!is_object($db) || $db->getAttribute(PDO::ATTR_AUTOCOMMIT))\n            printf(\"[005] Autocommit should be off\\n\");\n        /* TODO: no way to check ATTR_TIMEOUT settings */\n        if (!is_object($db = new PDO($dsn, $user, $pass, array(PDO::ATTR_TIMEOUT => 10))))\n            printf(\"[006] ATTR_TIMEOUT should be accepted\\n\");\n        if (!is_object($db = new PDO($dsn, $user, $pass, array(PDO::ATTR_TIMEOUT => PHP_INT_MAX))))\n            printf(\"[007] ATTR_TIMEOUT should be accepted\\n\");\n        if (!is_object($db = new PDO($dsn, $user, $pass, array(PDO::ATTR_TIMEOUT => -PHP_INT_MAX))))\n            printf(\"[008] ATTR_TIMEOUT should be accepted\\n\");\n        /* TODO: Its ugly that PDO::ATTR_EMULATE_PREPARES == PDO::MYSQL_ATTR_DIRECT_QUERY */\n        $db = new PDO($dsn, $user, $pass, array(PDO::ATTR_EMULATE_PREPARES => true));\n        if (!is_object($db))\n            printf(\"[009] ATTR_EMULATE_PREPARES should be accepted and on\\n\");\n        if (!$db->getAttribute(PDO::ATTR_EMULATE_PREPARES))\n            printf(\"[010] [TODO][CHANGEREQUEST] ATTR_EMULATE_PREPARES should be on\\n\");\n        if (!$db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))\n            printf(\"[011] As PDO::MYSQL_ATTR_DIRECT_QUERY == PDO::ATTR_EMULATE_PREPARES\n                and PDO::ATTR_EMULATE_PREPARES overrules the other, PDO::MYSQL_ATTR_DIRECT_QUERY should be on\\n\");\n        $db = new PDO($dsn, $user, $pass, array(PDO::ATTR_EMULATE_PREPARES => false));\n        if (!is_object($db))\n            printf(\"[012] ATTR_EMULATE_PREPARES should be accepted and on\\n\");\n        if ($db->getAttribute(PDO::ATTR_EMULATE_PREPARES))\n            printf(\"[013] [TODO][CHANGEREQUEST] ATTR_EMULATE_PREPARES should be off\\n\");\n        if ($db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))\n            printf(\"[014] As PDO::MYSQL_ATTR_DIRECT_QUERY == PDO::ATTR_EMULATE_PREPARES\n                and PDO::ATTR_EMULATE_PREPARES overrules the other, PDO::MYSQL_ATTR_DIRECT_QUERY should be off\\n\");\n        // PDO::ATTR_EMULATE_PREPARES overrules PDO::MYSQL_ATTR_DIRECT_QUERY\n        // TODO: is it clever that a generic setting overrules a specific setting?\n        $db = new PDO($dsn, $user, $pass, array(PDO::ATTR_EMULATE_PREPARES => true, PDO::MYSQL_ATTR_DIRECT_QUERY => false));\n        if (!$db->getAttribute(PDO::ATTR_EMULATE_PREPARES))\n            printf(\"[015] PDO::ATTR_EMULATE_PREPARES should be on\\n\");\n        if (!$db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))\n            printf(\"[016] PDO::MYSQL_ATTR_DIRECT_QUERY should be on\\n\");\n        $db = new PDO($dsn, $user, $pass, array(PDO::ATTR_EMULATE_PREPARES => false, PDO::MYSQL_ATTR_DIRECT_QUERY => true));\n        if ($db->getAttribute(PDO::ATTR_EMULATE_PREPARES))\n            printf(\"[017] PDO::ATTR_EMULATE_PREPARES should be off\\n\");\n        if ($db->getAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY))\n            printf(\"[018] PDO::MYSQL_ATTR_DIRECT_QUERY should be off\\n\");\n        set_option_and_check(19, PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 1, 'PDO::MYSQL_ATTR_USE_BUFFERED_QUERY');\n        set_option_and_check(20, PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, 0, 'PDO::MYSQL_ATTR_USE_BUFFERED_QUERY');\n        set_option_and_check(21, PDO::MYSQL_ATTR_LOCAL_INFILE, true, 'PDO::MYSQL_ATTR_LOCAL_INFILE');\n        set_option_and_check(22, PDO::MYSQL_ATTR_LOCAL_INFILE, false, 'PDO::MYSQL_ATTR_LOCAL_INFILE');\n        set_option_and_check(23, PDO::MYSQL_ATTR_INIT_COMMAND, 'SET @a=1', 'PDO::MYSQL_ATTR_INIT_COMMAND');\n        set_option_and_check(24, PDO::MYSQL_ATTR_INIT_COMMAND, '', 'PDO::MYSQL_ATTR_INIT_COMMAND');\n        set_option_and_check(25, PDO::MYSQL_ATTR_INIT_COMMAND, 'INSERT INTO nonexistent(invalid) VALUES (1)', 'PDO::MYSQL_ATTR_INIT_COMMAND');\n        set_option_and_check(33, PDO::MYSQL_ATTR_DIRECT_QUERY, 1, 'PDO::MYSQL_ATTR_DIRECT_QUERY');\n        set_option_and_check(34, PDO::MYSQL_ATTR_DIRECT_QUERY, 0, 'PDO::MYSQL_ATTR_DIRECT_QUERY');\n        if (defined('PDO::MYSQL_ATTR_LOCAL_INFILE_DIRECTORY')) {\n            set_option_and_check(35, PDO::MYSQL_ATTR_LOCAL_INFILE_DIRECTORY, null, 'PDO::MYSQL_ATTR_LOCAL_INFILE_DIRECTORY');\n            // libmysqlclient returns the directory with a trailing slash.\n            // set_option_and_check(36, PDO::MYSQL_ATTR_LOCAL_INFILE_DIRECTORY, __DIR__, 'PDO::MYSQL_ATTR_LOCAL_INFILE_DIRECTORY');\n        }\n    } catch (PDOException $e) {\n        printf(\"[001] %s, [%s] %s Line: %s\\n\",\n            $e->getMessage(),\n            (is_object($db)) ? $db->errorCode() : 'n/a',\n            (is_object($db)) ? implode(' ', $db->errorInfo()) : 'n/a',\n            $e->getLine());\n    }\n    print \"done!\";\n?>")).toMatchSnapshot();
  });
});
