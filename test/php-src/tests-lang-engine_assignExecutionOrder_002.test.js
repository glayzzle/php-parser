// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // tests/lang/engine_assignExecutionOrder_002.phpt
  it("Evaluation order during assignments.", function () {
    expect(parser.parseCode("<?php\n// simple case with missing element\n$f = array(\"hello\",\"item2\",\"bye\");\nlist($a,,$b) = $f;\necho \"A=$a B=$b\\n\";\n// Warning: Cannot use a scalar value as an array in %s on line %d\ntry {\n    $c[$c=1] = 1;\n} catch (Error $e) {\n    echo $e->getMessage(), \"\\n\";\n}\n// i++ evaluated first, so $d[0] is 10\n$d = array(0,10);\n$i = 0;\n$d[$i++] = $i*10;\n// expected array is 10,10\nvar_dump($d);\n// the f++++ makes f into 2, so $e 0 and 1 should both be 30\n$e = array(0,0);\n$f = 0;\n$g1 = array(10,10);\n$g2 = array(20,20);\n$g3 = array(30,30);\n$g = array($g1,$g2,$g3);\nlist($e[$f++],$e[$f++]) = $g[2];\n// expect 30,30\nvar_dump($e);\n$i1 = array(1,2);\n$i2 = array(10,20);\n$i3 = array(100,200);\n$i4 = array(array(1000,2000),3000);\n$i = array($i1,$i2,$i3,$i4);\n$j = array(0,0,0);\n$h = 0;\n// a list of lists\nlist(list($j[$h++],$j[$h++]),$j[$h++]) = $i[3];\nvar_dump($j);\n// list of lists with just variable assignments - expect 100,200,300\n$k3 = array(100,200);\n$k = array($k3,300);\nlist(list($l,$m),$n) = $k;\necho \"L=$l M=$m N=$n\\n\";\n// expect $x and $y to be null - this fails on php.net 5.2.1 (invalid opcode) - fixed in 5.2.3\nlist($o,$p) = 20;\necho \"O=$o and P=$p\\n\";\n// list of lists with blanks and nulls expect 10 20 40 50 60 70 80\n$q1 = array(10,20,30,40);\n$q2 = array(50,60);\n$q3 = array($q1,$q2,null,70);\n$q4 = array($q3,null,80);\nlist(list(list($r,$s,,$t),list($u,$v),,$w),,$x) = $q4;\necho \"$r $s $t $u $v $w $x\\n\";\n// expect y and z to be undefined\nlist($y,$z) = array();\necho \"Y=$y,Z=$z\\n\";\n// expect h to be defined and be 10\nlist($aa,$bb) = array(10);\necho \"AA=$aa\\n\";\n// expect cc and dd to be 10 and 30\nlist($cc,,$dd) = array(10,20,30,40);\necho \"CC=$cc DD=$dd\\n\";\n// expect the inner array to be defined\n$ee = array(\"original array\");\nfunction f() {\n  global $ee;\n  $ee = array(\"array created in f()\");\n  return 1;\n}\n$ee[\"array entry created after f()\"][f()] = \"hello\";\nprint_r($ee);\n?>")).toMatchSnapshot();
  });
});
