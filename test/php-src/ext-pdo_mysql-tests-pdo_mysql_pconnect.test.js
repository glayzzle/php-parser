// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_mysql/tests/pdo_mysql_pconnect.phpt
  it("MySQL PDO->__construct(), PDO::ATTR_PERSISTENT", function () {
    expect(parser.parseCode("<?php\n    require_once(__DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');\n    try {\n        $dsn = MySQLPDOTest::getDSN();\n        $user = PDO_MYSQL_TEST_USER;\n        $pass = PDO_MYSQL_TEST_PASS;\n        $db1 = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));\n        $db2 = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));\n        $db1->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);\n        $db2->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);\n        $db1->exec('SET @pdo_persistent_connection=1');\n        $stmt = $db2->query('SELECT @pdo_persistent_connection as _pers');\n        $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n        if ($tmp['_pers'] != 1)\n            printf(\"[001] Both handles should use the same connection.\");\n        $stmt = $db1->query('SELECT CONNECTION_ID() as _con1');\n        $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n        $con1 = $tmp['_con1'];\n        $stmt = $db2->query('SELECT CONNECTION_ID() as _con2');\n        $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n        $con2 = $tmp['_con2'];\n        if ($con1 !== $con2)\n            printf(\"[002] Both handles should report the same MySQL thread ID\");\n        $db1 = NULL; /* should be equal to closing to my understanding */\n        $db1 = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));\n        $db1->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);\n        $stmt = $db1->query('SELECT CONNECTION_ID() as _con1');\n        $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n        $con1 = $tmp['_con1'];\n        if ($con1 !== $con2)\n            printf(\"[003] Both handles should report the same MySQL thread ID\");\n        $affected = $db1->exec(sprintf('KILL %d', $con1));\n        // Server needs some think-time sometimes\n        sleep(1);\n        if ('00000' == $db1->errorCode()) {\n            // looks like KILL has worked ? Or not... TODO: why no warning with libmysql?!\n            @$db1->exec(\"SET @pdo_persistent_connection=2\");\n            // but now I want to see some error...\n            if ('HY000' != $db1->errorCode())\n                printf(\"[004] Wrong error code %s\\n\", $db1->errorCode());\n            $tmp = implode(' ', $db1->errorInfo());\n            if (!strstr($tmp, '2006'))\n                printf(\"[005] Wrong error info %s\\n\", $tmp);\n        }\n        $db1 = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => false));\n        $db1->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);\n        $stmt = $db1->query('SELECT CONNECTION_ID() as _con1');\n        $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n        $con1 = $tmp['_con1'];\n        @$db2 = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));\n        $db2->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);\n        $stmt = $db2->query('SELECT CONNECTION_ID() as _con2');\n        $tmp = $stmt->fetch(PDO::FETCH_ASSOC);\n        $con2 = $tmp['_con2'];\n        if ($con1 == $con2)\n            printf(\"[006] Looks like the persistent and the non persistent connection are using the same link?!\\n\");\n        // lets go crazy and create a few pconnections...\n        $connections = array();\n        for ($i = 0; $i <= 20; $i++) {\n            $connections[$i] = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));\n        }\n        do {\n            $i = mt_rand(0, 20);\n            if (isset($connections[$i]))\n                unset($connections[$i]);\n        } while (!empty($connections));\n    } catch (PDOException $e) {\n        printf(\"[001] %s, [%s] %s [%s] %s\\n\",\n            $e->getMessage(),\n            (is_object($db1)) ? $db1->errorCode() : 'n/a',\n            (is_object($db1)) ? implode(' ', $db1->errorInfo()) : 'n/a',\n            (is_object($db2)) ? $db2->errorCode() : 'n/a',\n            (is_object($db2)) ? implode(' ', $db2->errorInfo()) : 'n/a');\n    }\n    print \"done!\";\n?>")).toMatchSnapshot();
  });
});
