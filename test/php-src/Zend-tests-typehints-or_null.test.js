// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // Zend/tests/typehints/or_null.phpt
  it("Test \"or null\"/\"or be null\" in type-checking errors for userland functions", function () {
    expect(parser.parseCode("<?php\n// This should test every branch in zend_execute.c's `zend_verify_arg_type`, `zend_verify_return_type` and `zend_verify_missing_return_type` functions which produces an \"or null\"/\"or be null\" part in its error message\nfunction unloadedClass(?I\\Dont\\Exist $param) {}\ntry {\n    unloadedClass(new \\StdClass);\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nclass RealClass {}\ninterface RealInterface {}\nfunction loadedClass(?RealClass $param) {}\nfunction loadedInterface(?RealInterface $param) {}\ntry {\n    loadedClass(new \\StdClass);\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\ntry {\n    loadedInterface(new \\StdClass);\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\ntry {\n    unloadedClass(1);\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\ntry {\n    loadedClass(1);\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\ntry {\n    loadedInterface(1);\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction callableF(?callable $param) {}\ntry {\n    callableF(1);\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction iterableF(?iterable $param) {}\ntry {\n    iterableF(1);\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction intF(?int $param) {}\ntry {\n    intF(new StdClass);\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnUnloadedClass(): ?I\\Dont\\Exist {\n    return new \\StdClass;\n}\ntry {\n    returnUnloadedClass();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnLoadedClass(): ?RealClass {\n    return new \\StdClass;\n}\ntry {\n    returnLoadedClass();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnLoadedInterface(): ?RealInterface {\n    return new \\StdClass;\n}\ntry {\n    returnLoadedInterface();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnUnloadedClassScalar(): ?I\\Dont\\Exist {\n    return 1;\n}\ntry {\n    returnUnloadedClassScalar();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnLoadedClassScalar(): ?RealClass {\n    return 1;\n}\ntry {\n    returnLoadedClassScalar();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnLoadedInterfaceScalar(): ?RealInterface {\n    return 1;\n}\ntry {\n    returnLoadedInterfaceScalar();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnCallable(): ?callable {\n    return 1;\n}\ntry {\n    returnCallable();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnIterable(): ?iterable {\n    return 1;\n}\ntry {\n    returnIterable();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnInt(): ?int {\n    return new \\StdClass;\n}\ntry {\n    returnInt();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnMissingUnloadedClass(): ?I\\Dont\\Exist {\n}\ntry {\n    returnMissingUnloadedClass();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnMissingLoadedClass(): ?RealClass {\n}\ntry {\n    returnMissingLoadedClass();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnMissingLoadedInterface(): ?RealInterface {\n}\ntry {\n    returnMissingLoadedInterface();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnMissingCallable(): ?callable {\n}\ntry {\n    returnMissingCallable();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnMissingIterable(): ?iterable {\n}\ntry {\n    returnMissingIterable();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\nfunction returnMissingInt(): ?int {\n}\ntry {\n    returnMissingInt();\n} catch (\\TypeError $e) {\n    echo $e, PHP_EOL;\n}\n?>")).toMatchSnapshot();
  });
});
