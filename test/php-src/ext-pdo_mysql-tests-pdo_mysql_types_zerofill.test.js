// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_mysql/tests/pdo_mysql_types_zerofill.phpt
  it("MySQL PDO->exec(), native types - ZEROFILL", function () {
    expect(parser.parseCode("<?php\n    require_once(__DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');\n    function test_type(&$db, $offset, $sql_type, $value, $ret_value = NULL, $pattern = NULL) {\n        $db->exec('DROP TABLE IF EXISTS test');\n        $sql = sprintf('CREATE TABLE test(id INT, label %s) ENGINE=%s', $sql_type, MySQLPDOTest::getTableEngine());\n        @$db->exec($sql);\n        if ($db->errorCode() != 0) {\n            // not all MySQL Server versions and/or engines might support the type\n            return true;\n        }\n        $stmt = $db->prepare('INSERT INTO test(id, label) VALUES (?, ?)');\n        $stmt->bindValue(1, $offset);\n        $stmt->bindValue(2, $value);\n        try {\n            if (!$stmt->execute()) {\n                printf(\"[%03d + 1] INSERT failed, %s\\n\", $offset, var_export($stmt->errorInfo(), true));\n                return false;\n            }\n        } catch (PDOException $e) {\n            // This might be a SQL warning on signed values inserted in unsigned columns\n            // Zerofill implies unsigned but the test plays with signed = negative values as well!\n            return true;\n        }\n        $db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, false);\n        $stmt = $db->query('SELECT id, label FROM test');\n        $row = $stmt->fetch(PDO::FETCH_ASSOC);\n        $stmt->closeCursor();\n        if (!isset($row['id']) || !isset($row['label'])) {\n            printf(\"[%03d + 2] Fetched result seems wrong, dumping result: %s\\n\", $offset, var_export($row, true));\n            return false;\n        }\n        if ($row['id'] != $offset) {\n            printf(\"[%03d + 3] Expecting %s got %s\\n\", $offset, $row['id']);\n            return false;\n        }\n        if (!is_null($pattern)) {\n            if (!preg_match($pattern, $row['label'])) {\n                printf(\"[%03d + 5] Value seems wrong, accepting pattern %s got %s, check manually\\n\",\n                    $offset, $pattern, var_export($row['label'], true));\n                return false;\n            }\n        } else {\n            $exp = $value;\n            if (!is_null($ret_value)) {\n                // we expect a different return value than our input value\n                // typically the difference is only the type\n                $exp = $ret_value;\n            }\n            if ($row['label'] !== $exp) {\n                printf(\"[%03d + 4] %s - input = %s/%s, output = %s/%s\\n\", $offset,\n                    $sql_type, var_export($exp, true), gettype($exp),\n                    var_export($row['label'], true), gettype($row['label']));\n                return false;\n            }\n        }\n        $db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);\n        $stmt = $db->query('SELECT id, label FROM test');\n        $row_string = $stmt->fetch(PDO::FETCH_ASSOC);\n        $stmt->closeCursor();\n        if ($row['label'] != $row_string['label']) {\n            printf(\"%s - STRINGIGY = %s, NATIVE = %s\\n\", $sql_type, var_export($row_string['label'], true), var_export($row['label'], true));\n            return false;\n        }\n        return true;\n    }\n    $db = MySQLPDOTest::factory();\n    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n    $db->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);\n    $db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, false);\n    $stmt = $db->prepare('SELECT @@sql_mode AS _mode');\n    $stmt->execute();\n    $row = $stmt->fetch(PDO::FETCH_ASSOC);\n    $real_as_float = (false === stristr($row['_mode'], \"REAL_AS_FLOAT\")) ? false : true;\n    test_type($db, 100, 'REAL ZEROFILL', -1.01, NULL, '/^[0]*0$/');\n    test_type($db, 110, 'REAL ZEROFILL', 1.01, NULL, ($real_as_float) ? '/^[0]*1\\.0.*$/' : '/^[0]*1\\.01$/');\n    test_type($db, 120, 'REAL UNSIGNED ZEROFILL', 1.01, NULL, ($real_as_float) ? '/^[0]*1\\..*$/' : '/^[0]*1\\.01$/');\n    test_type($db, 130, 'DOUBLE ZEROFILL', -1.01, NULL, '/^[0]*0$/');\n    test_type($db, 140, 'DOUBLE ZEROFILL', 1.01, NULL, '/^[0]*1\\.01$/');\n    test_type($db, 150, 'DOUBLE UNSIGNED ZEROFILL', 1.01, NULL, '/^[0]*1\\.01$/');\n    test_type($db, 160, 'FLOAT ZEROFILL', -1.01, NULL, '/^[0]*0$/');\n    test_type($db, 170, 'FLOAT ZEROFILL', 1, NULL, '/^[0]*1$/');\n    test_type($db, 180, 'FLOAT UNSIGNED ZEROFILL', -1, NULL, '/^[0]*0$/');\n    test_type($db, 190, 'DECIMAL ZEROFILL', -1.01, NULL, '/^[0]*0$/');\n    test_type($db, 200, 'DECIMAL ZEROFILL', 1.01, NULL, '/^[0]*1$/');\n    test_type($db, 210, 'DECIMAL UNSIGNED ZEROFILL', 1.01, NULL, '/^[0]*1$/');\n    test_type($db, 220, 'NUMERIC ZEROFILL', -1, NULL, '/^[0]*0$/');\n    test_type($db, 230, 'NUMERIC ZEROFILL', 1, NULL, '/^[0]*1$/');\n    test_type($db, 240, 'NUMERIC UNSIGNED ZEROFILL', 1.01, NULL, '/^[0]*1$/');\n    echo \"done!\\n\";\n?>")).toMatchSnapshot();
  });
});
