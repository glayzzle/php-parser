// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // Zend/tests/019.phpt
  it("Test unset(), empty() and isset() functions", function () {
    expect(parser.parseCode("<?php\necho \"*** Testing unset(), empty() & isset() with scalar variables ***\\n\";\n// testing scalar variables\n$scalar_variables = array(\n  0,\n  1,\n  +1\n  -1,\n  0x55,\n  -0xFA,\n  0123,\n  -0563,\n  0.0,\n  1e5,\n  1E-5,\n  -1.5e5,\n  +5.6,\n  \"\",\n  '',\n  \" \",\n  ' ',\n  \"string\",\n  \"123\",\n  \"0\",\n  \"ture\",\n  \"FALSE\",\n  \"NULL\",\n  \"null\",\n  true,\n  false,\n  TRUE,\n  FALSE\n);\n$loop_counter = 1;\nforeach ($scalar_variables as $scalar_var) {\n  $set_var = 10; // this variable to use with isset\n  echo \"-- Iteration $loop_counter --\\n\"; $loop_counter++;\n  // checking with isset before unsetting, expected: bool(true)\n  var_dump( isset($scalar_var) );\n  var_dump( isset($scalar_var, $set_var) );\n  // checking if the var is empty, expected: bool(false) on most\n  // except \"\", 0, \"0\", NULL, FALSE\n  var_dump( empty($scalar_var) );\n  // destroy the variable using unset\n  unset( $scalar_var );\n  // dump and see if its destroyed, expcted: NULL\n  var_dump( $scalar_var );\n  // check using isset to see if unset, expected: bool(false)\n  var_dump( isset($scalar_var) );\n  var_dump( isset($scalar_var, $set_var) );\n  // empty to check if empty, expecting bool(true)\n  var_dump( empty($scalar_var) );\n  // isset() with two args, one arg only unset, expected: bool(false)\n  var_dump( isset($scalar_var, $set_var) );\n  // isset() with two args, both args already unset, expected: bool(false);\n  unset($set_var);\n  var_dump( isset($scalar_var, $set_var) );\n}\necho \"\\n*** Testing unset(), empty() & isset() with arrays ***\\n\";\n$array_variables = array(\n  array(),\n  array(NULL),\n  array(0),\n  array(\"0\"),\n  array(\"\"),\n  array(1,2,3,4),\n  array(1.4,2.5,5.6),\n  array(1 => \"One\", 2 => \"two\"),\n  array(\"Name\" => \"Jack\", \"Age\" => \"30\"),\n  array(1,2, \"One\" => \"1\", 2 => \"two\", \"\"=>\"empty\", \"\" => '')\n);\n$outer_loop_counter = 1;\nforeach ($array_variables as $array_var) {\n  echo \"--- Outerloop Iteration $outer_loop_counter ---\\n\";\n  // check the isset and unset on non existing key\n  $var = 1;  // a var which is defined\n  // try to unset the element which is non-existent\n  unset($array_var['non_existent']);\n  // check using isset() & empty() on a non_existent element in the array\n  var_dump( isset($array_var['non_existent']) );\n  var_dump( isset($array_var['non_existent'], $var) );\n  var_dump( isset($array_var['non_existent'], $array_var['none']) );\n  var_dump( empty($array_var['non_existent']) );\n  // testing empty and isset on arrays\n  var_dump( empty($array_var) ); // expecting bool(false), except: array(), which is considered empty\n  var_dump( isset($array_var) ); // expecting bool(true), except: array(), which is not set\n  // get the keys of the $array_var\n  $keys = array_keys($array_var);\n  // unset each element in the array and see the working of unset, isset & empty\n  $inner_loop_counter = 1;\n  foreach ($keys as $key_value) {\n    echo \"-- Innerloop Iteration $inner_loop_counter of Outerloop Iteration $outer_loop_counter --\\n\";\n    $inner_loop_counter++;\n    // unset the element\n    unset($array_var[$key_value]);\n    // dump the array after element was unset\n    var_dump($array_var);\n    // check using isset for the element that was unset\n    var_dump( isset($array_var[$key_val]) ); // expected: bool(false)\n    // calling isset with more args\n    var_dump( isset($array_var[$key_val], $array_var) ); //expected: bool(false)\n    // calling empty, expected bool(true)\n    var_dump( empty($array_var[$key_val]) );\n    // dump the array to see that that array did not get modified\n    // because of using isset, empty and unset on its element\n    var_dump($array_var);\n  }\n  $outer_loop_counter++;\n  // unset the whole array\n  unset($array_var);\n  // dump the array to see its unset\n  var_dump($array_var);\n  // use isset to see that array is not set\n  var_dump( isset($array_var) ); //expected: bool(false)\n  var_dump( isset($array_var, $array_var[$key_val]) ); // expected: bool(false)\n  // empty() to see if the array is empty\n  var_dump( empty($array_var) ); // expected: bool(true)\n}\necho \"\\n*** Testing unset(), empty() & isset() with resource variables ***\\n\";\n$fp = fopen(__FILE__, \"r\");\n$dfp = opendir( __DIR__ );\n$resources = array (\n  $fp,\n  $dfp\n);\n$loop_counter = 1;\nforeach ($resources as $resource) {\n  $temp_var = 10;\n  echo \"-- Iteration $loop_counter --\\n\"; $loop_counter++;\n  //dump the resource first\n  var_dump($resource);\n  // check using isset() and empty()\n  var_dump( isset($resource) );  // expected: bool(true)\n  var_dump( empty($resource) );  // expected: bool(false)\n  // call isset() with two args, both set\n  var_dump( isset($resource, $temp_var) ); // expected: bool(true)\n  // dump the resource to see using isset() and empty () had no effect on it\n  var_dump($resource);\n  // unset the resource\n  unset($resource);\n  // check using isset() and empty()\n  var_dump( isset($resource) );  // expected: bool(flase)\n  var_dump( empty($resource) );  // expected: bool(true)\n  // call isset() with two args, but one set\n  var_dump( isset($resource, $temp_var) ); // expected: bool(false)\n  // uset the temp_var\n  unset($temp_var);\n  // now the isset() with both the args as unset\n  var_dump( isset($resource, $temp_var) ); // expected: bool(false);\n  // dump the resource to see if there any effect on it\n  var_dump($resource);\n}\n// unset and dump the array containing all the resources to see that\n// unset works correctly\nunset($resources);\nvar_dump($resources);\nvar_dump( isset($resources) );  //expected: bool(false)\nvar_dump( empty($resources) );  // expected: bool(true)\necho \"\\n*** Testing unset(), empty() & isset() with objects ***\\n\";\nclass Point\n{\n  var $x;\n  var $y;\n  var $lable;\n  function __construct($x, $y) {\n    $this->x = $x;\n    $this->y = $y;\n  }\n  function setLable($lable) {\n    $this->lable = $lable;\n  }\n  function testPoint() {\n    echo \"\\nPoint::testPoint() called\\n\";\n  }\n}\n$point1 = new Point(30,40);\n// use unset/empty/isset to check the object\nvar_dump($point1); // dump the object\n// check the object and member that is not set\nvar_dump( isset($point1) );  // expected: bool(true)\nvar_dump( empty($point1) );  // expected: bool(false)\nvar_dump( isset($point1->$lable) );  //expected: bool(flase)\nvar_dump( empty($point1->$lable) );  //expected: bool(true)\n//set the member variable lable and check\n$point1->setLable(\"Point1\");\nvar_dump( isset($point1->$lable) );  //expected: bool(true)\nvar_dump( empty($point1->$lable) );  //expected: bool(false)\n// dump the object to see that obj was not harmed\n// because of the usage of the isset & empty\nvar_dump($point1);\n//unset a member and check\nunset($point1->x);\n// dump the point to see that variable was unset\nvar_dump($point1);\nvar_dump( isset($point1->x) );  // expected: bool(false)\nvar_dump( empty($point1->x) );  // expected: bool(true)\n// unset all members and check\nunset($point1->y);\nunset($point1->lable);\n// dump the object to check that all variables are unset\nvar_dump($point1);\nvar_dump( isset($point1) );  // expected: bool(ture)\nvar_dump( empty($point1) );  // expected: bool(false)\n//unset the object and check\nunset($point1);\nvar_dump( isset($point1) );  // expected: bool(false)\nvar_dump( empty($point1) );  // expected: bool(true)\n// dump to see that object is unset\nvar_dump($point1);\n// try isset/unset/empty on a member function\n$point2 = new Point(5,6);\nvar_dump( isset($point2->testPoint) );\nvar_dump( empty($point2->testPoint) );\nunset($point2->testPoint);\nvar_dump( isset($point2->testPoint) );\nvar_dump( empty($point2->testPoint) );\n// use get_class_methods to see effect if any\nvar_dump( get_class_methods($point2) );\n// dump the object to see the effect, none expected\nvar_dump($point2);\n/* testing variation in operation for isset(), empty() & unset().\nNote: Most of the variation for function unset() is testing by a\n      set of testcases named \"Zend/tests/unset_cv??.phpt\", only\n      variation not tested are attempted here */\necho \"\\n*** Testing possible variation in operation for isset(), empty() & unset() ***\\n\";\n/* unset() variation1: checking unset on static variable inside a function.\n * unset() destroys the variable only in the context of the rest of a function\n * Following calls will restore the previous value of a variable.\n */\necho \"\\n** Testing unset() variation 1: unset on static variable inside a function **\\n\";\nfunction test_unset1() {\n  static $static_var;\n  // increment the value of the static. this change is in function context\n  $static_var ++;\n  echo \"value of static_var before unset: $static_var\\n\";\n  // check using isset and empty\n  var_dump( isset($static_var) );\n  var_dump( empty($static_var) );\n  // unset the static var\n  unset($static_var);\n  echo \"value of static_var after unset: $static_var\\n\";\n  // check using isset and empty\n  var_dump( isset($static_var) );\n  var_dump( empty($static_var) );\n  // assign a value to static var\n  $static_var = 20;\n  echo \"value of static_var after new assignment: $static_var\\n\";\n}\n// call the functiont\ntest_unset1();\ntest_unset1();\ntest_unset1();\necho \"\\n** Testing unset() variation 2: unset on a variable passed by ref. inside of a function **\\n\";\n/* unset() variation2: Pass by reference\n * If a variable that is PASSED BY REFERENCE is unset() inside of a function,\n * only the local variable is destroyed. The variable in the calling environment\n * will retain the same value as before unset()  was called.\n */\nfunction test_unset2( &$ref_val ) {\n  // unset the variable passed\n  unset($ref_val);\n  // check using isset and empty to confirm\n  var_dump( isset($ref_val) );\n  var_dump( empty($ref_val) );\n  // set the value ot a new one\n  $ref_val = \"new value by ref\";\n}\n$value = \"value\";\nvar_dump($value);\ntest_unset2($value);\nvar_dump($value);\necho \"\\n** Testing unset() variation 3: unset on a global variable inside of a function **\\n\";\n/* unset() variation2: unset on a global variable inside a function\n * If a globalized variable is unset() inside of a function, only the\n * local variable is destroyed. The variable in the calling environment\n * will retain the same value as before unset() was called.\n */\n$global_var = 10;\nfunction test_unset3() {\n  global $global_var;\n  // check the $global_var using isset and empty\n  var_dump( isset($global_var) );\n  var_dump( empty($global_var) );\n  // unset the global var\n  unset($global_var);\n  // check the $global_var using isset and empty\n  var_dump( isset($global_var) );\n  var_dump( empty($global_var) );\n}\nvar_dump($global_var);\ntest_unset3();\nvar_dump($global_var);\n//Note: No error conditions relating to passing arguments can be tested\n// because these are not functions but statements, it will result in syntax error.\n?>")).toMatchSnapshot();
  });
});
