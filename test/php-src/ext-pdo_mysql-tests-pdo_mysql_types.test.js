// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/pdo_mysql/tests/pdo_mysql_types.phpt
  it("MySQL PDO->exec(), native types wo ZEROFILL", function () {
    expect(parser.parseCode("<?php\n    require_once(__DIR__ . DIRECTORY_SEPARATOR . 'mysql_pdo_test.inc');\n    function test_type(&$db, $offset, $sql_type, $value, $ret_value = NULL, $pattern = NULL, $alternative_type = NULL) {\n        $db->exec('DROP TABLE IF EXISTS test');\n        $sql = sprintf('CREATE TABLE test(id INT, label %s) ENGINE=%s', $sql_type, MySQLPDOTest::getTableEngine());\n        @$db->exec($sql);\n        if ($db->errorCode() != 0) {\n            // not all MySQL Server versions and/or engines might support the type\n            return true;\n        }\n        $stmt = $db->prepare('INSERT INTO test(id, label) VALUES (?, ?)');\n        $stmt->bindValue(1, $offset);\n        $stmt->bindValue(2, $value);\n        if (!$stmt->execute()) {\n            printf(\"[%03d + 1] INSERT failed, %s\\n\", $offset, var_export($stmt->errorInfo(), true));\n            return false;\n        }\n        $db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, false);\n        $stmt = $db->query('SELECT  id, label FROM test');\n        $row = $stmt->fetch(PDO::FETCH_ASSOC);\n        $stmt->closeCursor();\n        if (!isset($row['id']) || !isset($row['label'])) {\n            printf(\"[%03d + 2] Fetched result seems wrong, dumping result: %s\\n\", $offset, var_export($row, true));\n            return false;\n        }\n        if ($row['id'] != $offset) {\n            printf(\"[%03d + 3] Expecting %s got %s\\n\", $offset, $row['id']);\n            return false;\n        }\n        if (!is_null($pattern)) {\n            if (!preg_match($pattern, $row['label'])) {\n                printf(\"[%03d + 5] Value seems wrong, accepting pattern %s got %s, check manually\\n\",\n                    $offset, $pattern, var_export($row['label'], true));\n                return false;\n            }\n        } else {\n            $exp = $value;\n            if (!is_null($ret_value)) {\n                // we expect a different return value than our input value\n                // typically the difference is only the type\n                $exp = $ret_value;\n            }\n            if ($row['label'] !== $exp && !is_null($alternative_type) && gettype($row['label']) != $alternative_type) {\n                printf(\"[%03d + 4] %s - input = %s/%s, output = %s/%s (alternative type: %s)\\n\", $offset,\n                    $sql_type, var_export($exp, true), gettype($exp),\n                    var_export($row['label'], true), gettype($row['label']),\n                    $alternative_type);\n                return false;\n            }\n        }\n        $db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, true);\n        $stmt = $db->query('SELECT id, label FROM test');\n        $row_string = $stmt->fetch(PDO::FETCH_ASSOC);\n        $stmt->closeCursor();\n        if (is_null($pattern) && ($row['label'] != $row_string['label'])) {\n            printf(\"%s - STRINGIGY = %s, NATIVE = %s\\n\", $sql_type, var_export($row_string['label'], true), var_export($row['label'], true));\n            return false;\n        } else if (!is_null($pattern) && !preg_match($pattern, $row_string['label'])) {\n            printf(\"%s - STRINGIGY = %s, NATIVE = %s, pattern '%s'\\n\", $sql_type, var_export($row_string['label'], true), var_export($row['label'], true), $pattern);\n            return false;\n        }\n        return true;\n    }\n    $db = MySQLPDOTest::factory();\n    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n    $db->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);\n    $db->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, false);\n/*\n    test_type($db, 20, 'BIT(8)', 1);\n*/\n    $is_mysqlnd = MySQLPDOTest::isPDOMySQLnd();\n    test_type($db, 30, 'TINYINT', -127, ($is_mysqlnd) ? -127: '-127');\n    test_type($db, 40, 'TINYINT UNSIGNED', 255, ($is_mysqlnd) ? 255 : '255');\n    test_type($db, 50, 'BOOLEAN', 1, ($is_mysqlnd) ? 1 : '1');\n    test_type($db, 60, 'SMALLINT', -32768, ($is_mysqlnd) ? -32768 : '-32768');\n    test_type($db, 70, 'SMALLINT UNSIGNED', 65535, ($is_mysqlnd) ? 65535 : '65535');\n    test_type($db, 80, 'MEDIUMINT', -8388608, ($is_mysqlnd) ? -8388608 : '-8388608');\n    test_type($db, 90, 'MEDIUMINT UNSIGNED', 16777215, ($is_mysqlnd) ? 16777215 : '16777215');\n    test_type($db, 100, 'INT', -2147483648,\n        ($is_mysqlnd) ? ((PHP_INT_SIZE > 4) ? (int)-2147483648 : (double)-2147483648) : '-2147483648',\n        NULL, ($is_mysqlnd) ? 'integer' : NULL);\n    test_type($db, 110, 'INT UNSIGNED', 4294967295, ($is_mysqlnd) ? ((PHP_INT_SIZE > 4) ? 4294967295 : '4294967295') : '4294967295');\n    // no chance to return int with the current PDO version - we are forced to return strings\n    test_type($db, 120, 'BIGINT', 1, ($is_mysqlnd) ? 1 : '1');\n    // to avoid trouble with  numeric ranges, lets pass the numbers as a string\n    test_type($db, 130, 'BIGINT', '-9223372036854775808', NULL, '/^\\-9[\\.]*22/');\n    test_type($db, 140, 'BIGINT UNSIGNED', '18446744073709551615', NULL, '/^1[\\.]*844/');\n    test_type($db, 150, 'REAL', -1.01, ($is_mysqlnd) ? -1.01 : '-1.01');\n    test_type($db, 160, 'REAL UNSIGNED', 1.01, ($is_mysqlnd) ? 1.01 : '1.01');\n    test_type($db, 170, 'DOUBLE', -1.01, ($is_mysqlnd) ? -1.01 : '-1.01');\n    test_type($db, 180, 'DOUBLE UNSIGNED', 1.01, ($is_mysqlnd) ? 1.01 : '1.01');\n    test_type($db, 210, 'FLOAT', -1.01, NULL, '/^\\-1.0\\d+/');\n    test_type($db, 220, 'FLOAT UNSIGNED', 1.01, NULL, '/^1.0\\d+/');\n    test_type($db, 250, 'DECIMAL', -1.01, '-1');\n    test_type($db, 260, 'DECIMAL UNSIGNED', 1.01, '1');\n    test_type($db, 290, 'NUMERIC', -1.01, '-1');\n    test_type($db, 300, 'NUMERIC UNSIGNED', 1.01, '1');\n    test_type($db, 330, 'DATE', '2008-04-23');\n    test_type($db, 340, 'TIME', '14:37:00');\n    test_type($db, 350, 'TIMESTAMP', '2008-05-06 21:09:00');\n    test_type($db, 360, 'DATETIME', '2008-03-23 14:38:00');\n    test_type($db, 370, 'YEAR', 2008, ($is_mysqlnd) ? 2008 : '2008');\n    test_type($db, 380, 'CHAR(1)', 'a');\n    test_type($db, 390, 'CHAR(10)', '0123456789');\n    test_type($db, 400, 'CHAR(255)', str_repeat('z', 255));\n    test_type($db, 410, 'VARCHAR(1)', 'a');\n    test_type($db, 420, 'VARCHAR(10)', '0123456789');\n    test_type($db, 430, 'VARCHAR(255)', str_repeat('z', 255));\n    test_type($db, 440, 'BINARY(1)', str_repeat('a', 1));\n    test_type($db, 450, 'BINARY(255)', str_repeat('b', 255));\n    test_type($db, 460, 'VARBINARY(1)', str_repeat('a', 1));\n    test_type($db, 470, 'VARBINARY(255)', str_repeat('b', 255));\n    test_type($db, 480, 'TINYBLOB', str_repeat('b', 255));\n    test_type($db, 490, 'BLOB', str_repeat('b', 256));\n    test_type($db, 500, 'MEDIUMBLOB', str_repeat('b', 256));\n    test_type($db, 510, 'LONGBLOB', str_repeat('b', 256));\n    test_type($db, 520, 'TINYTEXT', str_repeat('b', 255));\n    test_type($db, 530, 'TINYTEXT BINARY', str_repeat('b', 255));\n    test_type($db, 560, 'TEXT', str_repeat('b', 256));\n    test_type($db, 570, 'TEXT BINARY', str_repeat('b', 256));\n    test_type($db, 580, 'MEDIUMTEXT', str_repeat('b', 256));\n    test_type($db, 590, 'MEDIUMTEXT BINARY', str_repeat('b', 256));\n    test_type($db, 600, 'LONGTEXT', str_repeat('b', 256));\n    test_type($db, 610, 'LONGTEXT BINARY', str_repeat('b', 256));\n    test_type($db, 620, \"ENUM('yes', 'no') DEFAULT 'yes'\", 'no');\n    test_type($db, 630, \"SET('yes', 'no') DEFAULT 'yes'\", 'no');\n    test_type($db, 640, 'DECIMAL(3,2)', -1.01, '-1.01');\n    echo \"done!\\n\";\n?>")).toMatchSnapshot();
  });
});
