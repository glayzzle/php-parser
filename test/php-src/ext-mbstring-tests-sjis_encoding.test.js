// eslint-disable prettier/prettier
const parser = require("../main");

describe("php-src tests", function () {
  // ext/mbstring/tests/sjis_encoding.phpt
  it("Exhaustive test of Shift-JIS encoding verification and conversion", function () {
    expect(parser.parseCode("<?php\nsrand(999); /* Make results consistent */\ninclude('encoding_tests.inc');\nmb_substitute_character(0x25); // '%'\n/* Read in the table of all characters in Shift-JIS */\nreadConversionTable(__DIR__ . '/data/SHIFTJIS.txt', $validChars, $fromUnicode);\nfor ($i = 0; $i < 0x20; $i++) {\n  $validChars[chr($i)] = \"\\x00\" . chr($i);\n  $fromUnicode[\"\\x00\" . chr($i)] = chr($i);\n}\n/* U+007E is TILDE; convert to Shift-JIS 0x8160 (WAVE DASH) */\n$fromUnicode[\"\\x00\\x7E\"] = \"\\x81\\x60\";\n/* DEL character */\n$validChars[\"\\x7F\"] = \"\\x00\\x7F\";\n$fromUnicode[\"\\x00\\x7F\"] = \"\\x7F\";\n/* U+00AF is MACRON; Shift-JIS 0x7E is overline */\n$fromUnicode[\"\\x00\\xAF\"] = \"\\x7E\";\n/* Use fullwidth reverse solidus, not (halfwidth) backslash (0x5C) */\n$validChars[\"\\x81\\x5F\"] = \"\\xFF\\x3C\";\n$fromUnicode[\"\\xFF\\x3C\"] = \"\\x81\\x5F\";\n/* Unicode has both halfwidth and fullwidth NOT SIGN; convert both of them\n * to JIS X 0208 NOT SIGN */\n$fromUnicode[\"\\xFF\\xE2\"] = \"\\x81\\xCA\";\n/* Likewise for fullwidth and halfwidth POUND SIGN */\n$fromUnicode[\"\\xFF\\xE1\"] = \"\\x81\\x92\";\n/* Likewise for fullwidth and halfwidth CENT SIGN */\n$fromUnicode[\"\\xFF\\xE0\"] = \"\\x81\\x91\";\n/* Convert Unicode FULLWIDTH TILDE to JIS X 0208 WAVE DASH */\n$fromUnicode[\"\\xFF\\x5E\"] = \"\\x81\\x60\";\n/* Convert Unicode FULLWIDTH HYPHEN-MINUS to JIS X 0208 MINUS SIGN */\n$fromUnicode[\"\\xFF\\x0D\"] = \"\\x81\\x7C\";\n/* Convert Unicode PARALLEL TO to JIS X 0208 DOUBLE VERTICAL LINE */\n$fromUnicode[\"\\x22\\x25\"] = \"\\x81\\x61\";\ntestAllValidChars($validChars, 'Shift-JIS', 'UTF-16BE');\necho \"SJIS verification and conversion works on all valid characters\\n\";\nfindInvalidChars($validChars, $invalidChars, $truncated,\n  array_fill_keys(range(0x81, 0x9F), 2) + array_fill_keys(range(0xE0, 0xEF), 2));\ntestAllInvalidChars($invalidChars, $validChars, 'Shift-JIS', 'UTF-16BE', \"\\x00%\");\ntestTruncatedChars($truncated, 'Shift-JIS', 'UTF-16BE', \"\\x00%\");\necho \"SJIS verification and conversion works on all invalid characters\\n\";\ntestAllValidChars($fromUnicode, 'UTF-16BE', 'Shift-JIS', false);\necho \"Unicode -> SJIS conversion works on all valid characters\\n\";\nfindInvalidChars($fromUnicode, $invalidChars, $unused, array_fill_keys(range(0, 0xFF), 2));\nconvertAllInvalidChars($invalidChars, $fromUnicode, 'UTF-16BE', 'Shift-JIS', '%');\necho \"Unicode -> SJIS conversion works on all invalid characters\\n\";\ntestValidString(\"\\xFF\\x5E\", \"\\x81\\x60\", 'UTF-16BE', 'SJIS', false);\necho \"Other mappings from Unicode -> SJIS are OK\\n\";\n// Test \"long\" illegal character markers\nmb_substitute_character(\"long\");\nconvertInvalidString(\"\\x80\", \"%\", \"Shift-JIS\", \"UTF-8\");\nconvertInvalidString(\"\\x81\\x20\", \"%\", \"Shift-JIS\", \"UTF-8\");\nconvertInvalidString(\"\\xEA\\xA9\", \"%\", \"Shift-JIS\", \"UTF-8\");\necho \"Done!\\n\";\n?>")).toMatchSnapshot();
  });
});
